# Asaki Framework

## 项目概述

**Asaki Framework** 是一个专为Unity游戏开发设计的高性能、模块化游戏框架。框架采用微内核架构，提供了一套完整的服务容器、事件系统、响应式属性、对象池、图系统和时钟系统等核心组件。

### 核心特性
- **极速微内核服务容器** (AsakiContext): 采用Copy-On-Write + Snapshot Swap架构，读操作无锁，写操作有锁
- **高性能事件总线** (AsakiBroker): 泛型静态桶设计，无GC分配，支持线程安全的事件发布/订阅
- **响应式属性系统** (MVVM): 强类型响应式属性，支持Action委托和IAsakiObserver接口两种观察模式
- **智能对象池** (AsakiSmartPool): 支持异步操作、超时回收和统计管理的智能对象池
- **可视化图系统** (Graphs): 支持节点编辑、数据流和黑板系统的可视化图系统
- **统一时钟系统** (Simulation): 支持优先级排序的Tick和FixedTick系统，统一管理游戏逻辑更新

### 技术架构
- **分层架构**: Core(核心层) → Unity(Unity桥接层) → Editor(编辑器层)
- **模块化设计**: 每个功能模块独立成包，通过.asmdef程序集定义文件管理依赖
- **代码生成**: 支持音频ID、UIID等枚举的自动生成
- **性能优先**: 大量使用AggressiveInlining、对象池、无锁设计等性能优化手段

## 项目结构

```
E:\Projects\UnityGame\Asaki\Assets\Asaki\
├───CodeGen\                    # 代码生成器DLL
│   ├───Asaki.CodeGen.dll
│   └───Asaki.CodeGen.pdb
├───Core\                      # 核心框架层
│   ├───Asaki.Core.asmdef      # 核心程序集定义
│   ├───Attributes\            # 框架属性标记
│   ├───Audio\                 # 音频服务接口
│   ├───Blackboard\            # 黑板数据系统
│   ├───Broker\                # 事件总线系统
│   ├───Configuration\         # 配置服务接口
│   ├───Context\               # 服务容器
│   ├───Coroutines\            # 协程服务接口
│   ├───Graphs\                # 可视化图系统
│   ├───MVVM\                  # 响应式属性系统
│   ├───Pooling\               # 对象池系统
│   ├───Resources\             # 资源服务接口
│   ├───Serialization\         # 序列化服务接口
│   ├───Simulation\            # 时钟系统
│   └───UI\                    # UI服务接口
├───Docs\                      # 框架文档
│   └───01-Core\               # 核心模块文档
├───Editor\                    # 编辑器扩展
│   └───Asaki.Editor.asmdef    # 编辑器程序集定义
├───Generated\                 # 自动生成的代码
│   ├───Asaki.Generated.asmdef # 生成代码程序集定义
│   ├───AudioID.cs             # 音频ID枚举
│   └───UIID.cs                # UIID枚举
└───Unity\                     # Unity桥接层
    └───Asaki.Unity.asmdef     # Unity桥接程序集定义
```

## 核心模块详解

### 1. AsakiContext - 服务容器 (Core/Context/)
**位置**: `Core/Context/AsakiContext.cs`

**核心特性**:
- 极速微内核设计，读操作无锁 (O(1))
- Copy-On-Write写入机制，写操作有锁 (O(n))
- 支持服务注册、获取、替换和懒加载
- 支持模块生命周期管理 (IAsakiModule)
- 支持容器冻结，防止运行时随意注册服务

**关键API**:
```csharp
// 注册服务
AsakiContext.Register<T>(T service);
AsakiContext.Register(Type type, IAsakiService service);

// 获取服务
T AsakiContext.Get<T>();
bool AsakiContext.TryGet<T>(out T service);

// 懒加载获取
T AsakiContext.GetOrRegister<T>(Func<T> factory);

// 替换服务 (热更新)
AsakiContext.Replace<T>(T service);

// 容器控制
AsakiContext.Freeze();  // 冻结容器
AsakiContext.ClearAll(); // 清空所有服务
```

**使用场景**: 服务注册、模块管理、依赖注入

### 2. AsakiBroker - 事件总线 (Core/Broker/)
**位置**: `Core/Broker/AsakiBroker.cs`

**核心特性**:
- 泛型静态桶设计，每种事件类型独立存储
- 无GC分配，事件必须是struct
- 发布操作无锁，订阅/取消订阅有锁
- 支持异常处理委托
- 支持Roslyn代码生成自动订阅

**关键API**:
```csharp
// 发布事件
AsakiBroker.Publish<T>(T e) where T : struct, IAsakiEvent;

// 订阅事件
AsakiBroker.Subscribe<T>(IAsakiHandler<T> handler) where T : struct, IAsakiEvent;

// 取消订阅
AsakiBroker.Unsubscribe<T>(IAsakiHandler<T> handler) where T : struct, IAsakiEvent;

// 异常处理
AsakiBroker.OnException = ex => { /* 处理异常 */ };

// 清理所有订阅
AsakiBroker.Cleanup();
```

**使用场景**: 模块间通信、UI事件、游戏状态变化、异步操作通知

### 3. MVVM - 响应式属性 (Core/MVVM/)
**位置**: `Core/MVVM/AsakiProperty.cs`

**核心特性**:
- 强类型泛型设计，支持两种观察模式
- 完整的相等性比较实现
- 禁止用作字典键（可变对象）
- 支持隐式类型转换
- 零GC设计（使用IAsakiObserver接口）

**关键API**:
```csharp
// 创建属性
var health = new AsakiProperty<int>(100);
var name = new AsakiProperty<string>("Player");

// 订阅变化（Action模式）
health.Subscribe(value => Debug.Log($"Health: {value}"));

// 绑定观察者（接口模式）
health.Bind(healthObserver);

// 设置值（自动触发通知）
health.Value = 80;

// 相等性比较
if (health == 100) { /* ... */ }
if (health == anotherHealth) { /* ... */ }

// 隐式转换
int currentHealth = health;
```

**使用场景**: UI数据绑定、状态管理、事件驱动编程

### 4. AsakiSmartPool - 智能对象池 (Core/Pooling/)
**位置**: `Core/Pooling/AsakiSmartPool.*.cs`

**核心特性**:
- 支持GameObject池化
- 支持IAsakiPoolable接口自定义初始化和清理
- 支持超时回收和后台维护
- 支持异步操作和协程集成
- 支持统计和监控

**关键API**:
```csharp
// 注册预制体
AsakiSmartPool.Register("enemy", enemyPrefab);

// 生成对象
var enemy = AsakiSmartPool.Spawn("enemy", position, rotation, parent);

// 回收对象
AsakiSmartPool.Despawn(enemy, "enemy");

// 清理池
AsakiSmartPool.Cleanup();

// 设置默认容量
AsakiSmartPool.SetDefaultCapacity(32);
```

**使用场景**: 频繁创建销毁的对象、粒子系统、子弹、敌人

### 5. Graphs - 可视化图系统 (Core/Graphs/)
**位置**: `Core/Graphs/AsakiGraphBase.cs`

**核心特性**:
- 支持节点式可视化编辑
- 支持数据流和黑板系统
- 运行时拓扑缓存，查询复杂度O(1)
- 支持多输出端口和单输出端口
- 支持反向连接查询

**关键API**:
```csharp
// 运行时初始化
graph.InitializeRuntime();

// 获取入口节点
var entryNode = graph.GetEntryNode<AsakiNodeBase>();

// 获取下一个节点（单输出）
var nextNode = graph.GetNextNode(currentNode, "Out");

// 获取所有下一个节点（多输出）
var nextNodes = graph.GetNextNodes(currentNode, "Broadcast");

// 获取节点通过GUID
var node = graph.GetNodeByGUID(guid);

// 获取输入连接
var edge = graph.GetInputConnection(targetNode, "InputPort");
```

**使用场景**: 行为树、对话系统、任务系统、技能系统

### 6. Simulation - 时钟系统 (Core/Simulation/)
**位置**: `Core/Simulation/AsakiSimulationManager.cs`

**核心特性**:
- 统一管理Tick和FixedTick
- 支持优先级排序（数值越小越先执行）
- 统一时钟源，解耦Unity时间系统
- 支持IAsakiTickable和IAsakiFixedTickable接口

**关键API**:
```csharp
// 注册Tick对象
simManager.Register(tickable, (int)TickPriority.Normal);
simManager.Register(tickable, customPriority);

// 注销Tick对象
simManager.Unregister(tickable);

// 执行Tick（通常由AsakiMonoDriver调用）
simManager.Tick(deltaTime);
simManager.FixedTick(fixedDeltaTime);
```

**优先级枚举**:
```csharp
public enum TickPriority {
    High = 0,      // 输入、传感器
    Normal = 1000, // 游戏逻辑、状态机
    Low = 2000,    // UI、音频、视图同步
}
```

**使用场景**: 游戏逻辑更新、物理模拟、状态机、AI行为

## 开发约定

### 1. 程序集依赖
- **Asaki.Core**: 无外部依赖，仅依赖.NET基础库
- **Asaki.Unity**: 依赖Unity Engine，提供Unity桥接实现
- **Asaki.Editor**: 依赖Unity Editor，提供编辑器扩展
- **Asaki.Generated**: 依赖Core和Unity，包含自动生成的代码

### 2. 命名规范
- 接口: `IAsakiXXX` (如: IAsakiService, IAsakiModule)
- 属性类: `AsakiXXXAttribute` (如: AsakiBindAttribute)
- 核心类: `AsakiXXX` (如: AsakiContext, AsakiBroker)
- 枚举: `XXXID` (如: AudioID, UIID)

### 3. 性能优化
- 热路径使用`[MethodImpl(MethodImplOptions.AggressiveInlining)]`
- 频繁创建的对象使用对象池
- 避免在Update中分配内存
- 使用struct代替class减少GC
- 使用volatile和lock确保线程安全

### 4. 代码生成
框架支持多种代码生成器：
- **音频ID生成**: 从音频资源生成AudioID枚举
- **UIID生成**: 从UI资源生成UIID枚举
- **事件订阅生成**: 使用Roslyn生成自动订阅/取消订阅代码
- **属性绑定生成**: 使用[AsakiBind]生成属性绑定代码

### 5. 版本定义
框架支持条件编译：
- `ASAKI_USE_UNITASK`: 启用UniTask异步支持
- `ASAKI_USE_ADDRESSABLE`: 启用Addressables资源系统支持

## 构建和运行

### Unity环境
1. 将Asaki文件夹放入Unity项目的Assets目录
2. Unity会自动识别.asmdef文件并编译程序集
3. 在Unity编辑器中使用框架功能

### 依赖管理
框架可选依赖：
- **UniTask**: 用于异步操作 (`com.cysharp.unitask`)
- **Addressables**: 用于资源管理 (`com.unity.addressables`)

在Unity Package Manager中添加这些包后，框架会自动启用相应的编译条件。

## 测试和验证

### 单元测试
框架核心层(Asaki.Core)不依赖Unity，可以编写标准单元测试：
```bash
# 使用dotnet test运行测试
dotnet test Asaki.Core.Tests
```

### 集成测试
Unity相关功能需要在Unity编辑器中测试：
1. 创建测试场景
2. 添加测试脚本
3. 在编辑器中运行测试

### 性能测试
框架内置性能监控：
- AsakiSmartPool支持统计生成/回收次数
- AsakiBroker支持事件发布监控
- AsakiContext支持服务查询性能分析

## 扩展和定制

### 添加新服务
1. 定义服务接口继承IAsakiService
2. 实现服务类
3. 在模块的OnInit中注册服务
4. 通过AsakiContext.Get<T>()获取服务

### 添加新模块
1. 实现IAsakiModule接口
2. 添加[AsakiModule]属性标记
3. 在OnInit中注册服务和依赖
4. 在OnInitAsync中执行异步初始化
5. 在OnDispose中清理资源

### 扩展图系统
1. 继承AsakiNodeBase创建新节点类型
2. 实现节点逻辑
3. 在编辑器中创建自定义节点视图
4. 使用AsakiGraphBase管理节点和连接

### 自定义代码生成
1. 继承框架的代码生成器基类
2. 实现资源扫描和代码生成逻辑
3. 在Unity编辑器中触发生成
4. 生成的代码自动放入Generated文件夹

## 最佳实践

### 1. 服务设计
- 保持服务接口简洁，遵循单一职责原则
- 使用接口抽象，避免直接依赖具体实现
- 服务应该是无状态的或线程安全的

### 2. 模块设计
- 模块应该自包含，有明确的依赖关系
- 在OnInit中只获取配置和注册服务
- 在OnInitAsync中执行耗时操作
- 在OnDispose中正确释放资源

### 3. 事件设计
- 事件应该是struct，避免GC分配
- 事件数据应该精简，只包含必要信息
- 使用强类型事件，避免使用object

### 4. 性能优化
- 频繁创建的对象使用对象池
- 避免在Update中分配内存
- 使用TryGet代替Get避免异常
- 合理使用优先级控制系统执行顺序

### 5. 代码生成
- 将生成的代码放入Generated文件夹
- 不要手动修改生成的代码
- 使用partial类扩展生成的代码
- 在版本控制中忽略生成的代码

## 常见问题

### Q: 服务注册失败，提示已存在？
A: 使用TryGet先检查服务是否已注册，或使用GetOrRegister实现懒加载。

### Q: 事件处理程序未被调用？
A: 检查事件类型是否正确实现IAsakiEvent接口，检查是否正确订阅。

### Q: 对象池对象状态异常？
A: 确保实现IAsakiPoolable接口，在OnSpawn和OnDespawn中正确重置状态。

### Q: 图系统查询性能低？
A: 确保调用InitializeRuntime()构建拓扑缓存，将查询复杂度降到O(1)。

### Q: Tick顺序不符合预期？
A: 检查优先级设置，数值越小越先执行，同优先级按注册顺序执行。

## 相关文档

- [Core模块文档](Docs/01-Core/)
- [服务接口文档](Core/)
- [编辑器扩展文档](Editor/)

## 版本信息

- **框架版本**: v5.1 Lock-Free Edition
- **最后更新**: 2025-12-23
- **作者**: Asaki Framework Team
- **许可证**: MIT License
