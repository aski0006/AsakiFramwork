using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Globalization;

namespace Asaki.CodeGen.Generators
{
	public static class AsakiSaveGenerator
	{
		// [Security] 系统级序列化口令 - 必须与 Service 中的定义一致
		private const string SYSTEM_PERMISSION_KEY = "ASAKI_SYS_KEY_9482_ACCESS";

		public static void Execute(GeneratorExecutionContext context, List<TypeDeclarationSyntax> candidates)
		{
			foreach (var typeDecl in candidates)
			{
				// 获取语义模型
				var model = context.Compilation.GetSemanticModel(typeDecl.SyntaxTree);
				var typeSymbol = model.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
				
				if (typeSymbol == null || !HasAsakiSaveAttribute(typeSymbol))
					continue;

				// 判断是否是 Config 类型 (需要生成特殊保护代码)
				bool isConfigType = IsConfigType(typeSymbol, context.Compilation);
				
				// 生成核心代码
				string source = GenerateClassCode(typeSymbol, isConfigType, context.Compilation);
				
				// 添加到编译上下文
				context.AddSource($"{typeSymbol.Name}_AsakiSave.g.cs", source);
			}
		}

		private static bool HasAsakiSaveAttribute(INamedTypeSymbol symbol)
		{
			return symbol.GetAttributes().Any(ad =>
				ad.AttributeClass?.Name == "AsakiSaveAttribute" ||
				ad.AttributeClass?.Name == "AsakiSave");
		}

		private static bool IsConfigType(ITypeSymbol typeSymbol, Compilation compilation)
		{
			if (typeSymbol == null) return false;
			
			// 查找 IAsakiConfig 接口符号
			var configInterface = compilation.GetTypeByMetadataName("Asaki.Core.Configuration.IAsakiConfig");
			if (configInterface == null) return false;

			// 检查接口实现 (包括基类)
			return typeSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, configInterface));
		}

		private static string GenerateClassCode(INamedTypeSymbol symbol, bool isConfigType, Compilation compilation)
		{
			string namespaceName = symbol.ContainingNamespace.ToDisplayString();
			string typeName = symbol.Name;
			string kind = symbol.IsValueType ? "struct" : "class";
			
			// 获取所有标记了 [AsakiSaveMember] 的成员
			var members = GetSaveMembers(symbol);

			// [关键修复] 排序逻辑：优先按 Order 排序，Order 相同按名称排序
			members.Sort((a, b) =>
			{
				var orderA = GetOrder(a);
				var orderB = GetOrder(b);
				if (orderA != orderB) return orderA.CompareTo(orderB);
				return String.Compare(a.Name, b.Name, StringComparison.Ordinal);
			});

			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine($"// 生成时间: {System.DateTime.Now.ToString(CultureInfo.InvariantCulture)}");
			sb.AppendLine("using Asaki.Core.Serialization;");
			sb.AppendLine("using Asaki.Core.MVVM;");
			sb.AppendLine("using UnityEngine;");
			sb.AppendLine("using System.Collections.Generic;");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.Linq;");
			sb.AppendLine();

			if (!symbol.ContainingNamespace.IsGlobalNamespace)
			{
				sb.AppendLine($"namespace {namespaceName}");
				sb.AppendLine("{");
			}

			sb.AppendLine($"    partial {kind} {typeName} : IAsakiSavable");
			sb.AppendLine("    {");

			// 1. 生成 Config 安全保护代码
			if (isConfigType)
			{
				GenerateConfigProtection(sb, typeName);
			}

			// 2. 生成 Serialize 方法
			GenerateSerializeMethod(sb, typeName, members, isConfigType, compilation);

			// 3. 生成 Deserialize 方法
			GenerateDeserializeMethod(sb, members, compilation);

			// 4. [新增] 生成 Clone 方法 (解决 Get 返回引用问题的核心)
			GenerateCloneMethod(sb, typeName, members, compilation, isConfigType);

			// 5. 生成引用解析 (Config Link)
			if (members.Any(m => IsConfigReferenceMember(m, compilation)))
			{
				GenerateResolveMethod(sb, members, compilation);
			}

			sb.AppendLine("    }");

			if (!symbol.ContainingNamespace.IsGlobalNamespace)
				sb.AppendLine("}");

			return sb.ToString();
		}

		// =========================================================
		// 代码块生成逻辑
		// =========================================================

		private static void GenerateConfigProtection(StringBuilder sb, string typeName)
		{
			sb.AppendLine("        // [AsakiConfig Protection]");
			sb.AppendLine("        private bool _allowConfigSerialization = false;");
			sb.AppendLine();
			sb.AppendLine("        public void AllowConfigSerialization(string permissionKey)");
			sb.AppendLine("        {");
			sb.AppendLine($"            if (permissionKey == \"{SYSTEM_PERMISSION_KEY}\")");
			sb.AppendLine("            {");
			sb.AppendLine("                _allowConfigSerialization = true;");
			sb.AppendLine("            }");
			sb.AppendLine("            else");
			sb.AppendLine("            {");
			sb.AppendLine($"                Debug.LogError($\"[AsakiSave] Security Alert: Invalid permission key '{{permissionKey}}' provided for config '{typeName}'. Serialization remains locked.\");");
			sb.AppendLine("            }");
			sb.AppendLine("        }");
			sb.AppendLine();
		}

		private static void GenerateSerializeMethod(StringBuilder sb, string typeName, List<ISymbol> members, bool isConfigType, Compilation compilation)
		{
			sb.AppendLine("        public void Serialize(IAsakiWriter writer)");
			sb.AppendLine("        {");
			
			if (isConfigType)
			{
				sb.AppendLine("            if (!_allowConfigSerialization)");
				sb.AppendLine("            {");
				sb.AppendLine($"                throw new InvalidOperationException(\"Security Violation: Configuration object '{typeName}' cannot be serialized without explicit system permission.\");");
				sb.AppendLine("            }");
				sb.AppendLine();
			}

			sb.AppendLine($"            writer.BeginObject(\"{typeName}\");");
			foreach (var m in members) GenerateWriteStatement(sb, m, compilation, 3);
			sb.AppendLine($"            writer.EndObject();");
			sb.AppendLine("        }");
			sb.AppendLine();
		}

		private static void GenerateDeserializeMethod(StringBuilder sb, List<ISymbol> members, Compilation compilation)
		{
			sb.AppendLine("        public void Deserialize(IAsakiReader reader)");
			sb.AppendLine("        {");
			foreach (var m in members) GenerateReadStatement(sb, m, compilation, 3);
			sb.AppendLine("        }");
			sb.AppendLine();
		}

		// [核心新增] 生成强类型 Clone 方法
		private static void GenerateCloneMethod(StringBuilder sb, string typeName, List<ISymbol> members, Compilation compilation, bool isConfigType)
		{
			sb.AppendLine($"        public {typeName} Clone()");
			sb.AppendLine("        {");
			sb.AppendLine($"            var target = new {typeName}();");
			
			foreach (var m in members)
			{
				var (type, name) = ParseMemberInfo(m);
				string indent = "            ";
				
				bool isAsakiProp = IsAsakiProperty(type, out var innerType);
				ITypeSymbol realType = isAsakiProp ? innerType : type;

				// 访问源数据
				string sourceAccess = isAsakiProp ? $"this.{name}?.Value" : $"this.{name}";
				string sourceCheck = isAsakiProp ? $"this.{name} != null" : $"this.{name} != null";

				// 准备目标属性 (如果是 AsakiProp，需要先 new)
				if (isAsakiProp)
				{
					sb.AppendLine($"{indent}if ({sourceCheck}) target.{name} = new AsakiProperty<{innerType.ToDisplayString()}>();");
				}

				// 处理 List 深/浅拷贝
				if (IsListType(realType, out var elementType))
				{
					string check = isAsakiProp ? $"if (this.{name}?.Value != null)" : $"if (this.{name} != null)";
					sb.AppendLine($"{indent}{check}");
					sb.AppendLine($"{indent}{{");
					
					// List 构造函数 new List<T>(IEnumerable<T>) 执行的是浅拷贝
					// 对于 Config 来说，因为存储的是 ID 或值类型，List 的浅拷贝已经足够安全
					if (isAsakiProp)
						sb.AppendLine($"{indent}    target.{name}.Value = new System.Collections.Generic.List<{elementType.ToDisplayString()}>({sourceAccess});");
					else
						sb.AppendLine($"{indent}    target.{name} = new System.Collections.Generic.List<{elementType.ToDisplayString()}>(this.{name});");
						
					sb.AppendLine($"{indent}}}");
				}
				// 处理普通字段
				else
				{
					// 直接赋值 (值类型是拷贝，string 是不可变引用，Config 对象是引用但后续会重解)
					if (isAsakiProp)
					{
						// 注意：如果是 ValueType，需要处理 Nullable 逻辑，但这里 sourceAccess 已经处理了 ?.Value
						// 如果 realType 是 struct，sourceAccess 可能是 null，所以需要判定
						if (realType.IsValueType)
							sb.AppendLine($"{indent}if (this.{name} != null) target.{name}.Value = this.{name}.Value;");
						else
							sb.AppendLine($"{indent}target.{name}.Value = this.{name}?.Value;");
					}
					else
					{
						sb.AppendLine($"{indent}target.{name} = this.{name};");
					}
				}
			}

			sb.AppendLine("            return target;");
			sb.AppendLine("        }");
			sb.AppendLine();
			
			if (isConfigType)
			{
				sb.AppendLine($"        Asaki.Core.Configuration.IAsakiConfig Asaki.Core.Configuration.IAsakiConfig.CloneConfig()");
				sb.AppendLine("        {");
				sb.AppendLine("            return this.Clone();");
				sb.AppendLine("        }");
				sb.AppendLine();
			}
		}

		private static void GenerateResolveMethod(StringBuilder sb, List<ISymbol> members, Compilation compilation)
		{
			sb.AppendLine("        public void ResolveConfigReferences(Asaki.Core.Configuration.IAsakiConfigService configService)");
			sb.AppendLine("        {");
			foreach (var m in members)
			{
				if (IsConfigReferenceMember(m, compilation)) GenerateResolveStatement(sb, m, compilation);
			}
			sb.AppendLine("        }");
		}

		// =========================================================
		// 读写语句生成细节
		// =========================================================

		private static void GenerateWriteStatement(StringBuilder sb, ISymbol member, Compilation compilation, int indentLevel)
		{
			var (type, name) = ParseMemberInfo(member);
			string keyName = name;
			string indent = new string(' ', indentLevel * 4);
			bool isAsakiProp = IsAsakiProperty(type, out var innerType);
			ITypeSymbol realType = isAsakiProp ? innerType : type;
			
			string valueAccess;
			if (isAsakiProp)
				valueAccess = realType.IsValueType 
					? $"(this.{name} != null ? this.{name}.Value : default({realType.ToDisplayString()}))" 
					: $"this.{name}?.Value";
			else
				valueAccess = $"this.{name}";

			// 1. Config 类型 -> 写 ID
			if (IsConfigType(realType, compilation))
			{
				string safeIdAccess = $"(({valueAccess}) != null ? ({valueAccess}).Id : -1)";
				sb.AppendLine($"{indent}writer.WriteInt(\"{keyName}Id\", {safeIdAccess});");
				return;
			}

			// 2. List 类型
			if (IsListType(realType, out var eType))
			{
				string listAccess = valueAccess;
				string listCount = $"({listAccess} != null ? {listAccess}.Count : 0)";

				if (IsConfigType(eType, compilation))
				{
					sb.AppendLine($"{indent}writer.BeginList(\"{keyName}Ids\", {listCount});");
					sb.AppendLine($"{indent}if ({listAccess} != null)");
					sb.AppendLine($"{indent}{{");
					sb.AppendLine($"{indent}    foreach (var item in {listAccess}) writer.WriteInt(\"Item\", item != null ? item.Id : -1);");
					sb.AppendLine($"{indent}}}");
					sb.AppendLine($"{indent}writer.EndList();");
					return;
				}

				sb.AppendLine($"{indent}writer.BeginList(\"{keyName}\", {listCount});");
				sb.AppendLine($"{indent}if ({listAccess} != null)");
				sb.AppendLine($"{indent}{{");
				sb.AppendLine($"{indent}    foreach (var item in {listAccess})");
				sb.AppendLine($"{indent}    {{");
				string ew = GetWriteMethod(eType);
				if (ew == "WriteObject") sb.AppendLine($"{indent}        writer.WriteObject(\"Item\", item);");
				else sb.AppendLine($"{indent}        writer.{ew}(\"Item\", item);");
				sb.AppendLine($"{indent}    }}");
				sb.AppendLine($"{indent}}}");
				sb.AppendLine($"{indent}writer.EndList();");
				return;
			}

			// 3. 普通类型
			string method = GetWriteMethod(realType);
			if (method == "WriteObject") sb.AppendLine($"{indent}writer.WriteObject(\"{keyName}\", {valueAccess});");
			else sb.AppendLine($"{indent}writer.{method}(\"{keyName}\", {valueAccess});");
		}

		private static void GenerateReadStatement(StringBuilder sb, ISymbol member, Compilation compilation, int indentLevel)
		{
			var (type, name) = ParseMemberInfo(member);
			string keyName = name;
			string indent = new string(' ', indentLevel * 4);
			bool isAsakiProp = IsAsakiProperty(type, out var innerType);
			ITypeSymbol realType = isAsakiProp ? innerType : type;
			string targetVar = isAsakiProp ? $"temp_{name}" : $"this.{name}";

			if (isAsakiProp) sb.AppendLine($"{indent}{realType.ToDisplayString()} {targetVar};");

			// 1. Config -> 读 ID
			if (IsConfigType(realType, compilation))
			{
				sb.AppendLine($"{indent}int {name}Id = reader.ReadInt(\"{keyName}Id\");");
				// ID 读取后暂存局部变量，不直接写入对象，等待 Resolve 阶段
				return;
			}

			// 2. List
			if (IsListType(realType, out var eType))
			{
				if (IsConfigType(eType, compilation))
				{
					sb.AppendLine($"{indent}int count_{name}Ids = reader.BeginList(\"{keyName}Ids\");");
					sb.AppendLine($"{indent}System.Collections.Generic.List<int> {name}Ids = new System.Collections.Generic.List<int>(count_{name}Ids);");
					sb.AppendLine($"{indent}for (int i = 0; i < count_{name}Ids; i++) {name}Ids.Add(reader.ReadInt(\"Item\"));");
					sb.AppendLine($"{indent}reader.EndList();");
					return;
				}

				string er = GetReadMethod(eType);
				string listType = $"System.Collections.Generic.List<{eType.ToDisplayString()}>";
				sb.AppendLine($"{indent}int count_{name} = reader.BeginList(\"{keyName}\");");
				
				if (isAsakiProp) sb.AppendLine($"{indent}{targetVar} = new {listType}(count_{name});");
				else
				{
					sb.AppendLine($"{indent}if ({targetVar} == null) {targetVar} = new {listType}(count_{name});");
					sb.AppendLine($"{indent}{targetVar}.Clear();");
				}

				sb.AppendLine($"{indent}for (int i = 0; i < count_{name}; i++)");
				sb.AppendLine($"{indent}{{");
				if (er == "ReadObject") sb.AppendLine($"{indent}    {targetVar}.Add(reader.ReadObject<{eType.ToDisplayString()}>(\"Item\"));");
				else sb.AppendLine($"{indent}    {targetVar}.Add(reader.{er}(\"Item\"));");
				sb.AppendLine($"{indent}}}");
				sb.AppendLine($"{indent}reader.EndList();");
			}
			else 
			{
				string method = GetReadMethod(realType);
				if (method == "ReadObject")
					sb.AppendLine($"{indent}{targetVar} = reader.ReadObject<{realType.ToDisplayString()}>(\"{keyName}\", {targetVar});");
				else
					sb.AppendLine($"{indent}{targetVar} = reader.{method}(\"{keyName}\");");
			}

			if (isAsakiProp)
			{
				sb.AppendLine($"{indent}if (this.{name} == null) this.{name} = new AsakiProperty<{realType.ToDisplayString()}>();");
				sb.AppendLine($"{indent}this.{name}.Value = {targetVar};");
			}
		}

		private static void GenerateResolveStatement(StringBuilder sb, ISymbol member, Compilation compilation)
		{
			var (type, name) = ParseMemberInfo(member);
			bool isAsakiProp = IsAsakiProperty(type, out var innerType);
			ITypeSymbol realType = isAsakiProp ? innerType : type;
			string interfaceType = GetInterfaceNameForMember(realType);
			string ensureProp = isAsakiProp ? $"if (this.{name} == null) this.{name} = new AsakiProperty<{realType.ToDisplayString()}>();" : "";
			string assignTarget = isAsakiProp ? $"this.{name}.Value" : $"this.{name}";

			if (IsListType(realType, out var elementType))
			{
				string genericType = GetInterfaceNameForMember(elementType);
				sb.AppendLine($"            if ({name}Ids != null)");
				sb.AppendLine("            {");
				if (isAsakiProp) sb.AppendLine($"                {ensureProp}");
				sb.AppendLine($"                {assignTarget} = new System.Collections.Generic.List<{interfaceType}>();");
				sb.AppendLine($"                foreach (var id in {name}Ids)");
				sb.AppendLine("                {");
				sb.AppendLine($"                    var config = configService.Get<{genericType}>(id);");
				sb.AppendLine($"                    if (config != null) {assignTarget}.Add(config);");
				sb.AppendLine("                }");
				sb.AppendLine("            }");
			}
			else
			{
				sb.AppendLine($"            if ({name}Id > 0)");
				sb.AppendLine("            {");
				if (isAsakiProp) sb.AppendLine($"                {ensureProp}");
				sb.AppendLine($"                {assignTarget} = configService.Get<{interfaceType}>({name}Id);");
				sb.AppendLine("            }");
			}
		}

		// =========================================================
		// 辅助方法 (Helpers)
		// =========================================================

		private static int GetOrder(ISymbol m)
		{
			var ad = m.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "AsakiSaveMemberAttribute" || a.AttributeClass?.Name == "AsakiSaveMember");
			if (ad == null) return int.MaxValue;

			// 1. 优先检查构造函数参数 [AsakiSaveMember(0)]
			if (ad.ConstructorArguments.Length > 0)
			{
				if (ad.ConstructorArguments[0].Value is int orderVal) return orderVal;
			}
			
			// 2. 检查命名参数 [AsakiSaveMember(order: 0)]
			if (ad.NamedArguments.Length > 0)
			{
				foreach (var arg in ad.NamedArguments)
				{
					// [修复] 忽略大小写检查 Order/order
					if (string.Equals(arg.Key, "Order", StringComparison.OrdinalIgnoreCase))
					{
						if (arg.Value.Value is int i) return i;
					}
				}
			}

			return int.MaxValue;
		}

		private static bool IsAsakiProperty(ITypeSymbol type, out ITypeSymbol innerType)
		{
			innerType = null;
			if (type is INamedTypeSymbol nt && nt.IsGenericType && nt.Name == "AsakiProperty")
			{
				innerType = nt.TypeArguments[0];
				return true;
			}
			return false;
		}

		private static bool IsListType(ITypeSymbol t, out ITypeSymbol e)
		{
			e = null;
			if (t is INamedTypeSymbol nt && nt.IsGenericType && (nt.Name == "List" || nt.Name.EndsWith("List")))
			{
				e = nt.TypeArguments[0];
				return true;
			}
			return false;
		}

		private static string GetInterfaceNameForMember(ITypeSymbol type)
		{
			string typeName = type.Name;
			return (typeName.StartsWith("I") && char.IsUpper(typeName[1])) ? typeName : "I" + typeName;
		}

		private static bool IsConfigReferenceMember(ISymbol member, Compilation compilation)
		{
			var (memberType, _) = ParseMemberInfo(member);
			if (IsAsakiProperty(memberType, out var innerType)) memberType = innerType;
			return IsConfigType(memberType, compilation) || (IsListType(memberType, out var elementType) && IsConfigType(elementType, compilation));
		}

		private static (ITypeSymbol T, string N) ParseMemberInfo(ISymbol m)
		{
			ITypeSymbol t = m is IFieldSymbol f ? f.Type : ((IPropertySymbol)m).Type;
			return (t, m.Name);
		}

		private static List<ISymbol> GetSaveMembers(INamedTypeSymbol s)
		{
			return s.GetMembers()
			        .Where(m => (m is IFieldSymbol || m is IPropertySymbol) &&
			                    m.GetAttributes().Any(ad =>
				                    ad.AttributeClass?.Name == "AsakiSaveMemberAttribute" ||
				                    ad.AttributeClass?.Name == "AsakiSaveMember"))
			        .ToList();
		}
		
		private static string GetWriteMethod(ITypeSymbol t)
		{
			string tn = t.ToDisplayString();
			switch (tn)
			{
				case "int": return "WriteInt";
				case "string": return "WriteString";
				case "float": return "WriteFloat";
				case "bool": return "WriteBool";
				case "long": return "WriteLong";
				case "double": return "WriteDouble";
				case "uint": return "WriteUInt";
				case "ulong": return "WriteULong";
				case "UnityEngine.Vector2": return "WriteVector2";
				case "UnityEngine.Vector3": return "WriteVector3";
				case "UnityEngine.Vector2Int": return "WriteVector2Int";
				case "UnityEngine.Vector3Int": return "WriteVector3Int";
				case "UnityEngine.Bounds": return "WriteBounds";
				case "UnityEngine.Quaternion": return "WriteQuaternion";
			}
			return "WriteObject";
		}

		private static string GetReadMethod(ITypeSymbol t)
		{
			string tn = t.ToDisplayString();
			switch (tn)
			{
				case "int": return "ReadInt";
				case "string": return "ReadString";
				case "float": return "ReadFloat";
				case "bool": return "ReadBool";
				case "long": return "ReadLong";
				case "double": return "ReadDouble";
				case "uint": return "ReadUInt";
				case "ulong": return "ReadULong";
				case "UnityEngine.Vector2": return "ReadVector2";
				case "UnityEngine.Vector3": return "ReadVector3";
				case "UnityEngine.Vector2Int": return "ReadVector2Int";
				case "UnityEngine.Vector3Int": return "ReadVector3Int";
				case "UnityEngine.Bounds": return "ReadBounds";
				case "UnityEngine.Quaternion": return "ReadQuaternion";
			}
			return "ReadObject";
		}
	}
}