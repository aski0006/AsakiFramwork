using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Asaki.CodeGen.Generators
{
    public static class AsakiConfigRegistryGenerator
    {
        // [Fix] 修正命名空间，确保能找到 IAsakiConfig
        // 请确保你的 IAsakiConfig 定义在 Asaki.Core.Configuration 命名空间下
        private const string CONFIG_INTERFACE_NAME = "Asaki.Core.Configuration.IAsakiConfig";

        public static void Execute(GeneratorExecutionContext context, List<ClassDeclarationSyntax> candidateConfigs)
        {
            if (candidateConfigs.Count == 0) return;

            var compilation = context.Compilation;
            var configInterfaceSymbol = compilation.GetTypeByMetadataName(CONFIG_INTERFACE_NAME);
            
            // [Debug] 如果找不到接口，可以在这里报个 Warning 方便排查
            if (configInterfaceSymbol == null) 
            {
                // 如果你的项目结构不同，可能是 "Asaki.Core.IAsakiConfig"
                // 建议检查 IAsakiConfig.cs 文件的 namespace 定义
                return;
            }

            var validConfigs = new List<INamedTypeSymbol>();
            var nameCollisionCheck = new HashSet<string>();

            foreach (var classDecl in candidateConfigs)
            {
                var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

                if (classSymbol == null || classSymbol.IsAbstract) continue;

                if (classSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, configInterfaceSymbol)))
                {
                    string configName = classSymbol.Name;

                    if (!nameCollisionCheck.Add(configName))
                    {
                        var descriptor = new DiagnosticDescriptor(
                            "ASAKI001",
                            "Duplicate Config Name",
                            $"Found duplicate config class name '{configName}'. Config class names must be unique.",
                            "AsakiConfig",
                            DiagnosticSeverity.Error,
                            true);
                        
                        context.ReportDiagnostic(Diagnostic.Create(descriptor, classDecl.GetLocation()));
                        continue;
                    }

                    validConfigs.Add(classSymbol);
                }
            }

            if (validConfigs.Count > 0)
            {
                string source = GenerateSource(validConfigs);
                context.AddSource("AsakiConfigRegistry.g.cs", source);
            }
        }

        private static string GenerateSource(List<INamedTypeSymbol> configs)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using Asaki.Unity.Services.Configuration;"); // 修正引用
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine();

            sb.AppendLine("namespace Asaki.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static class AsakiUserConfigLoader");
            sb.AppendLine("    {");
            sb.AppendLine("        #if UNITY_EDITOR");
            sb.AppendLine("        [UnityEditor.InitializeOnLoadMethod]");
            sb.AppendLine("        #endif");
            sb.AppendLine("        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]");
            sb.AppendLine("        private static void AutoRegister()");
            sb.AppendLine("        {");
            sb.AppendLine("            AsakiConfigRegistry.RegisterLoader(GetLoader);");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        private static Task GetLoader(AsakiConfigService service, string configName, string path)");
            sb.AppendLine("        {");
            sb.AppendLine("            switch (configName)");
            sb.AppendLine("            {");

            foreach (var config in configs)
            {
                string fullTypeName = config.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string configName = config.Name;

                sb.AppendLine($"                case \"{configName}\":");
                sb.AppendLine($"                    return service.LoadInternalAsync<{fullTypeName}>(path);");
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    return null;");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}