# Unity Scripts Aggregation
# Generated: 2025-12-25 18:57:30
# Total Files: 169
# Total Size: 702952 bytes

<!-- File: Asaki/Core/Attributes/AsakiBindAttribute.cs -->
<!-- GUID: b2858a74d27744e08a0c116abc7f4254 -->
<!-- Size: 274 bytes -->
<!-- Modified: 2025-12-19 22:43:48 -->
```csharp
using System;

namespace Asaki.Core
{
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public sealed class AsakiBindAttribute : Attribute
	{
		// 以后可以在这里添加参数，比如 [AsakiBind(GenerateUI = true)]
	}
}
```

<!-- File: Asaki/Core/Attributes/AsakiGraphContextAttribute.cs -->
<!-- GUID: a3663be5e2bf49da92f92ad304287b46 -->
<!-- Size: 1007 bytes -->
<!-- Modified: 2025-12-22 16:49:03 -->
```csharp
using System;

namespace Asaki.Core
{
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
	public class AsakiGraphContextAttribute : Attribute
	{
		public Type GraphType { get; private set; }
		public string Path { get; private set; }
		public AsakiGraphContextAttribute(Type graphType, string path)
		{
			GraphType = graphType;
			Path = path;
		}
	}

	[AttributeUsage(AttributeTargets.Field)]
	public class AsakiNodeInputAttribute : Attribute
	{
		public string PortName;
		public bool Multiple; // 是否允许多连
		public AsakiNodeInputAttribute(string name = "In", bool multiple = true)
		{
			PortName = name;
			Multiple = multiple;
		}
	}

	[AttributeUsage(AttributeTargets.Field)]
	public class AsakiNodeOutputAttribute : Attribute
	{
		public string PortName;
		public bool Multiple;
		public AsakiNodeOutputAttribute(string name = "Out", bool multiple = false)
		{
			PortName = name;
			Multiple = multiple;
		}
	}
}
```

<!-- File: Asaki/Core/Attributes/AsakiModuleAttribute.cs -->
<!-- GUID: 2cf2b05e1d6d47d680d0f387afeaba7c -->
<!-- Size: 1336 bytes -->
<!-- Modified: 2025-12-19 22:43:24 -->
```csharp
using System;

namespace Asaki.Core
{
	/// <summary>
	/// [Asaki 架构核心] 模块标记特性。
	/// 用于将一个类声明为 Asaki 系统模块，并定义其启动优先级和依赖关系。
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public sealed class AsakiModuleAttribute : Attribute
	{
		/// <summary>
		/// 初始化优先级。
		/// <para>值越小越早初始化 (0 > 100 > 1000)。</para>
		/// <para>注意：优先级仅在"同级"（无依赖关系）的模块间生效。依赖关系永远优于优先级。</para>
		/// </summary>
		public int Priority { get; }

		/// <summary>
		/// 强依赖列表。
		/// <para>声明此模块依赖的其他模块的具体类型 (Type)。</para>
		/// <para>加载器会确保这些依赖项在此模块之前完成初始化。</para>
		/// </summary>
		public Type[] Dependencies { get; }

		/// <summary>
		/// 声明一个 Asaki 模块。
		/// </summary>
		/// <param name="priority">启动优先级 (默认 1000)</param>
		/// <param name="dependencies">依赖的模块类型列表 (params)</param>
		public AsakiModuleAttribute(int priority = 1000, params Type[] dependencies)
		{
			Priority = priority;
			Dependencies = dependencies ?? Array.Empty<Type>();
		}
	}
}
```

<!-- File: Asaki/Core/Attributes/AsakiSerializationAttributes.cs -->
<!-- GUID: a74fc52479444f7d8319f12f37bff579 -->
<!-- Size: 1087 bytes -->
<!-- Modified: 2025-12-19 22:43:24 -->
```csharp
using System;

namespace Asaki.Core
{
	/// <summary>
	/// 标记一个类或结构体需要自动生成 IAsakiSavable 实现
	/// </summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
	public class AsakiSaveAttribute : Attribute
	{
		// 用于版本控制，防止坏档
		public int Version { get; }

		public AsakiSaveAttribute(int version = 1)
		{
			Version = version;
		}
	}

	/// <summary>
	/// 标记一个字段或属性需要被序列化
	/// </summary>
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, Inherited = true)]
	public class AsakiSaveMemberAttribute : Attribute
	{
		// 可选：指定序列化时的 Key（默认使用字段名）
		// 在 Binary 模式下此 Key 无效，仅用于 Debug JSON
		public string Key { get; set; }

		// 可选：手动指定排序顺序 (Binary模式下字段写入顺序很重要)
		public int Order { get; set; }

		public AsakiSaveMemberAttribute(string key = null, int order = 0)
		{
			Key = key;
			Order = order;
		}
	}
}
```

<!-- File: Asaki/Core/Attributes/AsakiUIBuilderAttribute.cs -->
<!-- GUID: 03a04e3625014ab390d74aefe88b5132 -->
<!-- Size: 1184 bytes -->
<!-- Modified: 2025-12-22 16:36:50 -->
```csharp
using Asaki.Core.UI;
using System;

namespace Asaki.Core
{
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
	public class AsakiUIBuilderAttribute : Attribute
	{
		public AsakiUIWidgetType Type { get; }

		/// <summary>
		/// 指定生成的 GameObject 名称。
		/// <para>若为空，自动使用字段名（去除下划线）。</para>
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// 指定父级路径（相对于 Root）。
		/// <para>例如: "Content/Grid"。若为空，则直接挂载在 Root 下。</para>
		/// </summary>
		public string Parent { get; set; }

		public string CustomPrefab { get; }

		public int Order { get; set; } = 0;
		/// <summary>
		/// 声明一个 UI 组件
		/// </summary>
		/// <param name="type">组件类型</param>
		public AsakiUIBuilderAttribute(AsakiUIWidgetType type)
		{
			Type = type;
		}

		/// <summary>
		/// 声明一个自定义组件
		/// </summary>
		public AsakiUIBuilderAttribute(string customPrefabName)
		{
			Type = AsakiUIWidgetType.Custom;
			CustomPrefab = customPrefabName;
		}
	}
}
```

<!-- File: Asaki/Core/Audio/AsakiAudioEvents.cs -->
<!-- GUID: 48ef9b1a32034277a8f8de672f56ca84 -->
<!-- Size: 492 bytes -->
<!-- Modified: 2025-12-22 16:32:48 -->
```csharp
using Asaki.Core.Broker;

namespace Asaki.Core.Audio
{
	public struct AsakiPlayAudioEvent : IAsakiEvent
	{
		public AsakiAudioParams Params;
		public AsakiAudioHandle OutputHandle; // 用于回传句柄 (如果同步调用)
	}

	public struct AsakiStopAudioEvent : IAsakiEvent
	{
		public AsakiAudioHandle Handle;
		public float FadeOutDuration;
	}

	public struct AsakiAudioFinishedEvent : IAsakiEvent
	{
		public AsakiAudioHandle Handle;
		public int AssetId;
	}
}
```

<!-- File: Asaki/Core/Audio/AsakiAudioHandle.cs -->
<!-- GUID: 27b5f36b48c34204b973d1732230b154 -->
<!-- Size: 1265 bytes -->
<!-- Modified: 2025-12-22 16:32:05 -->
```csharp
using System;

namespace Asaki.Core.Audio
{
	public readonly struct AsakiAudioHandle : IEquatable<AsakiAudioHandle>
	{
		public readonly int Id;        // 句柄唯一 ID
		public readonly int Timestamp; // 创建时间戳 (用于校验有效性，防止回收后误操作)

		public static readonly AsakiAudioHandle Invalid = new AsakiAudioHandle(0, 0);

		public AsakiAudioHandle(int id, int timestamp)
		{
			Id = id;
			Timestamp = timestamp;
		}

		public bool IsValid => Id != 0;

		// 重写 Equals 和 HashCode 以支持作为 Dictionary Key
		public override bool Equals(object obj)
		{
			if (obj is AsakiAudioHandle other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(AsakiAudioHandle other)
		{
			return Id == other.Id && Timestamp == other.Timestamp;
		}

		public override int GetHashCode()
		{

			return HashCode.Combine(Id, Timestamp);
		}

		// 可选：重载 == 和 != 运算符以提供更直观的相等比较
		public static bool operator ==(AsakiAudioHandle left, AsakiAudioHandle right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(AsakiAudioHandle left, AsakiAudioHandle right)
		{
			return !left.Equals(right);
		}
	}
}
```

<!-- File: Asaki/Core/Audio/AsakiAudioParams.cs -->
<!-- GUID: 5fb184d2bc5e467aad4d9f78d73f29d9 -->
<!-- Size: 2020 bytes -->
<!-- Modified: 2025-12-22 16:32:05 -->
```csharp
using UnityEngine;

namespace Asaki.Core.Audio
{

	/// <summary>
	/// 标准化音频播放参数包 (纯配置数据)
	/// </summary>
	public readonly struct AsakiAudioParams
	{
		// public readonly int AssetId; // [已删除] ID 由 Play 方法的参数决定

		public readonly Vector3 Position;   // 3D 空间坐标
		public readonly float Volume;       // 音量 (0-1)
		public readonly float Pitch;        // 音调
		public readonly float SpatialBlend; // 2D/3D 混合 (0=2D, 1=3D)
		public readonly bool IsLoop;        // 是否循环
		public readonly int Priority;       // 优先级 (0=最高)

		// [新增] 默认参数实例 (方便复用)
		public static readonly AsakiAudioParams Default = new AsakiAudioParams(
			Vector3.zero, 1.0f, 1.0f, 0f, false, 128
		);

		// 私有全参构造
		private AsakiAudioParams(Vector3 pos, float volume, float pitch, float spatialBlend, bool isLoop, int priority)
		{
			Position = pos;
			Volume = volume;
			Pitch = pitch;
			SpatialBlend = spatialBlend;
			IsLoop = isLoop;
			Priority = priority;
		}

		// ==========================================
		// Fluent API (每次修改返回新结构体)
		// ==========================================

		public AsakiAudioParams Set3D(Vector3 pos)
		{
			return new AsakiAudioParams(pos, Volume, Pitch, 1.0f, IsLoop, Priority);
			// Set3D 隐含 SpatialBlend=1
		}

		public AsakiAudioParams SetVolume(float vol)
		{
			return new AsakiAudioParams(Position, vol, Pitch, SpatialBlend, IsLoop, Priority);
		}

		public AsakiAudioParams SetPitch(float pitch)
		{
			return new AsakiAudioParams(Position, Volume, pitch, SpatialBlend, IsLoop, Priority);
		}

		public AsakiAudioParams SetLoop(bool loop)
		{
			return new AsakiAudioParams(Position, Volume, Pitch, SpatialBlend, loop, Priority);
		}

		public AsakiAudioParams SetPriority(int priority)
		{
			return new AsakiAudioParams(Position, Volume, Pitch, SpatialBlend, IsLoop, priority);
		}
	}
}
```

<!-- File: Asaki/Core/Audio/IAsakiAudioService.cs -->
<!-- GUID: 4a91f220c3fb4d25800b03d1a1a275cf -->
<!-- Size: 2452 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;
using System.Threading;
using UnityEngine;

namespace Asaki.Core.Audio
{
	/// <summary>
	/// 纯粹的音频播放行为接口
	/// 资源生命周期由实现层通过 AsakiResKit 自动管理
	/// </summary>
	public interface IAsakiAudioService : IAsakiModule
	{
		// ==========================================================
		// 1. 核心行为 (Core Behavior)
		// ==========================================================

		// 播放音频
		// 实现层逻辑：解析 AssetId -> 调用 Resources.LoadAsync -> 播放 -> 结束时 Release
		public AsakiAudioHandle Play(int assetId, AsakiAudioParams p = default(AsakiAudioParams), CancellationToken token = default(CancellationToken));

		// 停止音频
		// 实现层逻辑：淡出 -> 停止 -> Release Resources Handle
		void Stop(AsakiAudioHandle handle, float fadeDuration = 0.2f);

		// ==========================================================
		// 2. 运行时控制 (Runtime Control)
		// ==========================================================

		void Pause(AsakiAudioHandle handle);
		void Resume(AsakiAudioHandle handle);

		// 动态参数调整
		void SetVolume(AsakiAudioHandle handle, float volume);
		void SetPitch(AsakiAudioHandle handle, float pitch);
		void SetSpatialBlend(AsakiAudioHandle handle, float spatialBlend);

		// 3D 位置更新 (用于 Core 层驱动移动物体)
		void SetPosition(AsakiAudioHandle handle, Vector3 position);

		// 效果控制
		void SetLoop(AsakiAudioHandle handle, bool isLoop);
		void SetMuted(AsakiAudioHandle handle, bool isMuted);
		void SetPriority(AsakiAudioHandle handle, int priority);

		// ==========================================================
		// 3. 全局与分组控制 (Global & Groups)
		// ==========================================================

		// 全局控制
		void SetGlobalVolume(float volume);
		void StopAll(float fadeDuration = 0.5f);
		void PauseAll();
		void ResumeAll();

		bool IsPlaying(AsakiAudioHandle handle);
		bool IsPaused(AsakiAudioHandle handle); // <--- 关键补充

		// 分组控制 (Music, SFX, Voice)
		// 建议：groupId 对应 Unity 的 AudioMixerGroup
		void SetGroupVolume(int groupId, float volume);
		void SetGroupMuted(int groupId, bool isMuted);
		void StopGroup(int groupId, float fadeDuration = 0.2f);
		void PauseGroup(int groupId);
		void ResumeGroup(int groupId);
	}
}
```

<!-- File: Asaki/Core/Blackboard/AsakiBlackboard.cs -->
<!-- GUID: 4bfeffc1cbc4442296b6cabeced2e031 -->
<!-- Size: 10968 bytes -->
<!-- Modified: 2025-12-22 23:38:27 -->
```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;
using Asaki.Core.MVVM;

namespace Asaki.Core.Blackboard
{
    public sealed class AsakiBlackboard : IAsakiBlackboard
    {
        public IAsakiBlackboard Parent { get; private set; }

        // [Core Constraint 2] 独立类型注册表
        // 任何 Key 在首次写入时必须“登记户口”。后续访问必须查验类型，防止静默失败。
        private readonly Dictionary<int, Type> _typeRegistry = new Dictionary<int, Type>();

        // --- 物理分桶 (Lazy Initialization) ---
        // 只有当真正存储数据时才分配内存
        private Dictionary<int, AsakiProperty<int>> _intBucket;
        private Dictionary<int, AsakiProperty<int>> IntBucket => _intBucket ??= new Dictionary<int, AsakiProperty<int>>();

        private Dictionary<int, AsakiProperty<float>> _floatBucket;
        private Dictionary<int, AsakiProperty<float>> FloatBucket => _floatBucket ??= new Dictionary<int, AsakiProperty<float>>();
        
        private Dictionary<int, AsakiProperty<bool>> _boolBucket;
        private Dictionary<int, AsakiProperty<bool>> BoolBucket => _boolBucket ??= new Dictionary<int, AsakiProperty<bool>>();

        private Dictionary<int, AsakiProperty<string>> _stringBucket;
        private Dictionary<int, AsakiProperty<string>> StringBucket => _stringBucket ??= new Dictionary<int, AsakiProperty<string>>();

        private Dictionary<int, AsakiProperty<Vector3>> _vector3Bucket;
        private Dictionary<int, AsakiProperty<Vector3>> Vector3Bucket => _vector3Bucket ??= new Dictionary<int, AsakiProperty<Vector3>>();

        private Dictionary<int, object> _genericBucket;
        private Dictionary<int, object> GenericBucket => _genericBucket ??= new Dictionary<int, object>();

        // --- 构造函数 (环路检测) ---
        public AsakiBlackboard(IAsakiBlackboard parent = null)
        {
            if (parent != null)
            {
                var p = parent;
                int depth = 0;
                while (p != null)
                {
                    if (p == this) throw new InvalidOperationException("[AsakiBlackboard] Circular dependency detected!");
                    p = p.Parent;
                    if (++depth > 32) throw new InvalidOperationException("[AsakiBlackboard] Scope depth exceeds limit (32).");
                }
            }
            Parent = parent;
        }

        // ==========================================================
        // 核心安全逻辑 (Type Safety)
        // ==========================================================

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidateOrRegisterType<T>(AsakiBlackboardKey key)
        {
            int hash = key.Hash;
            Type reqType = typeof(T);

            if (_typeRegistry.TryGetValue(hash, out Type regType))
            {
                // 已存在：必须匹配
                if (regType != reqType)
                {
                    throw new InvalidCastException(
                        $"[AsakiBlackboard] Type Mismatch for key '{key}'! Registered: {regType.Name}, Requested: {reqType.Name}");
                }
            }
            else
            {
                // 未存在：注册新户口 (如果是只读操作且父级也没有，这一步其实不会触发，在 GetLocalPropertyOrCreate 中触发)
                // 这里我们稍微放宽，让具体的 CreateLocal 去注册，避免 Read 操作污染 Registry
            }
        }

        public Type GetKeyType(AsakiBlackboardKey key)
        {
            if (_typeRegistry.TryGetValue(key.Hash, out Type t)) return t;
            return Parent?.GetKeyType(key);
        }

        // ==========================================================
        // 读写 API
        // ==========================================================

        public void SetValue<T>(AsakiBlackboardKey key, T value)
        {
            // 写入本地：必须确保类型匹配（或注册新类型）
            GetLocalPropertyOrCreate<T>(key).Value = value;
        }

        public T GetValue<T>(AsakiBlackboardKey key, T defaultValue = default)
        {
            // 1. 查本地
            if (TryGetLocalProperty(key, out AsakiProperty<T> localProp))
            {
                return localProp.Value;
            }

            // 2. 查父级
            if (Parent != null)
            {
                // 注意：父级也必须符合 T 类型，由父级的 Validate 逻辑保证
                return Parent.GetValue(key, defaultValue);
            }

            return defaultValue;
        }

        public AsakiProperty<T> GetProperty<T>(AsakiBlackboardKey key)
        {
            // 策略：Copy-On-Access (Strict Shadowing)
            
            // 1. 如果本地已有，直接返回
            if (TryGetLocalProperty(key, out AsakiProperty<T> localProp))
            {
                return localProp;
            }

            // 2. 如果本地没有，准备创建本地副本
            // 先尝试从父级获取当前值作为初始值
            T initialValue = default;
            if (Parent != null && Parent.Contains(key))
            {
                initialValue = Parent.GetValue<T>(key);
            }

            // 3. 创建本地属性 (此时会注册类型)，切断与父级的引用关联
            var newProp = CreateLocalProperty<T>(key);
            newProp.Value = initialValue;
            
            return newProp;
        }

        public bool Contains(AsakiBlackboardKey key)
        {
            if (_typeRegistry.ContainsKey(key.Hash)) return true;
            return Parent != null && Parent.Contains(key);
        }

        // ==========================================================
        // 内部存储逻辑
        // ==========================================================

        private AsakiProperty<T> GetLocalPropertyOrCreate<T>(AsakiBlackboardKey key)
        {
            if (TryGetLocalProperty(key, out AsakiProperty<T> prop))
            {
                return prop;
            }
            return CreateLocalProperty<T>(key);
        }

        private AsakiProperty<T> CreateLocalProperty<T>(AsakiBlackboardKey key)
        {
            ValidateOrRegisterType<T>(key);
            _typeRegistry[key.Hash] = typeof(T);

            var prop = new AsakiProperty<T>();
            int hash = key.Hash;
            Type t = typeof(T);

            // JIT 会优化掉不走的分支，不会因为 if-else 多而变慢
            if (t == typeof(int)) 
            {
                // [Safe Cast]
                // 1. (object)prop: 引用类型转 object，零 GC。
                // 2. (AsakiProperty<int>): 显式转换，类型不匹配会抛异常（安全网）。
                IntBucket[hash] = (AsakiProperty<int>)(object)prop;
            }
            else if (t == typeof(float)) FloatBucket[hash] = (AsakiProperty<float>)(object)prop;
            else if (t == typeof(bool)) BoolBucket[hash] = (AsakiProperty<bool>)(object)prop;
            else if (t == typeof(string)) StringBucket[hash] = (AsakiProperty<string>)(object)prop;
            else if (t == typeof(Vector3)) Vector3Bucket[hash] = (AsakiProperty<Vector3>)(object)prop;
            else GenericBucket[hash] = prop;

            return prop;
        }

        private bool TryGetLocalProperty<T>(AsakiBlackboardKey key, out AsakiProperty<T> property)
        {
            property = null;
            int hash = key.Hash;
            
            // 安全检查
            if (_typeRegistry.TryGetValue(hash, out Type regType))
            {
                if (regType != typeof(T))
                {
                    // 这里不需要 Unsafe 也不需要 Assert，直接抛异常，因为这是逻辑错误
                    throw new InvalidCastException($"[AsakiBlackboard] Type Mismatch! Key: {key}, Registered: {regType}, Requested: {typeof(T)}");
                }
            }
            else
            {
                return false;
            }

            Type t = typeof(T);
            
            // 使用标准转换替代 UnsafeCast
            if (t == typeof(int))
            {
                if (_intBucket != null && _intBucket.TryGetValue(hash, out var p)) 
                { 
                    // 先转 object 再转 T。因为外面包了 if (t == typeof(int))，这里 T 就是 int
                    // 编译器能推断出 T 是 AsakiProperty<int> 的等价类型
                    property = (AsakiProperty<T>)(object)p; 
                    return true; 
                }
            }
            else if (t == typeof(float))
            {
                if (_floatBucket != null && _floatBucket.TryGetValue(hash, out var p)) 
                { 
                    property = (AsakiProperty<T>)(object)p; 
                    return true; 
                }
            }
            else if (t == typeof(bool))
            {
                if (_boolBucket != null && _boolBucket.TryGetValue(hash, out var p)) 
                { 
                    property = (AsakiProperty<T>)(object)p; 
                    return true; 
                }
            }
            else if (t == typeof(string))
            {
                if (_stringBucket != null && _stringBucket.TryGetValue(hash, out var p)) 
                { 
                    property = (AsakiProperty<T>)(object)p; 
                    return true; 
                }
            }
            else if (t == typeof(Vector3))
            {
                if (_vector3Bucket != null && _vector3Bucket.TryGetValue(hash, out var p)) 
                { 
                    property = (AsakiProperty<T>)(object)p; 
                    return true; 
                }
            }
            else
            {
                if (_genericBucket != null && _genericBucket.TryGetValue(hash, out var p)) 
                { 
                    property = (AsakiProperty<T>)p; // 泛型桶本身存的就是 object，直接强转
                    return true; 
                }
            }

            return false;
        }
        
        public void Dispose()
        {
            // 清理本地数据，断开引用
            _typeRegistry.Clear();
            _intBucket?.Clear();
            _floatBucket?.Clear();
            _boolBucket?.Clear();
            _stringBucket?.Clear();
            _vector3Bucket?.Clear();
            _genericBucket?.Clear();
            Parent = null;
        }
    }
}```

<!-- File: Asaki/Core/Blackboard/AsakiBlackboardKey.cs -->
<!-- GUID: e7c8c799f984477fbe71371df7821ef0 -->
<!-- Size: 2583 bytes -->
<!-- Modified: 2025-12-22 23:38:29 -->
```csharp
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Asaki.Core.Blackboard
{
    /// <summary>
    /// [Core Constraint 1] 确定性哈希键
    /// 强制使用 FNV-1a 算法替代 string.GetHashCode，确保跨平台/跨进程的哈希一致性。
    /// </summary>
    public readonly struct AsakiBlackboardKey : IEquatable<AsakiBlackboardKey>
    {
        public readonly int Hash;

#if UNITY_EDITOR
        public readonly string DebugName;
#endif

        // FNV-1a 32-bit Constants
        private const uint FNV_OFFSET_BASIS = 2166136261;
        private const uint FNV_PRIME = 16777619;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public AsakiBlackboardKey(string keyName)
        {
            if (string.IsNullOrEmpty(keyName))
            {
                Hash = 0;
#if UNITY_EDITOR
                DebugName = "NULL";
#endif
                return;
            }

            unchecked
            {
                uint hash = FNV_OFFSET_BASIS;
                // 手动遍历字符字节，避免依赖平台特定的 string 实现
                for (int i = 0; i < keyName.Length; i++)
                {
                    hash ^= keyName[i];
                    hash *= FNV_PRIME;
                }
                Hash = (int)hash;
            }

#if UNITY_EDITOR
            DebugName = keyName;
#endif
        }

        public AsakiBlackboardKey(int hash)
        {
            Hash = hash;
#if UNITY_EDITOR
            DebugName = hash.ToString();
#endif
        }

        // 隐式转换，方便使用
        public static implicit operator AsakiBlackboardKey(string name) => new AsakiBlackboardKey(name);
        public static implicit operator AsakiBlackboardKey(int hash) => new AsakiBlackboardKey(hash);

        public bool Equals(AsakiBlackboardKey other) => Hash == other.Hash;
        public override bool Equals(object obj) => obj is AsakiBlackboardKey other && Equals(other);
        public override int GetHashCode() => Hash;
        
        public static bool operator ==(AsakiBlackboardKey left, AsakiBlackboardKey right) => left.Hash == right.Hash;
        public static bool operator !=(AsakiBlackboardKey left, AsakiBlackboardKey right) => left.Hash != right.Hash;

        public override string ToString()
        {
#if UNITY_EDITOR
            return string.IsNullOrEmpty(DebugName) ? Hash.ToString() : $"{DebugName} ({Hash})";
#else
            return Hash.ToString();
#endif
        }
    }
}```

<!-- File: Asaki/Core/Blackboard/IAsakiBlackboard.cs -->
<!-- GUID: 61b511037c2441338ddfb4a3dc467706 -->
<!-- Size: 695 bytes -->
<!-- Modified: 2025-12-22 23:38:27 -->
```csharp
using Asaki.Core.Context;
using System;
using Asaki.Core.MVVM;

namespace Asaki.Core.Blackboard
{
	public interface IAsakiBlackboard : IAsakiService, IDisposable
	{
		// 作用域链
		IAsakiBlackboard Parent { get; }

		// 基础存取 (支持 Shadowing)
		void SetValue<T>(AsakiBlackboardKey key, T value);
		T GetValue<T>(AsakiBlackboardKey key, T defaultValue = default);

		// 响应式绑定 (支持 Copy-On-Access)
		AsakiProperty<T> GetProperty<T>(AsakiBlackboardKey key);

		// 元数据查询
		bool Contains(AsakiBlackboardKey key);
        
		// [New] 获取键的注册类型，用于安全检查或调试
		Type GetKeyType(AsakiBlackboardKey key);
	}
}
```

<!-- File: Asaki/Core/Broker/AsakiBroker.cs -->
<!-- GUID: 8e258ea744944bb7b5a71f5cf4028495 -->
<!-- Size: 1755 bytes -->
<!-- Modified: 2025-12-25 16:00:42 -->
```csharp
using Asaki.Core.Context;

namespace Asaki.Core.Broker
{
	/// <summary>
	/// [Facade] 静态入口外观
	/// 负责连接静态调用 (Roslyn) 与 动态实例 (EventBus)。
	/// </summary>
	public static class AsakiBroker
	{
	
		// 懒加载获取 Bus
		private static IAsakiEventService GetOrRegisterBus()
		{
			// 1. 尝试获取现有实例
			if (AsakiContext.TryGet<IAsakiEventService>(out var bus))
			{
				return bus;
			}

			// 2. [Auto-Fix] 如果没找到，主动创建一个并注册！
			// 这解决了脚本执行顺序导致的 "Subscribe too early" 问题
			// 确保总线在第一次使用时必定存在。
            
			// 注意：使用 double-check locking 防止并发创建 (虽然 Unity 主线程通常没这个问题)
			return AsakiContext.GetOrRegister<IAsakiEventService>(() => new AsakiEventService());
		}

		public static void Publish<T>(T e) where T : IAsakiEvent
		{
			GetOrRegisterBus().Publish(e);
		}

		public static void Subscribe<T>(IAsakiHandler<T> handler) where T :IAsakiEvent
		{
			GetOrRegisterBus().Subscribe(handler);
		}

		public static void Unsubscribe<T>(IAsakiHandler<T> handler) where T : IAsakiEvent
		{
			// Unsubscribe 时如果 Bus 不存在，那肯定没订阅过，直接忽略即可
			if (AsakiContext.TryGet<IAsakiEventService>(out var bus))
			{
				bus.Unsubscribe(handler);
			}
		}
	}

	public static class AsakiBrokerExtensions
	{
		public static void AsakiRegister<T>(this IAsakiHandler<T> handler) where T : IAsakiEvent
		{
			AsakiBroker.Subscribe(handler);
		}

		public static void AsakiUnregister<T>(this IAsakiHandler<T> handler) where T : IAsakiEvent
		{
			AsakiBroker.Unsubscribe(handler);
		}
	}
}
```

<!-- File: Asaki/Core/Broker/AsakiEventService.cs -->
<!-- GUID: 05f00208490644b9adc013fbf43a3ac9 -->
<!-- Size: 5966 bytes -->
<!-- Modified: 2025-12-25 16:00:22 -->
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Asaki.Core.Broker
{
    /// <summary>
    /// [Implementation] 基于实例的高性能事件总线。
    /// 解决了 IL2CPP 静态构造函数无法热更、无法重置的致命缺陷。
    /// </summary>
    public class AsakiEventService : IAsakiEventService
    {
        // ========================================================================
        // Internal Bucket Strategy
        // ========================================================================
        
        // 抽象接口用于统一管理 Cleanup
        private interface IEventBucket 
        { 
            void Cleanup(); 
        }

        // 具体的泛型桶 (Instance Class, not Static)
        private class EventBucket<T> : IEventBucket where T : IAsakiEvent
        {
            // 订阅列表 (Write heavy)
            private readonly List<IAsakiHandler<T>> _handlers = new List<IAsakiHandler<T>>(8);
            
            // 缓存数组 (Read heavy, Copy-On-Write)
            private IAsakiHandler<T>[] _cache = Array.Empty<IAsakiHandler<T>>();
            
            // 脏标记与锁
            private bool _dirty = false;
            private readonly object _bucketLock = new object();

            public void Subscribe(IAsakiHandler<T> handler)
            {
                lock (_bucketLock)
                {
                    if (!_handlers.Contains(handler))
                    {
                        _handlers.Add(handler);
                        _dirty = true;
                    }
                }
            }

            public void Unsubscribe(IAsakiHandler<T> handler)
            {
                lock (_bucketLock)
                {
                    if (_handlers.Remove(handler))
                    {
                        _dirty = true;
                    }
                }
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Publish(T e)
            {
                // 1. 检查脏标记 (Double-Check Locking 变种)
                if (_dirty)
                {
                    lock (_bucketLock)
                    {
                        if (_dirty)
                        {
                            _cache = _handlers.ToArray();
                            _dirty = false;
                        }
                    }
                }

                // 2. 获取缓存数组引用 (原子操作)
                var array = _cache;
                int count = array.Length;

                // 3. 极速遍历 (Zero GC)
                for (int i = 0; i < count; i++)
                {
                    // [Fix Defect-2] 移除 try-catch，让异常冒泡
                    // 这样 Debug.LogException 才能捕获到 Handler 内部的具体行号
                    array[i].OnEvent(e);
                }
            }

            public void Cleanup()
            {
                lock (_bucketLock)
                {
                    _handlers.Clear();
                    _cache = Array.Empty<IAsakiHandler<T>>();
                    _dirty = false;
                }
            }
        }

        // ========================================================================
        // Bus Implementation
        // ========================================================================

        // 存储所有类型的桶
        // Key: Event Type, Value: EventBucket<T>
        private readonly Dictionary<Type, IEventBucket> _buckets = new Dictionary<Type, IEventBucket>();
        private readonly object _busLock = new object();

        public void Subscribe<T>(IAsakiHandler<T> handler) where T : IAsakiEvent
        {
            GetBucket<T>().Subscribe(handler);
        }

        public void Unsubscribe<T>(IAsakiHandler<T> handler) where T : IAsakiEvent
        {
            GetBucket<T>().Unsubscribe(handler);
        }

        public void Publish<T>(T e) where T : IAsakiEvent
        {
            // 极速路径：如果桶不存在，说明没订阅者，直接跳过 (比静态类访问还快，因为省了泛型初始化检查)
            if (TryGetBucket<T>(out var bucket))
            {
                bucket.Publish(e);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private EventBucket<T> GetBucket<T>() where T : IAsakiEvent
        {
            // 快速检查
            if (TryGetBucket<T>(out var bucket)) return bucket;

            // 慢速创建
            lock (_busLock)
            {
                // Double check
                if (TryGetBucket(out bucket)) return bucket;

                bucket = new EventBucket<T>();
                _buckets[typeof(T)] = bucket;
                return bucket;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool TryGetBucket<T>(out EventBucket<T> bucket) where T : IAsakiEvent
        {
            // Dictionary 读操作在无扩容时是线程安全的
            // 但为了绝对稳健，这里依赖 _buckets 在运行时主要只增不减的特性
            if (_buckets.TryGetValue(typeof(T), out var b))
            {
                bucket = (EventBucket<T>)b; // 强转开销极低
                return true;
            }
            bucket = null;
            return false;
        }

        public void Dispose()
        {
            // [Fix Defect-3 & 4] 真正的清理
            lock (_busLock)
            {
                foreach (var bucket in _buckets.Values)
                {
                    bucket.Cleanup();
                }
                _buckets.Clear();
            }
        }
    }
}```

<!-- File: Asaki/Core/Broker/IAsakiEvent.cs -->
<!-- GUID: f59e2b9838644c07904c2d63188703bd -->
<!-- Size: 166 bytes -->
<!-- Modified: 2025-12-25 16:00:42 -->
```csharp
namespace Asaki.Core.Broker
{
	public interface IAsakiEvent { }

	public interface IAsakiHandler<T> where T : IAsakiEvent
	{
		void OnEvent(T e);
	}
	
}
```

<!-- File: Asaki/Core/Broker/IAsakiEventService.cs -->
<!-- GUID: b61e596ffcda4030af44f7532d600d93 -->
<!-- Size: 345 bytes -->
<!-- Modified: 2025-12-25 16:00:16 -->
```csharp
using Asaki.Core.Context;
using System;

namespace Asaki.Core.Broker
{
	public interface IAsakiEventService : IAsakiService,IDisposable
	{
		void Subscribe<T>(IAsakiHandler<T> handler) where T : IAsakiEvent;
		void Unsubscribe<T>(IAsakiHandler<T> handler) where T : IAsakiEvent;
		void Publish<T>(T e) where T : IAsakiEvent;
	}
}
```

<!-- File: Asaki/Core/Configuration/AsakiConfigReloadedEvent.cs -->
<!-- GUID: b22bc6c3648d46c38ece78b0ad480d59 -->
<!-- Size: 191 bytes -->
<!-- Modified: 2025-12-22 16:32:48 -->
```csharp
using Asaki.Core.Broker;
using System;

namespace Asaki.Core.Configuration
{
	public struct AsakiConfigReloadedEvent : IAsakiEvent
	{
		public Type ConfigType { get; set; }
	}
}
```

<!-- File: Asaki/Core/Configuration/IAsakiConfig.cs -->
<!-- GUID: 3e44acf3cda54cd1b2ad0d0d6cb4a68e -->
<!-- Size: 276 bytes -->
<!-- Modified: 2025-12-23 14:20:38 -->
```csharp
using Asaki.Core.Serialization;

namespace Asaki.Core.Configuration
{
	public interface IAsakiConfig : IAsakiSavable
	{
		/// <summary>
		/// 配置表主键 ID
		/// </summary>
		int Id { get; }
		
		void AllowConfigSerialization(string permissionKey);
	}
}
```

<!-- File: Asaki/Core/Configuration/IAsakiConfigService.cs -->
<!-- GUID: a9efc608960147ff941e521193c73498 -->
<!-- Size: 417 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Asaki.Core.Configuration
{
	public interface IAsakiConfigService : IAsakiModule
	{
		Task LoadAllAsync();
		T Get<T>(int id) where T : class, IAsakiConfig, new();
		IReadOnlyList<T> GetAll<T>() where T : class, IAsakiConfig, new();
		Task ReloadAsync<T>() where T : class, IAsakiConfig, new();
	}
}
```

<!-- File: Asaki/Core/Context/AsakiContext.cs -->
<!-- GUID: 74264f8224ed4b0f965cfef2800eb3df -->
<!-- Size: 9871 bytes -->
<!-- Modified: 2025-12-23 13:55:03 -->
```csharp
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Asaki.Core.Context
{
    /// <summary>
    /// [极速微内核] 服务容器 (V5.1 Lock-Free Edition)
    /// <para>架构策略：Copy-On-Write (写时复制) + Snapshot Swap (快照交换)</para>
    /// <para>性能特征：</para>
    /// <list type="bullet">
    /// <item>读操作 (Get): O(1), 无锁 (Zero-Lock), 仅一次引用解引用。</item>
    /// <item>写操作 (Register): O(n), 有锁, 触发内存分配 (仅在启动时发生)。</item>
    /// </list>
    /// </summary>
    public static class AsakiContext
    {
        // ========================================================================
        // 核心存储 (Snapshot)
        // ========================================================================
        
        // 使用 volatile 确保多线程下的可见性。
        // _services 永远指向一个"只读"的字典实例。每次写入都会创建一个新的字典并替换它。
        private static volatile Dictionary<Type, IAsakiService> _services = new Dictionary<Type, IAsakiService>(64);
        
        // 写操作专用锁 (读操作不使用任何锁)
        private static readonly object _writeLock = new object();
        
        // 架构状态机
        private static volatile bool _isFrozen = false;

        // ========================================================================
        // 极速读取 API (Hot Path)
        // ========================================================================

        /// <summary>
        /// 获取服务实例。
        /// <para>性能：主程热路径专用，无锁，开销等同于原生 Dictionary 查找。</para>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T Get<T>() where T : class, IAsakiService
        {
            // 直接访问 volatile 引用，无锁
            if (_services.TryGetValue(typeof(T), out IAsakiService service))
            {
                // 强转开销极低 (Unsafe.As 在这里也可以，但 standard cast 更安全且足够快)
                return (T)service;
            }
            throw new KeyNotFoundException($"[AsakiContext] Service not found: {typeof(T).Name}");
        }

        /// <summary>
        /// 尝试获取服务实例。
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryGet<T>(out T service) where T : class, IAsakiService
        {
            if (_services.TryGetValue(typeof(T), out IAsakiService s))
            {
                service = (T)s;
                return true;
            }
            service = null;
            return false;
        }

        // ========================================================================
        // 写入 API (Cold Path - Copy On Write)
        // ========================================================================

        /// <summary>
        /// [启动期] 注册服务。
        /// <para>注意：这是一个 O(n) 操作，仅应在游戏初始化阶段调用。</para>
        /// </summary>
        public static void Register<T>(T service) where T : class, IAsakiService
        {
            RegisterInternal(typeof(T), service, isReplacement: false);
        }

        public static void Register(Type type, IAsakiService service)
        {
            RegisterInternal(type, service, isReplacement: false);
        }

        /// <summary>
        /// [热更新] 运行时替换现有服务。
        /// <para>允许在 Freeze 后执行，用于修复 Bug 或热切模块。</para>
        /// </summary>
        public static void Replace<T>(T service) where T : class, IAsakiService
        {
            RegisterInternal(typeof(T), service, isReplacement: true);
        }

        private static void RegisterInternal(Type type, IAsakiService service, bool isReplacement)
        {
            if (service == null) throw new ArgumentNullException(nameof(service));
            if (!type.IsAssignableFrom(service.GetType()))
                throw new ArgumentException($"Service {service.GetType().Name} does not implement {type.Name}");

            // 1. 获取写锁 (阻塞其他写入者，但不阻塞读取者)
            lock (_writeLock)
            {
                // 2. 状态检查
                if (_isFrozen && !isReplacement)
                {
                    throw new InvalidOperationException(
                        $"[AsakiContext] Container is Frozen! Cannot register new service '{type.Name}' at runtime. " +
                        "Use 'Replace()' if you intend to hot-fix.");
                }

                // 3. 检查重复 (仅针对非替换模式)
                if (!isReplacement && _services.ContainsKey(type))
                {
                    throw new InvalidOperationException($"[AsakiContext] Service '{type.Name}' is already registered.");
                }

                // 4. 写时复制 (Copy-On-Write)
                // 创建一个新字典，大小扩容一点防止频繁 Resize
                var newServices = new Dictionary<Type, IAsakiService>(_services);
                
                // 执行写入/覆盖
                newServices[type] = service;

                // 5. 原子交换 (Atomic Swap)
                // 将引用指向新字典。此时所有新的 Get<T> 调用都会看到新数据。
                // 旧字典会被 GC 回收 (只要没有读取者持有它)。
                _services = newServices;
            }
        }

        /// <summary>
        /// 获取或注册 (懒加载)。
        /// <para>包含双重检查锁定 (Double-Check)，线程安全。</para>
        /// </summary>
        public static T GetOrRegister<T>(Func<T> factory) where T : class, IAsakiService
        {
            // 1. 快速检查 (无锁)
            if (TryGet<T>(out var existing)) return existing;

            lock (_writeLock)
            {
                // 2. 二次检查 (有锁)
                if (TryGet<T>(out existing)) return existing;

                // 3. 执行工厂创建 (注意：工厂应无副作用)
                var instance = factory();
                
                // 4. 注册 (复用内部逻辑)
                RegisterInternal(typeof(T), instance, isReplacement: false);
                
                return instance;
            }
        }

        // ========================================================================
        // 架构控制 API
        // ========================================================================

        /// <summary>
        /// [架构] 冻结容器。
        /// <para>应在初始化完毕 (Bootstrapper 结束) 后调用。</para>
        /// <para>冻结后禁止 Register，防止业务逻辑随处注册服务导致架构腐化。</para>
        /// </summary>
        public static void Freeze()
        {
            lock (_writeLock)
            {
                _isFrozen = true;
            }
        }

        /// <summary>
        /// [生命周期] 清空并销毁所有服务。
        /// </summary>
        public static void ClearAll()
        {
            Dictionary<Type, IAsakiService> oldSnapshot;
            
            lock (_writeLock)
            {
                // 1. 获取当前快照的引用
                oldSnapshot = _services;
                
                // 2. 立即置空 (后续读取将失败或返回空)
                _services = new Dictionary<Type, IAsakiService>();
                _isFrozen = false;
            }

            // 3. 在锁外执行 Dispose，防止 Dispose 逻辑死锁
            foreach (var kvp in oldSnapshot)
            {
                var service = kvp.Value;
                try
                {
                    // 优先调用模块销毁
                    if (service is IAsakiModule module)
                    {
                        module.OnDispose();
                    }
                    // 其次调用通用销毁 (需去重，如果既是Module又是Disposable)
                    else if (service is IDisposable disposable)
                    {
                        disposable.Dispose();
                    }
                }
                catch (Exception ex)
                {
                    // 记录异常但不中断清理流程
                    #if UNITY_EDITOR || DEVELOPMENT_BUILD
                    UnityEngine.Debug.LogError($"[AsakiContext] Error disposing service {kvp.Key.Name}: {ex}");
                    #endif
                }
            }
        }

        /// <summary>
        /// 线性查找服务 (O(n) 复杂度，仅用于调试或非热路径)。
        /// </summary>
        public static bool TryGetAssignable<T>(out T service) where T : class
        {
            // 获取当前快照引用 (线程安全)
            var snapshot = _services;
            var targetType = typeof(T);

            foreach (var kvp in snapshot)
            {
                // 这里的 IsAssignableFrom 是瓶颈，但在 snapshot 上遍历是安全的
                if (targetType.IsAssignableFrom(kvp.Key))
                {
                    service = kvp.Value as T;
                    return true;
                }
            }
            service = default;
            return false;
        }

        // 静态类不需要 Dispose，ClearAll 已处理内容释放
        public static void Dispose()
        {
            ClearAll();
        }
    }
}
```

<!-- File: Asaki/Core/Context/IAsakiModule.cs -->
<!-- GUID: 14a959c3442849118d3ee79e79ab70c3 -->
<!-- Size: 1480 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using System.Threading.Tasks;

namespace Asaki.Core.Context
{
	/// <summary>
	/// [Asaki 架构核心] 模块生命周期契约。
	/// <para>实现此接口的类必须同时标记 [AsakiModule] 特性。</para>
	/// </summary>
	public interface IAsakiModule : IAsakiService
	{
		/// <summary>
		/// [同步初始化阶段]
		/// <para>时机：模块实例被创建并注册到容器后立即调用。</para>
		/// <para>职责：</para>
		/// <list type="bullet">
		/// <item>获取配置 (AsakiContext.Get&lt;AsakiConfig&gt;)</item>
		/// <item>获取已就绪的依赖模块 (AsakiContext.Get&lt;TDependency&gt;)</item>
		/// <item>注册此模块提供的额外子服务 (AsakiContext.Register&lt;IService&gt;)</item>
		/// </list>
		/// <para>警告：严禁在此方法中再次注册模块自身 (this)，加载器已自动处理。</para>
		/// </summary>
		void OnInit();

		/// <summary>
		/// [异步初始化阶段]
		/// <para>时机：所有模块完成 OnInit 后，按 DAG 顺序依次调用。</para>
		/// <para>职责：执行耗时的异步操作，如资源加载、网络连接、数据库预热。</para>
		/// </summary>
		Task OnInitAsync();

		/// <summary>
		/// [销毁阶段]
		/// <para>时机：游戏退出或重启时调用。</para>
		/// <para>职责：清理非托管资源、断开连接。容器会自动清理引用，此处仅处理内部状态。</para>
		/// </summary>
		void OnDispose();
	}
}
```

<!-- File: Asaki/Core/Context/IAsakiModuleDiscovery.cs -->
<!-- GUID: 7f6923764961415984d807cab3f35629 -->
<!-- Size: 556 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using System;
using System.Collections.Generic;

namespace Asaki.Core.Context
{
	/// <summary>
	/// [物理隔离适配器] 模块发现策略接口。
	/// <para>Core 层定义需求，Unity 层负责实现 (通过反射扫描或代码生成)。</para>
	/// </summary>
	public interface IAsakiModuleDiscovery
	{
		/// <summary>
		/// 获取所有符合条件的模块类型。
		/// </summary>
		/// <returns>带有 [AsakiModule] 标记且实现了 IAsakiModule 的类型集合。</returns>
		IEnumerable<Type> GetModuleTypes();
	}
}
```

<!-- File: Asaki/Core/Context/IAsakiService.cs -->
<!-- GUID: 394d47ee06ced0044bd90f2fc9cfaaf4 -->
<!-- Size: 73 bytes -->
<!-- Modified: 2025-12-22 16:35:16 -->
```csharp
namespace Asaki.Core.Context
{
	public interface IAsakiService { }
}
```

<!-- File: Asaki/Core/Coroutines/IAsakiRoutineService.cs -->
<!-- GUID: 5d64d36ebfc94b3a8b1e0bf5a05c1811 -->
<!-- Size: 5262 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.Coroutines
{
	/// <summary>
	/// [异步服务接口] (v3.0 Enhanced)
	/// 提供完整的时间控制、条件等待和任务管理能力。
	/// </summary>
	public interface IAsakiRoutineService : IAsakiService
	{
		// === 基本等待方法 ===

		/// <summary>
		/// 等待指定秒数 (受 TimeScale 影响)
		/// </summary>
		Task WaitSeconds(float seconds, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定秒数 (真实时间，不受 TimeScale 影响)
		/// </summary>
		Task WaitSecondsUnscaled(float seconds, CancellationToken token = default(CancellationToken));

		// === 帧等待 ===

		/// <summary>
		/// 等待下一帧 (Update)
		/// </summary>
		Task WaitFrame(CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定数量的帧
		/// </summary>
		Task WaitFrames(int count, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待物理/固定帧 (FixedUpdate)
		/// </summary>
		Task WaitFixedFrame(CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定数量的物理帧
		/// </summary>
		Task WaitFixedFrames(int count, CancellationToken token = default(CancellationToken));

		// === 条件等待 ===

		/// <summary>
		/// 挂起直到条件为 true
		/// </summary>
		Task WaitUntil(Func<bool> predicate, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 挂起直到条件为 false
		/// </summary>
		Task WaitWhile(Func<bool> predicate, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待直到条件为 true，带超时时间
		/// </summary>
		Task<bool> WaitUntil(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待直到条件为 false，带超时时间
		/// </summary>
		Task<bool> WaitWhile(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken));

		// === 任务管理 ===

		/// <summary>
		/// 异步执行一个任务，自动处理取消和异常
		/// </summary>
		Task RunTask(Func<Task> taskFunc, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 异步执行一个带返回值的任务
		/// </summary>
		Task<T> RunTask<T>(Func<Task<T>> taskFunc, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 延迟执行一个动作
		/// </summary>
		Task DelayedCall(float delaySeconds, Action action, CancellationToken token = default(CancellationToken), bool unscaledTime = false);

		/// <summary>
		/// 在下一帧执行一个动作
		/// </summary>
		Task NextFrameCall(Action action, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 当条件满足时执行一个动作
		/// </summary>
		Task When(Func<bool> condition, Action action, CancellationToken token = default(CancellationToken));

		// === 批量任务管理 ===

		/// <summary>
		/// 等待所有任务完成
		/// </summary>
		Task WaitAll(params Task[] tasks);

		/// <summary>
		/// 等待任意一个任务完成
		/// </summary>
		Task WaitAny(params Task[] tasks);

		/// <summary>
		/// 顺序执行多个异步操作
		/// </summary>
		Task Sequence(params Func<Task>[] actions);

		/// <summary>
		/// 并行执行多个异步操作
		/// </summary>
		Task Parallel(params Func<Task>[] actions);

		/// <summary>
		/// 重试执行异步操作
		/// </summary>
		Task Retry(Func<Task> action, int maxRetries = 3, float retryDelay = 1f, CancellationToken token = default(CancellationToken));

		// === 高级等待模式 ===

		/// <summary>
		/// 等待一个自定义的等待源
		/// </summary>
		Task WaitCustom(IAsakiWaitSource waitSource, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 创建可配置的等待构建器
		/// </summary>
		IWaitBuilder CreateWaitBuilder();

		// === 状态和取消 ===

		/// <summary>
		/// 当前运行的任务数量
		/// </summary>
		int RunningTaskCount { get; }

		/// <summary>
		/// 取消所有正在运行的任务
		/// </summary>
		void CancelAllTasks();

		/// <summary>
		/// 创建一个链接到服务生命周期的取消令牌
		/// </summary>
		CancellationToken CreateLinkedToken(CancellationToken externalToken = default(CancellationToken));
	}

	// === 扩展接口 ===

	/// <summary>
	/// 自定义等待源接口
	/// </summary>
	public interface IAsakiWaitSource
	{
		bool IsCompleted { get; }
		float Progress { get; }
		void Update();
	}

	/// <summary>
	/// 等待构建器接口（流畅API）
	/// </summary>
	public interface IWaitBuilder
	{
		IWaitBuilder Seconds(float seconds, bool unscaled = false);
		IWaitBuilder Frames(int count);
		IWaitBuilder FixedFrames(int count);
		IWaitBuilder Until(Func<bool> condition);
		IWaitBuilder While(Func<bool> condition);
		Task Build(CancellationToken token = default(CancellationToken));
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiBlackboardData.cs -->
<!-- GUID: 1848b3a8988e400b85fea2fd09e63c55 -->
<!-- Size: 649 bytes -->
<!-- Modified: 2025-12-22 22:59:19 -->
```csharp
using System;
using UnityEngine;

namespace Asaki.Core.Graphs
{
	public enum AsakiBlackboardPropertyType
	{
		Int,
		Float,
		Bool,
		String,
		Vector3,
		Vector2,
		Vector2Int,
		Vector3Int,
		Color,
	}
	
	[Serializable]
	public class AsakiVariableDef
	{
		public string Name;
		public AsakiBlackboardPropertyType Type;
		public bool IsExposed = true;
		
		public int IntVal;
		public float FloatVal;
		public bool BoolVal;
		public string StringVal;
		public Vector3 Vector3Val;
		public Vector2 Vector2Val;
		public Vector3Int Vector3IntVal;
		public Vector2Int Vector2IntVal;
		public Color ColorVal;
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiCustomGraphEditorAttribute.cs -->
<!-- GUID: 67df2af6772d454a8aa2d72d2bb34dc3 -->
<!-- Size: 353 bytes -->
<!-- Modified: 2025-12-22 22:45:23 -->
```csharp
using System;

namespace Asaki.Editor.GraphEditors
{
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
	public sealed class AsakiCustomGraphEditorAttribute : Attribute
	{
		public Type GraphType { get; }

		public AsakiCustomGraphEditorAttribute(Type graphType)
		{
			GraphType = graphType;
		}
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiGraphAsset.cs -->
<!-- GUID: e0bab3935ff6489cbdf6997e3ac70f4a -->
<!-- Size: 698 bytes -->
<!-- Modified: 2025-12-22 16:33:09 -->
```csharp
using System;
using UnityEngine;

namespace Asaki.Core.Graphs
{

	[Serializable]
	public abstract class AsakiNodeBase
	{
		[HideInInspector] public Vector2 Position;
		[HideInInspector] public string GUID;
		[HideInInspector] public int ExecutionOrder;
		// 获取标题的虚方法，默认返回类名
		public virtual string Title => this.GetType().Name;
		public virtual void OnCreated() { }
	}

	[System.Serializable]
	public class AsakiEdgeData
	{
		public string BaseNodeGUID;   // 输出节点 GUID
		public string BasePortName;   // 输出端口名
		public string TargetNodeGUID; // 输入节点 GUID
		public string TargetPortName; // 输入端口名
	}

}
```

<!-- File: Asaki/Core/Graphs/AsakiGraphBase.cs -->
<!-- GUID: c0049e49efba4774a121d823b6138721 -->
<!-- Size: 5720 bytes -->
<!-- Modified: 2025-12-22 23:51:15 -->
```csharp
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Core.Graphs
{
	public abstract class AsakiGraphBase : ScriptableObject
	{
		[SerializeReference]
		public List<AsakiNodeBase> Nodes = new List<AsakiNodeBase>();
		public List<AsakiEdgeData> Edges = new List<AsakiEdgeData>();
		[Header("Blackboard")]
		[SerializeReference] // 支持多态，虽然目前是 List<T>
		public List<AsakiVariableDef> Variables = new List<AsakiVariableDef>();

		// 缓存：快速通过 GUID 找到节点实例
		private Dictionary<string, AsakiNodeBase> _nodeLookup;
		private Dictionary<AsakiNodeBase, Dictionary<string, AsakiEdgeData>> _incomingCache;
		// 缓存：快速查找连线关系
		// Key: 源节点, Value: { 端口名 -> 目标节点列表 }
		private Dictionary<AsakiNodeBase, Dictionary<string, List<AsakiNodeBase>>> _outgoingCache;
		[System.NonSerialized]
		private bool _isInitialized = false;

		private void EnsureRuntimeInitialized()
		{
			if (!_isInitialized || _outgoingCache == null || _nodeLookup == null)
			{
				InitializeRuntime();
			}
		}
		
		/// <summary>
		/// 运行时初始化。建议在 Runner 的 Start() 中调用。
		/// 会构建拓扑缓存，将查找复杂度从 O(N) 降为 O(1)。
		/// </summary>
		public void InitializeRuntime()
		{
			if (_isInitialized && _outgoingCache != null && _nodeLookup != null) return;

			// 1. 构建节点查找表
			_nodeLookup = new Dictionary<string, AsakiNodeBase>();
			foreach (var node in Nodes)
			{
				if (node != null) _nodeLookup[node.GUID] = node;
			}

			// 2. 构建连线关系缓存
			_outgoingCache = new Dictionary<AsakiNodeBase, Dictionary<string, List<AsakiNodeBase>>>();
			_incomingCache = new Dictionary<AsakiNodeBase, Dictionary<string, AsakiEdgeData>>();
			foreach (var edge in Edges)
			{
				if (!_nodeLookup.TryGetValue(edge.BaseNodeGUID, out var source)) continue;
				if (!_nodeLookup.TryGetValue(edge.TargetNodeGUID, out var target)) continue;

				// 1. 构建 Outgoing (正向)
				if (!_outgoingCache.ContainsKey(source))
					_outgoingCache[source] = new Dictionary<string, List<AsakiNodeBase>>();
				if (!_outgoingCache[source].ContainsKey(edge.BasePortName))
					_outgoingCache[source][edge.BasePortName] = new List<AsakiNodeBase>();
				_outgoingCache[source][edge.BasePortName].Add(target);

				// 2. [New] 构建 Incoming (反向) - 用于数据回溯
				if (!_incomingCache.ContainsKey(target))
					_incomingCache[target] = new Dictionary<string, AsakiEdgeData>();
                
				// 记录哪条线连到了 target 的哪个端口
				_incomingCache[target][edge.TargetPortName] = edge;
			}

			_isInitialized = true;
		}

		// --------------------------------------------------------
		// ★ 常用 API (Helper Methods)
		// --------------------------------------------------------

		/// <summary>
		/// 获取图的入口节点（默认返回第一个添加的节点，也可以按名字查找）
		/// </summary>
		public T GetEntryNode<T>() where T : AsakiNodeBase
		{
			if (Nodes.Count == 0) return null;
			return Nodes[0] as T; // 简单粗暴，返回第一个
		}

		public AsakiEdgeData GetInputConnection(AsakiNodeBase targetNode, string inputPortName)
		{
			EnsureRuntimeInitialized();
			if (_incomingCache.TryGetValue(targetNode, out var portMap))
			{
				if (portMap.TryGetValue(inputPortName, out var edge))
				{
					return edge;
				}
			}
			return null;
		}
		
		public AsakiNodeBase GetNodeByGUID(string guid)
		{
			return _nodeLookup.GetValueOrDefault(guid);
		}
		
		/// <summary>
		/// 获取指定端口连接的【单个】下一个节点。
		/// 适用于单输出端口（如 "Next"）。
		/// </summary>
		public AsakiNodeBase GetNextNode(AsakiNodeBase current, string portName = "Out")
		{
			EnsureRuntimeInitialized();

			if (_outgoingCache.TryGetValue(current, out var portMap))
			{
				if (portMap.TryGetValue(portName, out var targets) && targets.Count > 0)
				{
					return targets[0];
				}
			}
			return null;
		}

		/// <summary>
		/// 获取指定端口连接的【所有】下一个节点。
		/// 适用于多输出端口（如 "BroadCast"）。
		/// </summary>
		public List<AsakiNodeBase> GetNextNodes(AsakiNodeBase current, string portName = "Out")
		{
			EnsureRuntimeInitialized();

			if (_outgoingCache.TryGetValue(current, out var portMap))
			{
				if (portMap.TryGetValue(portName, out var targets))
				{
					return targets;
				}
			}
			return new List<AsakiNodeBase>(); // 返回空列表防止 NullReference
		}

		/// <summary>
		/// 泛型版本，自动转换类型
		/// </summary>
		public T GetNextNode<T>(AsakiNodeBase current, string portName = "Out") where T : AsakiNodeBase
		{
			return GetNextNode(current, portName) as T;
		}
		
		public void OnBeforeSerialize()
		{
			// 序列化前无需操作，数据都在 List 中
		}

		public void OnAfterDeserialize()
		{
			// 反序列化后（如 Ctrl+Z，或资源加载），缓存表是空的
			// 我们标记为未初始化，下次访问时会自动重建 (Lazy Load)
			// 或者更激进地：如果已经在运行中，强制刷新
            
			_isInitialized = false; 
			_nodeLookup = null;
			_outgoingCache = null;
			_incomingCache = null;
            
			// 注意：不要在这里直接调用 InitializeRuntime()
			// 因为 Unity 反序列化是在非主线程或受限环境下进行的，
			// 复杂的字典操作可能不安全。
			// 我们通过置空标志位，让 GetInputConnection 等方法在下次调用时自动重建。
		}
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiGraphRunner.cs -->
<!-- GUID: ce34892c63674b8cad896183825149e0 -->
<!-- Size: 8917 bytes -->
<!-- Modified: 2025-12-22 23:50:04 -->
```csharp
using Asaki.Core.Blackboard;
using Asaki.Core.Context;
using System;
using UnityEngine;

namespace Asaki.Core.Graphs
{
	public abstract class AsakiGraphRunner<TGraph> : MonoBehaviour
		where TGraph : AsakiGraphBase
	{
		[Header("Graphs Data")]
		public TGraph GraphAsset;

		protected AsakiGraphRuntimeContext _context;

		protected virtual void Start()
		{
			if (GraphAsset == null)
			{
				Debug.LogWarning($"[AsakiGraphRunner] GraphAsset is null on {name}");
				return;
			}

			// 1. 初始化图结构缓存 (O(1) Lookup)
			GraphAsset.InitializeRuntime();

			// 2. 构建运行时上下文
			InitializeContext();
	
			// 3. 将 Asset 中配置的变量初值填入 Runtime 黑板
			InitializeBlackboardValues();
			
			OnGraphInitialized();
		}

		private void InitializeContext()
		{
			_context = new AsakiGraphRuntimeContext();
			_context.Owner = this.gameObject;

			// --- 作用域链构建 (Scope Chain Integration) ---

			// A. 尝试获取全局黑板 (Global Scope)
			// AsakiContext 是线程安全的，可以直接访问
			IAsakiBlackboard globalScope = null;
			if (AsakiContext.TryGet<IAsakiBlackboard>(out var globalBB))
			{
				globalScope = globalBB;
			}

			// B. 创建本地黑板 (Local Scope)
			// 将全局黑板设为 Parent，实现 "Local -> Global" 的查找链
			// 依据 v2 设计：对本地黑板的修改绝不会污染 globalScope
			_context.Blackboard = new AsakiBlackboard(globalScope);
		}

		private void InitializeBlackboardValues()
		{
			if (GraphAsset == null || _context.Blackboard == null) return;

			// 遍历 ScriptableObject 中的变量定义
			foreach (var variable in GraphAsset.Variables)
			{
		
				switch (variable.Type)
				{
					case AsakiBlackboardPropertyType.Int:
						_context.Blackboard.SetValue(variable.Name, variable.IntVal);
						break;
					case AsakiBlackboardPropertyType.Float:
						_context.Blackboard.SetValue(variable.Name, variable.FloatVal);
						break;
					case AsakiBlackboardPropertyType.Bool:
						_context.Blackboard.SetValue(variable.Name, variable.BoolVal);
						break;
					case AsakiBlackboardPropertyType.String:
						_context.Blackboard.SetValue(variable.Name, variable.StringVal);
						break;
					case AsakiBlackboardPropertyType.Vector3:
						_context.Blackboard.SetValue(variable.Name, variable.Vector3Val);
						break;
					case AsakiBlackboardPropertyType.Vector2Int:
						_context.Blackboard.SetValue(variable.Name, variable.Vector2IntVal);
						break;
					case AsakiBlackboardPropertyType.Vector3Int:
						_context.Blackboard.SetValue(variable.Name, variable.Vector3IntVal);
						break;
					case AsakiBlackboardPropertyType.Color:
						_context.Blackboard.SetValue(variable.Name, variable.ColorVal);
						break;
				}
			}
		}
		
		// 子类可以在这里做额外的初始化（比如绑定 UI、注册特定服务）
		protected virtual void OnGraphInitialized() { }

		// --- 生命周期管理 (New) ---

		protected virtual void OnDestroy()
		{
			// 必须清理，否则 Blackboard 中的 AsakiProperty 可能会残留 UI 订阅，导致内存泄漏
			if (_context != null)
			{
				_context.Dispose();
				_context = null;
			}
			OnNodeExecuted = null;
		}

		// --- 辅助 API (Helpers) ---

		/// <summary>
		/// 获取变量 (支持 Key 字符串自动转 Hash)
		/// </summary>
		public T GetVariable<T>(string key)
		{
			if (_context?.Blackboard == null) return default;
			// 隐式转换: string -> AsakiBlackboardKey (FNV-1a)
			return _context.Blackboard.GetValue<T>(key);
		}

		/// <summary>
		/// 设置变量 (Shadowing: 只修改本地)
		/// </summary>
		public void SetVariable<T>(string key, T value)
		{
			if (_context?.Blackboard == null) return;
			// 隐式转换: string -> AsakiBlackboardKey (FNV-1a)
			_context.Blackboard.SetValue<T>(key, value);
		}

		/// <summary>
		/// 获取当前节点某个输入端口的值。
		/// 如果有连线，则回溯上游节点并计算返回值；
		/// 如果无连线，则返回默认值。
		/// </summary>
		protected T GetInputValue<T>(AsakiNodeBase currentNode, string inputPortName, T fallback = default)
		{
			// 1. 查找连接到该端口的线
			var edge = GraphAsset.GetInputConnection(currentNode, inputPortName);
			if (edge == null) return fallback;

			// 2. 找到上游节点
			var sourceNode = GraphAsset.GetNodeByGUID(edge.BaseNodeGUID);
			if (sourceNode == null) return fallback;

			// 3. 计算上游节点的值 (Resolve)
			// 这里我们实现一个简易的求值分发器
			return ResolveNodeValue<T>(sourceNode, edge.BasePortName);
		}

		/// <summary>
		/// 解析节点的值 (当节点被当作数据源连接时调用)
		/// </summary>
		protected virtual T ResolveNodeValue<T>(AsakiNodeBase node, string outputPortName)
		{
			// --- Case A: Get Variable Node (从黑板取值) ---
			if (node is AsakiGetVariableNode getVarNode)
			{
				if (_context.Blackboard == null) return default;

				// 核心：直接从 Blackboard 读
				// 利用隐式转换 string -> AsakiBlackboardKey
				return _context.Blackboard.GetValue<T>(getVarNode.VariableName);
			}

			// --- Case B: 其他数据节点 (如 Math, Logic 等，未来扩展) ---
			// e.g. if (node is AsakiAddNode addNode) return addNode.Execute(this);

			Debug.LogWarning($"[AsakiRunner] Cannot resolve value from node type: {node.GetType().Name}");
			return default;
		}

		
		
		// ================================================================
		// ★ 核心驱动逻辑 2: 执行流 (Execution Flow)
		// ================================================================
        
		// 节点执行事件 (Editor Only)
		public event Action<AsakiNodeBase> OnNodeExecuted;
		
		/// <summary>
		/// 执行单个节点逻辑
		/// </summary>
		protected virtual void ExecuteNode(AsakiNodeBase node)
		{
			if (node == null) return;

			#if UNITY_EDITOR
			// 触发调试事件
			OnNodeExecuted?.Invoke(node);
			#endif
			
			// --- Case A: Set Variable Node (写入黑板) ---
			if (node is AsakiSetVariableNode setVarNode)
			{
				if (_context.Blackboard == null) return;

				// 1. 获取要写入的值
				// 注意：这里需要根据变量类型动态获取值，比较棘手因为 T 未知
				// 但在 SetValue<T> 中我们需要泛型。
				// 策略：使用 object 重载或根据 VariableType switch

				object valueToWrite = GetInputValue<object>(setVarNode, "Value");

				// 2. 写入黑板 (需要处理类型分发)
				// 这里为了演示简单，我们假设 Blackboard 有 Object 重载，或者我们手动 switch
				WriteToBlackboard(setVarNode.VariableName, setVarNode.VariableType, valueToWrite);

				// 3. 继续执行后续节点
				var nextNode = GraphAsset.GetNextNode(node, "Out");
				if (nextNode != null) ExecuteNode(nextNode);
				return;
			}

			// --- Case B: 其他执行节点 ---
			// 子类可以 override 这个方法处理自己的业务节点
			OnExecuteCustomNode(node);
		}

		// 辅助：处理类型写入
		private void WriteToBlackboard(string key, AsakiBlackboardPropertyType type, object value)
		{
			// 这里的 value 可能是 null，或者类型不匹配，需要安全转换
			try
			{
				switch (type)
				{
					case AsakiBlackboardPropertyType.Int:
						_context.Blackboard.SetValue(key, Convert.ToInt32(value));
						break;
					case AsakiBlackboardPropertyType.Float:
						_context.Blackboard.SetValue(key, Convert.ToSingle(value));
						break;
					case AsakiBlackboardPropertyType.Bool:
						_context.Blackboard.SetValue(key, Convert.ToBoolean(value));
						break;
					case AsakiBlackboardPropertyType.String:
						_context.Blackboard.SetValue(key, Convert.ToString(value));
						break;
					case AsakiBlackboardPropertyType.Vector3:
						_context.Blackboard.SetValue(key, (Vector3)value);
						break;
					case AsakiBlackboardPropertyType.Vector2:
						_context.Blackboard.SetValue(key, (Vector2)value);
						break;
					case AsakiBlackboardPropertyType.Vector3Int:
						_context.Blackboard.SetValue(key, (Vector3Int)value);
						break;
					case AsakiBlackboardPropertyType.Vector2Int:
						_context.Blackboard.SetValue(key, (Vector2Int)value);
						break;
					case AsakiBlackboardPropertyType.Color:
						_context.Blackboard.SetValue(key, (Color)value);
						break;
				}
			}
			catch (Exception e)
			{
				Debug.LogError($"[AsakiRunner] SetVariable Failed: Key={key}, Type={type}, Value={value}. Error: {e.Message}");
			}
		}

		/// <summary>
		/// 子类重写此方法处理特定业务节点 (如 PlaySound, MoveTo)
		/// </summary>
		protected virtual void OnExecuteCustomNode(AsakiNodeBase node) { }
		
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiGraphRuntimeContext.cs -->
<!-- GUID: d6d2cd503de64041b3ecbbd395cd1841 -->
<!-- Size: 437 bytes -->
<!-- Modified: 2025-12-22 22:45:32 -->
```csharp
using Asaki.Core.Blackboard;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Core.Graphs
{
	public class AsakiGraphRuntimeContext : IDisposable
	{
		public IAsakiBlackboard Blackboard;
        
		public GameObject Owner;

		public void Dispose()
		{
			// M-01: 级联释放，断开所有属性订阅
			Blackboard?.Dispose();
			Blackboard = null;
			Owner = null;
		}
	}
}
```

<!-- File: Asaki/Core/Graphs/AsakiVariableNode.cs -->
<!-- GUID: 89bfef474cff4c688af5a45c4360be2b -->
<!-- Size: 1222 bytes -->
<!-- Modified: 2025-12-22 23:02:47 -->
```csharp
using System;

namespace Asaki.Core.Graphs
{
	[Serializable]
	[AsakiGraphContext(typeof(AsakiGraphBase), "Variable/Get")] // 适配所有图
	public class AsakiGetVariableNode : AsakiNodeBase
	{
		public override string Title => $"Get {VariableName}";
        
		// 存储变量名 (Key)
		public string VariableName;
        
		// 存储类型 (用于运行时优化和 Editor 端口着色)
		public AsakiBlackboardPropertyType VariableType;

		// 输出端口 (名字固定为 Value，但在 Editor 下我们会动态修改它的显示类型)
		[AsakiNodeOutput("Value")] 
		public object Value; 
	}
	
	[Serializable]
	[AsakiGraphContext(typeof(AsakiGraphBase), "Variable/Set")]
	public class AsakiSetVariableNode : AsakiNodeBase
	{
		public override string Title => $"Set {VariableName}";

		public string VariableName;
		public AsakiBlackboardPropertyType VariableType;

		// 执行流输入
		[AsakiNodeInput("In")] 
		public AsakiFlowPort InputFlow;
        
		// 值输入
		[AsakiNodeInput("Value")] 
		public object NewValue;

		// 执行流输出
		[AsakiNodeOutput("Out")]
		public AsakiFlowPort OutputFlow;
	}
	
	[Serializable] public struct AsakiFlowPort { }
}
```

<!-- File: Asaki/Core/MVVM/AsakiProperty.cs -->
<!-- GUID: 76e9140ab449409d9287728d01c72eb0 -->
<!-- Size: 5005 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace Asaki.Core.MVVM
{
	[Serializable]
	public class AsakiProperty<T> : IEquatable<AsakiProperty<T>>
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public T _value;

		[NonSerialized]
		private Action<T> _onValueChangedAction;

		[NonSerialized]
		private readonly List<IAsakiObserver<T>> _observers = new List<IAsakiObserver<T>>();

		public AsakiProperty()
		{
			_value = default(T);
		}
		public AsakiProperty(T initialValue = default(T))
		{
			_value = initialValue;
		}

		public T Value
		{
			get => _value;
			set
			{
				if (EqualityComparer<T>.Default.Equals(_value, value)) return;
				_value = value;
				Notify();
			}
		}

		public void Subscribe(Action<T> action)
		{
			_onValueChangedAction += action;
			action?.Invoke(_value);
		}

		public void Unsubscribe(Action<T> action)
		{
			_onValueChangedAction -= action;
		}

		public void Bind(IAsakiObserver<T> observer)
		{
			if (_observers.Contains(observer)) return;
			_observers.Add(observer);
			observer.OnValueChange(_value);
		}

		public void Unbind(IAsakiObserver<T> observer)
		{
			_observers.Remove(observer);
		}

		private void Notify()
		{
			_onValueChangedAction?.Invoke(_value);
			for (int i = _observers.Count - 1; i >= 0; i--)
			{
				_observers[i].OnValueChange(_value);
			}
		}

		// ========================================================================
		// 相等性实现
		// ========================================================================

		public override int GetHashCode()
		{
			// 抛出异常，明确禁止将其用作字典键
			throw new NotSupportedException($"{nameof(AsakiProperty<T>)} should not be used as a dictionary key due to its mutable nature.");
		}

		/// <summary>
		/// 实现 IEquatable<T> 接口以获得更好的类型安全性和性能
		/// </summary>
		public bool Equals(AsakiProperty<T> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;
			return EqualityComparer<T>.Default.Equals(_value, other._value);
		}

		/// <summary>
		/// 重写 Equals 方法，保持与运算符重载一致
		/// </summary>
		public override bool Equals(object obj)
		{
			return obj switch
			       {
				       // 相同类型，使用类型安全的 Equals 方法
				       AsakiProperty<T> other => Equals(other),
				       // T 类型，直接比较值
				       T val => EqualityComparer<T>.Default.Equals(_value, val),
				       // 其他类型不相等
				       _ => false,
			       };
		}

		// ========================================================================
		// 运算符重载
		// ========================================================================

		/// <summary>
		/// AsakiProperty<T> 与 AsakiProperty<T> 的相等比较
		/// </summary>
		public static bool operator ==(AsakiProperty<T> left, AsakiProperty<T> right)
		{
			// 处理两个都为 null 的情况
			if (ReferenceEquals(left, right)) return true;

			// 处理其中一个为 null 的情况
			if (ReferenceEquals(left, null) || ReferenceEquals(right, null)) return false;

			return EqualityComparer<T>.Default.Equals(left._value, right._value);
		}

		public static bool operator !=(AsakiProperty<T> left, AsakiProperty<T> right)
		{
			return !(left == right);
		}

		/// <summary>
		/// T 与 AsakiProperty<T> 的相等比较（T 在左）
		/// </summary>
		public static bool operator ==(T left, AsakiProperty<T> right)
		{
			// 如果 right 为 null，只有 left 为 null 时才相等（对于引用类型）
			if (ReferenceEquals(right, null))
				return EqualityComparer<T>.Default.Equals(left, default(T));

			return EqualityComparer<T>.Default.Equals(left, right._value);
		}

		public static bool operator !=(T left, AsakiProperty<T> right)
		{
			return !(left == right);
		}

		/// <summary>
		/// AsakiProperty<T> 与 T 的相等比较（AsakiProperty<T> 在左）
		/// </summary>
		public static bool operator ==(AsakiProperty<T> left, T right)
		{
			// 如果 left 为 null，只有 right 为 null 时才相等（对于引用类型）
			if (ReferenceEquals(left, null))
				return EqualityComparer<T>.Default.Equals(default(T), right);

			return EqualityComparer<T>.Default.Equals(left._value, right);
		}

		public static bool operator !=(AsakiProperty<T> left, T right)
		{
			return !(left == right);
		}

		// ========================================================================
		// 其他方法
		// ========================================================================

		public override string ToString()
		{
			return _value?.ToString() ?? "null";
		}

		public static implicit operator T(AsakiProperty<T> property)
		{
			if (property == null) return default(T);
			return property._value;
		}
	}
}
```

<!-- File: Asaki/Core/MVVM/IAsakiObserver.cs -->
<!-- GUID: 4ea05142b6a64de290d1ba6646f67b9b -->
<!-- Size: 113 bytes -->
<!-- Modified: 2025-12-22 16:35:26 -->
```csharp
namespace Asaki.Core.MVVM
{
	public interface IAsakiObserver<T>
	{
		void OnValueChange(T value);
	}
}
```

<!-- File: Asaki/Core/Pooling/AsakiPoolService.cs -->
<!-- GUID: 998d177d56fb42d4a7b8560882edd4db -->
<!-- Size: 11893 bytes -->
<!-- Modified: 2025-12-23 19:35:36 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Coroutines;
using Asaki.Core.Resources; // 引用 Phase 1 定义的资源模块
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Core.Pooling
{
    /// <summary>
    /// [Asaki Native] 对象池服务实现 (Skeleton Phase)
    /// </summary>
    public class AsakiPoolService : IAsakiPoolService, IDisposable
    {
        // =========================================================
        // 1. 依赖与状态
        // =========================================================

        // 强依赖：分帧生成服务
        private readonly IAsakiRoutineService _routineService;
        
        // 强依赖：资源加载服务
        private readonly IAsakiResService _resService;
        
        // 强依赖：事件服务
        private readonly IAsakiEventService _eventService;
        
        // 核心存储：Key -> PoolData (包含 Handle + Stack)
        // PoolData 是我们在 Phase 1 定义的 internal 类
        private readonly Dictionary<string, PoolData> _pools = new Dictionary<string, PoolData>();

        // 全局根节点：所有具体 Pool 的父节点
        private Transform _globalRoot;
        private const string GLOBAL_ROOT_NAME = "[Asaki.Pool.Service]";

        // 销毁标志位
        private bool _isDisposed = false;

        // =========================================================
        // 2. 构造与初始化 (DI & Root Setup)
        // =========================================================

        /// <summary>
        /// 构造函数由 Bootstrapper 或 Module 手动注入依赖
        /// </summary>
        public AsakiPoolService(IAsakiRoutineService routineService, IAsakiResService resService, IAsakiEventService eventService)
        {
            // 守卫子句：确保依赖不为空
            _routineService = routineService ?? throw new ArgumentNullException(nameof(routineService));
            _resService = resService ?? throw new ArgumentNullException(nameof(resService));
            _eventService = eventService ?? throw new ArgumentNullException(nameof(eventService));

            InitializeGlobalRoot();
        }

        private void InitializeGlobalRoot()
        {
            // 创建一个持久的根节点
            var go = new GameObject(GLOBAL_ROOT_NAME);
            Object.DontDestroyOnLoad(go);
            _globalRoot = go.transform;
        }

        // =========================================================
        // 3. 异步预热 (Phase 3 Core)
        // =========================================================

        public async Task PrewarmAsync(string key, int count, int itemsPerFrame = 5)
        {
            // 1. 基础守卫
            if (_isDisposed) return;
            if (string.IsNullOrEmpty(key)) return;

            PoolData poolData;

            // 2. 检查池是否已存在
            // 如果池子已经存在，说明资源肯定加载过了，我们只需要补充数量即可
            if (!_pools.TryGetValue(key, out poolData))
            {
                // [Step A] 资源加载
                // 调用资源服务，异步获取句柄。这里我们使用 default(CancellationToken)
                // 如果你的业务需要取消预热，可以在接口中增加 Token 参数
                var handle = await _resService.LoadAsync<GameObject>(key, CancellationToken.None);
                
                // 校验资源有效性
                if (handle == null || !handle.IsValid)
                {
                    Debug.LogError($"[AsakiPool] Failed to load resource: {key}. Prewarm aborted.");
                    return;
                }

                // [Step B] 创建容器
                // 创建一个新的 GameObject 作为这个池的根节点
                var rootGo = new GameObject($"Pool_{key}");
                rootGo.transform.SetParent(_globalRoot); // 挂在全局根下

                // 组装 PoolData (我们在 Phase 1 定义的)
                poolData = new PoolData(handle, rootGo.transform, count);
                
                // 注册到字典
                _pools.Add(key, poolData);
            }

            // 3. 计算需要生成的数量
            // 如果池里已经有 5 个，目标是 10 个，我们只需要生成 5 个
            // 如果目标比现有少，我们不做缩减操作 (通常由清理策略负责)
            int currentCount = poolData.Stack.Count;
            int needToSpawn = count - currentCount;

            if (needToSpawn <= 0) return;

            // [Step C] 分帧实例化 (利用 Asaki Native 桥接技术)
            // 我们将耗时的 Instantiate 操作委托给 RoutineService，避免卡死主线程
            await _routineService.RunTask(async () =>
            {
                var batchCount = 0;
                var prefab = poolData.PrefabHandle.Asset; // 从句柄中取出 Prefab

                for (int i = 0; i < needToSpawn; i++)
                {
                    // 再次检查销毁状态 (防止在 await 期间服务被 Dispose)
                    if (_isDisposed) break;

                    // 实例化并挂载到 PoolRoot
                    var go = Object.Instantiate(prefab, poolData.Root);
                    go.SetActive(false); // 默认隐藏
                    
                    // 封装并入栈
                    var item = new PoolItem(go);
                    poolData.Stack.Push(item);

                    // 分帧控制：每生成 N 个等待一帧
                    batchCount++;
                    if (batchCount >= itemsPerFrame)
                    {
                        batchCount = 0;
                        await _routineService.WaitFrame();
                    }
                }
            });
            
            // 预热完成
            // Debug.Log($"[AsakiPool] Prewarmed {key}: +{needToSpawn} items.");
        }

        // =========================================================
        // 4. 运行时操作 (Phase 4 Core)
        // =========================================================

        public GameObject Spawn(string key, Vector3? position = null, Quaternion? rotation = null, Transform parent = null)
        {
            if (_isDisposed) return null;

            // 1. 核心检查：必须预热！
            // 这一步体现了"强制异步"策略。如果 Key 没在字典里，说明没有预热，
            // 而我们无法在这里进行异步加载(因为 Spawn 是同步的)，所以只能报错。
            if (!_pools.TryGetValue(key, out var poolData))
            {
                Debug.LogError($"[AsakiPool] Key not prewarmed: '{key}'. \n" +
                               "Solution: Call 'await PrewarmAsync(\"{key}\", ...)' during game initialization.");
                return null;
            }

            PoolItem item = null;

            // 2. 尝试出栈 (Hit Cache)
            while (poolData.Stack.Count > 0)
            {
                var popped = poolData.Stack.Pop();
                // 保护性检查：防止对象在外部被 Destroy 导致引用丢失
                if (popped.GameObject != null)
                {
                    item = popped;
                    break;
                }
            }

            // 3. 栈空补货 (Miss Cache)
            // 能够执行到这里，说明 PrefabHandle 肯定有效 (否则 poolData 不会存在)
            if (item == null)
            {
                // 直接同步实例化，因为资源已在内存
                var go = Object.Instantiate(poolData.PrefabHandle.Asset, poolData.Root);
                item = new PoolItem(go);
                
                // [可选] 如果你想统计"池扩容"次数，可以在这里打点
            }

            // 4. 设置变换信息
            var t = item.Transform;
            // 这里的逻辑：如果传入 parent，挂过去；如果没传，设为 null (置于场景根节点)
            // 注意：不要挂在 poolData.Root 下，激活的对象应该在外界
            t.SetParent(parent ? parent : null); 
            
            if (position.HasValue) t.position = position.Value;
            if (rotation.HasValue) t.rotation = rotation.Value;

            // 5. 激活与生命周期
            item.GameObject.SetActive(true);
            
            // 调用接口回调 (0 GC，因为我们在 PoolItem 构造时缓存了接口)
            item.AsakiPoolable?.OnSpawn();
            
            item.LastActiveTime = Time.time;

            return item.GameObject;
        }

        public void Despawn(GameObject go, string key)
        {
            if (_isDisposed || go == null) return;

            // 1. 查找池
            if (!_pools.TryGetValue(key, out var poolData))
            {
                Debug.LogWarning($"[AsakiPool] Despawn target pool '{key}' not found. Destroying object directly.");
                Object.Destroy(go);
                return;
            }

            // 2. 触发回调
            // 必须在 SetActive(false) 之前调用，方便逻辑处理
            if (go.TryGetComponent<IAsakiPoolable>(out var poolable))
            {
                poolable.OnDespawn();
            }

            // 3. 重置状态
            go.SetActive(false);

            // 4. 归位
            // 将对象重新挂载到该池的 Root 下，保持 Hierarchy 干净
            if (poolData.Root != null)
            {
                go.transform.SetParent(poolData.Root);
            }

            // 5. 入栈
            // 重新包装一个新的 PoolItem (或者复用旧的？为了避免复杂性，这里 new 一个 struct 开销极小)
            // 注意：我们在 PoolItem 构造函数里缓存了组件，这里 new 一次会导致再次 GetComponent。
            // 优化点：如果我们要极致性能，Spawn 时返回的是 PoolItem 引用而不是 GO，Despawn 传回 PoolItem。
            // 但为了 API 易用性 (GameObject)，这里重新 new PoolItem 是可接受的权衡。
            poolData.Stack.Push(new PoolItem(go));
        }

        public void ReleasePool(string key)
        {
            if (_pools.TryGetValue(key, out var poolData))
            {
                // 这将触发 PoolData.Dispose -> ResHandle.Dispose -> 引用计数减一
                poolData.Dispose();
                _pools.Remove(key);
                Debug.Log($"[AsakiPool] Released pool: {key}");
            }
        }

        // =========================================================
        // 4. 生命周期销毁
        // =========================================================

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            // 1. 释放所有池数据 (这也将释放所有 ResHandle)
            foreach (var kvp in _pools)
            {
                kvp.Value.Dispose();
            }
            _pools.Clear();

            // 2. 销毁全局根节点
            if (_globalRoot != null)
            {
                if (Application.isPlaying) Object.Destroy(_globalRoot.gameObject);
                else Object.DestroyImmediate(_globalRoot.gameObject);
                _globalRoot = null;
            }

            Debug.Log("[AsakiPoolService] Service Disposed & Memory Released.");
        }
    }
}```

<!-- File: Asaki/Core/Pooling/AsakiSmartPool.cs -->
<!-- GUID: dd1c6a7b3c93420bb39e6b5d2be08589 -->
<!-- Size: 2529 bytes -->
<!-- Modified: 2025-12-23 18:23:57 -->
```csharp
using Asaki.Core.Context;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Core.Pooling
{
    /// <summary>
    /// [Legacy Facade] 对象池静态门面
    /// <para>作用：兼容旧代码，将静态调用转发给 IAsakiPoolService。</para>
    /// <para>注意：这是一个"空壳"，真正的逻辑在 AsakiPoolService 中。</para>
    /// </summary>
    public static class AsakiSmartPool
    {
        // 快捷访问器：动态从 Context 获取服务
        // 如果服务没注册 (比如 Bootstrapper 还没跑)，这里会抛出异常，这是符合预期的 Fail-Fast
        private static IAsakiPoolService Service => AsakiContext.Get<IAsakiPoolService>();

        // =========================================================
        // 核心转发
        // =========================================================

        public static Task PrewarmAsync(string key, int count, int itemsPerFrame = 5)
        {
            return Service.PrewarmAsync(key, count, itemsPerFrame);
        }

        public static GameObject Spawn(string key, Vector3 position, Quaternion rotation, Transform parent = null)
        {
            return Service.Spawn(key, position, rotation, parent);
        }
        
        // 重载版本
        public static GameObject Spawn(string key, Vector3 position)
        {
            return Service.Spawn(key, position, Quaternion.identity, null);
        }

        public static void Despawn(GameObject go, string key)
        {
            Service.Despawn(go, key);
        }

        public static void ReleasePool(string key)
        {
            Service.ReleasePool(key);
        }

        // =========================================================
        // 兼容性接口 (这些方法在接口里没有，是 Facade 独有的 helper)
        // =========================================================

        public static List<GameObject> SpawnBatch(string key, int count, Vector3 position)
        {
            var list = new List<GameObject>(count);
            for (int i = 0; i < count; i++)
            {
                list.Add(Spawn(key, position));
            }
            return list;
        }

        public static void DespawnBatch(IEnumerable<GameObject> objects, string key)
        {
            foreach (var go in objects)
            {
                Despawn(go, key);
            }
        }
    }
}```

<!-- File: Asaki/Core/Pooling/IAsakiPoolable.cs -->
<!-- GUID: 61f3defaf2fa4fcdb99fbb61f8647c3b -->
<!-- Size: 121 bytes -->
<!-- Modified: 2025-12-22 16:36:33 -->
```csharp
namespace Asaki.Core.Pooling
{
	public interface IAsakiPoolable
	{
		void OnSpawn();
		void OnDespawn();
	}
}
```

<!-- File: Asaki/Core/Pooling/IAsakiPoolService.cs -->
<!-- GUID: 94e348222922479fb90a0abe1099b899 -->
<!-- Size: 1831 bytes -->
<!-- Modified: 2025-12-23 18:12:55 -->
```csharp
using Asaki.Core.Context;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Core.Pooling
{
	/// <summary>
	/// [Asaki Native] 对象池服务契约
	/// <para>核心策略：Async-First Prewarm + Sync Spawn</para>
	/// </summary>
	public interface IAsakiPoolService : IAsakiService
	{
		/// <summary>
		/// [异步预热] 核心 API。
		/// <para>1. 通过资源系统加载 Prefab (Ref Count +1)。</para>
		/// <para>2. 分帧实例化对象填充池子。</para>
		/// <para>必须在 Spawn 前调用，否则 Spawn 会失败。</para>
		/// </summary>
		/// <param name="key">资源地址/Key</param>
		/// <param name="count">目标池内数量</param>
		/// <param name="itemsPerFrame">分帧生成速率 (防卡顿)</param>
		Task PrewarmAsync(string key, int count, int itemsPerFrame = 5);

		/// <summary>
		/// [同步生成] 获取对象。
		/// <para>前提：Key 必须已预热 (Prewarmed)。</para>
		/// </summary>
		/// <param name="position">可选位置 (null则保持原样或默认)</param>
		/// <param name="rotation">可选旋转 (null则保持原样或默认)</param>
		/// <param name="parent">父节点 (null则为场景根或保持池结构)</param>
		GameObject Spawn(string key, Vector3? position = null, Quaternion? rotation = null, Transform parent = null);

		/// <summary>
		/// [回收] 将对象归还给池。
		/// </summary>
		/// <param name="go">要回收的对象</param>
		/// <param name="key">所属的池 Key (V5.1暂需显式传递)</param>
		void Despawn(GameObject go, string key);

		/// <summary>
		/// [释放池] 
		/// <para>1. 销毁池中所有闲置对象。</para>
		/// <para>2. 释放资源句柄 (Ref Count -1)，允许底层卸载资源。</para>
		/// </summary>
		void ReleasePool(string key);
	}
}
```

<!-- File: Asaki/Core/Pooling/PoolData.cs -->
<!-- GUID: 05fc3f21ee21409696a9c4b5b600933e -->
<!-- Size: 1722 bytes -->
<!-- Modified: 2025-12-23 18:13:53 -->
```csharp
using Asaki.Core.Resources; // 引用资源模块
using System;
using System.Collections.Generic;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Core.Pooling
{
	/// <summary>
	/// [Internal Container] 池数据结构
	/// <para>职责：将 "资源生命周期" 与 "对象实例集合" 绑定。</para>
	/// </summary>
	internal class PoolData : IDisposable
	{
		/// <summary>
		/// 资源句柄 (RAII)。
		/// <para>只要 PoolData 存在，这个 Handle 就不释放，</para>
		/// <para>保证 Prefab 不会被 Addressables/AssetBundle 卸载。</para>
		/// </summary>
		public ResHandle<GameObject> PrefabHandle;

		/// <summary>
		/// 闲置对象栈
		/// </summary>
		public readonly Stack<PoolItem> Stack;

		/// <summary>
		/// 层级根节点 (用于收纳隐藏的对象，保持 Hierarchy 干净)
		/// </summary>
		public Transform Root;

		public PoolData(ResHandle<GameObject> handle, Transform root, int capacity)
		{
			PrefabHandle = handle;
			Root = root;
			Stack = new Stack<PoolItem>(capacity);
		}

		public void Dispose()
		{
			// 1. 销毁所有闲置实例
			if (Stack != null)
			{
				while (Stack.Count > 0)
				{
					var item = Stack.Pop();
					if (item.GameObject != null)
					{
						Object.Destroy(item.GameObject);
					}
				}
			}

			// 2. 销毁层级根节点
			if (Root != null)
			{
				if (Application.isPlaying) Object.Destroy(Root.gameObject);
				else Object.DestroyImmediate(Root.gameObject);
			}

			// 3. [核心] 释放资源引用计数
			// 这会通知 AsakiResService 该 Prefab 不再被此池占用
			PrefabHandle?.Dispose();
			PrefabHandle = null;
		}
	}
}
```

<!-- File: Asaki/Core/Pooling/PoolItem.cs -->
<!-- GUID: 0f03a420d8be451f8c75dab0ffce8862 -->
<!-- Size: 935 bytes -->
<!-- Modified: 2025-12-23 18:13:11 -->
```csharp
using UnityEngine;

namespace Asaki.Core.Pooling
{
	/// <summary>
	/// [Data Unit] 对象池的基础存储单元
	/// </summary>
	public class PoolItem
	{
		/// <summary>
		/// 实际的 Unity GameObject 引用
		/// </summary>
		public readonly GameObject GameObject;

		/// <summary>
		/// 缓存 Transform 访问，微乎其微的性能优化
		/// </summary>
		public readonly Transform Transform;

		/// <summary>
		/// 缓存生命周期接口 (如果有)
		/// </summary>
		public readonly IAsakiPoolable AsakiPoolable;

		/// <summary>
		/// 上次激活时间 (用于 LRU 或超时清理策略)
		/// </summary>
		public float LastActiveTime;

		public PoolItem(GameObject go)
		{
			GameObject = go;
			Transform = go.transform;
			// 在构造时一次性获取接口，Spawn 时直接调用，0 GC
			go.TryGetComponent(out AsakiPoolable);
			LastActiveTime = Time.time;
		}
	}
}
```

<!-- File: Asaki/Core/Resources/IAsakiResDependencyLookup.cs -->
<!-- GUID: 15a759a2263c450d9ea46285867d80be -->
<!-- Size: 923 bytes -->
<!-- Modified: 2025-12-22 16:33:29 -->
```csharp
using System.Collections.Generic;

namespace Asaki.Core.Resources
{
	/// <summary>
	/// [依赖查询接口]
	/// 用于查询某个资源路径所依赖的其他资源路径。
	/// 对于 AssetBundle，这里通常读取 Manifest；
	/// 对于 Resources/Addressables，这里通常返回空。
	/// </summary>
	public interface IAsakiResDependencyLookup
	{
		/// <summary>
		/// 获取依赖项列表
		/// </summary>
		/// <param name="location">主资源地址</param>
		/// <returns>依赖资源地址列表 (如果没有依赖返回 null 或 空数组)</returns>
		IEnumerable<string> GetDependencies(string location);
	}

	/// <summary>
	/// [默认实现] 空依赖查询 (用于 Resources 模式)
	/// </summary>
	public class EmptyAsakiResDependencyLookup : IAsakiResDependencyLookup
	{
		public IEnumerable<string> GetDependencies(string location)
		{
			return null;
		}
	}
}
```

<!-- File: Asaki/Core/Resources/IAsakiResService.cs -->
<!-- GUID: e0e70ca80c204e27b919661df0bef5d6 -->
<!-- Size: 1376 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.Resources
{
	public class ResHandle<T> : IDisposable where T : class
	{
		private readonly IAsakiResService _service;
		public readonly string Location;
		public readonly T Asset;

		public bool IsValid => Asset != null;

		public ResHandle(string location, T asset, IAsakiResService service)
		{
			Location = location;
			Asset = asset;
			_service = service;
		}

		public void Dispose()
		{
			if (IsValid)
			{
				_service?.Release(Location);
			}
		}

		public static implicit operator T(ResHandle<T> handle)
		{
			return handle.Asset;
		}
	}
	public interface IAsakiResService : IAsakiModule
	{
		Task<ResHandle<T>> LoadAsync<T>(string location, Action<float> onProgress, CancellationToken token) where T : class;
		Task<ResHandle<T>> LoadAsync<T>(string location, CancellationToken token) where T : class;
		void Release(string location);

		Task<List<ResHandle<T>>> LoadBatchAsync<T>(IEnumerable<string> locations, Action<float> onProgress, CancellationToken token) where T : class;
		Task<List<ResHandle<T>>> LoadBatchAsync<T>(IEnumerable<string> locations, CancellationToken token) where T : class;
		public void ReleaseBatch(IEnumerable<string> locations);
	}
}
```

<!-- File: Asaki/Core/Resources/IAsakiResStrategy.cs -->
<!-- GUID: 192f3260624d440b8b74ceb2a7c8ae64 -->
<!-- Size: 566 bytes -->
<!-- Modified: 2025-12-22 16:33:29 -->
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.Resources
{
	public interface IAsakiResStrategy
	{
		string StrategyName { get; }
		Task InitializeAsync();

		/// <summary>
		/// 加载资源 (支持进度回调)
		/// </summary>
		/// <param name="onProgress">进度回调 (0.0 ~ 1.0)</param>
		Task<UnityEngine.Object> LoadAssetInternalAsync(string location, Type type, Action<float> onProgress, CancellationToken token);

		void UnloadAssetInternal(string location, UnityEngine.Object asset);
	}
}
```

<!-- File: Asaki/Core/Serialization/AsakiSerializationEvents.cs -->
<!-- GUID: b9ebe72da69a4a6998e6a34247d75b97 -->
<!-- Size: 432 bytes -->
<!-- Modified: 2025-12-22 16:36:06 -->
```csharp
using Asaki.Core.Broker;

namespace Asaki.Core.Serialization
{
	public struct AsakiSaveBeginEvent : IAsakiEvent
	{
		public string Filename;
	}

	// 保存成功
	public struct AsakiSaveSuccessEvent : IAsakiEvent
	{
		public string Filename;
	}

	// 保存失败（用于弹出错误提示）
	public struct AsakiSaveFailedEvent : IAsakiEvent
	{
		public string Filename;
		public string ErrorMessage;
	}
}
```

<!-- File: Asaki/Core/Serialization/IAsakiSaveService.cs -->
<!-- GUID: 22f90f6822b04d3084d3dbe490450841 -->
<!-- Size: 830 bytes -->
<!-- Modified: 2025-12-22 16:36:09 -->
```csharp
using Asaki.Core.Context;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Asaki.Core.Serialization
{

	public interface IAsakiSaveService : IAsakiModule
	{
		// 基于 Slot 的异步保存
		Task SaveSlotAsync<TMeta, TData>(int slotId, TMeta meta, TData data)
			where TMeta : IAsakiSlotMeta where TData : IAsakiSavable;

		// 基于 Slot 的异步加载
		Task<(TMeta Meta, TData Data)> LoadSlotAsync<TMeta, TData>(int slotId)
			where TMeta : IAsakiSlotMeta, new() where TData : IAsakiSavable, new();

		// 存档工具 API
		List<int> GetUsedSlots();
		bool DeleteSlot(int slotId);
		bool SlotExists(int slotId);
	}

	public interface IAsakiSlotMeta : IAsakiSavable
	{
		int SlotId { get; set; }
		long LastSaveTime { get; set; }
		string SaveName { get; set; }
	}
}
```

<!-- File: Asaki/Core/Serialization/IAsakiSerialization.cs -->
<!-- GUID: dd8b8e25e83c45aaaa29b55a2e202f3a -->
<!-- Size: 2463 bytes -->
<!-- Modified: 2025-12-22 16:36:09 -->
```csharp
using UnityEngine;

namespace Asaki.Core.Serialization
{
	public interface IAsakiWriter
	{
		void WriteVersion(int version);

		// --- 基础类型 ---
		void WriteInt(string key, int value);
		void WriteLong(string key, long value);
		void WriteFloat(string key, float value);
		void WriteDouble(string key, double value);
		void WriteString(string key, string value);
		void WriteBool(string key, bool value);
		void WriteUInt(string key, uint value);
		void WriteULong(string key, ulong value);

		// --- Asaki Math (保留你的扩展，非常好) ---
		// 针对结构体的特定优化，避免 WriteObject 的开销
		void WriteVector2Int(string key, Vector2Int value);
		void WriteVector3Int(string key, Vector3Int value);
		void WriteVector2(string key, Vector2 value);
		void WriteVector3(string key, Vector3 value);
		void WriteVector4(string key, Vector4 value);
		void WriteBounds(string key, Bounds value);
		void WriteQuaternion(string key, Quaternion value);

		// --- 复杂对象 ---
		void WriteObject<T>(string key, T value) where T : IAsakiSavable;

		// --- 结构控制 (移除 Key 参数) ---
		void BeginList(string key, int count);
		void EndList(); // 修正：不需要 Key

		void BeginObject(string key);
		void EndObject(); // 修正：不需要 Key
	}

	public interface IAsakiReader
	{
		int ReadVersion();

		// --- 基础类型 ---
		int ReadInt(string key);
		long ReadLong(string key);
		float ReadFloat(string key);
		double ReadDouble(string key);
		string ReadString(string key);
		bool ReadBool(string key);
		uint ReadUInt(string key);
		ulong ReadULong(string key);

		// --- Asaki Math ---
		Vector2Int ReadVector2Int(string key);
		Vector3Int ReadVector3Int(string key);
		Vector2 ReadVector2(string key);
		Vector3 ReadVector3(string key);
		Vector4 ReadVector4(string key);
		Bounds ReadBounds(string key);
		Quaternion ReadQuaternion(string key);

		// --- 复杂对象 ---
		// Reader 不需要 EndObject，因为 ReadObject 方法的结束就是 End
		T ReadObject<T>(string key, T existingObj = default(T)) where T : IAsakiSavable, new();

		// --- 集合控制 ---
		int BeginList(string key);
		void EndList(); // List 需要 End，因为 List 内部是循环，Reader 需要知道何时跳出循环逻辑
	}

	public interface IAsakiSavable
	{
		void Serialize(IAsakiWriter writer);
		void Deserialize(IAsakiReader reader);
	}
}
```

<!-- File: Asaki/Core/Simulation/AsakiSimulationManager.cs -->
<!-- GUID: 987f5774f5204a9eb67c4492fc676cfc -->
<!-- Size: 2412 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;
using System.Collections.Generic;

// 仅用于排序

namespace Asaki.Core.Simulation
{
	public class AsakiSimulationManager : IAsakiService
	{
		// 包装器，用于绑定优先级
		private struct TickableWrapper
		{
			public IAsakiTickable Tickable;
			public int Priority;
		}

		private readonly List<TickableWrapper> _tickables = new List<TickableWrapper>();
		private readonly List<IAsakiFixedTickable> _fixedTickables = new List<IAsakiFixedTickable>();

		// 脏标记，用于避免每帧排序
		private bool _isDirty = false;

		// --- Standard Tick ---

		public void Register(IAsakiTickable tickable, int priority = (int)TickPriority.Normal)
		{
			// 查重 (O(N)，启动阶段可接受)
			for (int i = 0; i < _tickables.Count; i++)
			{
				if (_tickables[i].Tickable == tickable) return;
			}

			_tickables.Add(new TickableWrapper { Tickable = tickable, Priority = priority });
			_isDirty = true;
		}

		public void Unregister(IAsakiTickable tickable)
		{
			// 简单移除，O(N)
			for (int i = 0; i < _tickables.Count; i++)
			{
				if (_tickables[i].Tickable == tickable)
				{
					_tickables.RemoveAt(i);
					return;
				}
			}
		}

		public void Tick(float deltaTime)
		{
			// 1. 如果有新注册的，先排序 (Stable Sort 保证同优先级按注册顺序)
			if (_isDirty)
			{
				_tickables.Sort((a, b) => a.Priority.CompareTo(b.Priority));
				_isDirty = false;
			}

			// 2. 正序遍历 (FIFO)
			// 这里的安全性假设：不会在 Tick 循环中 Unregister 自身
			// 如果需要支持 Tick 中移除，需要改用 "for i" 并处理索引回退，或者使用 "PendingRemoveQueue"
			// 鉴于 Asaki 是架构级模块，模块生命周期通常很长，这里用 for i 足够安全且高性能
			for (int i = 0; i < _tickables.Count; i++)
			{
				// [防御性编程] 防止空引用
				TickableWrapper wrapper = _tickables[i];
				if (wrapper.Tickable != null)
				{
					wrapper.Tickable.Tick(deltaTime);
				}
			}
		}

		// --- Fixed Tick ---
		// (FixedTick 同理，建议也加上 deltaTime 参数以防万一，虽然 physics step 也就是 Time.fixedDeltaTime)
		public void FixedTick(float fixedDeltaTime)
		{
			for (int i = 0; i < _fixedTickables.Count; i++)
			{
				_fixedTickables[i].FixedTick(fixedDeltaTime);
			}
		}
	}
}
```

<!-- File: Asaki/Core/Simulation/IAsakiTickable.cs -->
<!-- GUID: d67a4f3319eb4ae2b44984f5ead5246c -->
<!-- Size: 512 bytes -->
<!-- Modified: 2025-12-22 16:35:37 -->
```csharp
using Asaki.Core.Context;

namespace Asaki.Core.Simulation
{
	public interface IAsakiTickable : IAsakiService
	{
		// 注入非托管的时间增量
		void Tick(float deltaTime);
	}

	public interface IAsakiFixedTickable : IAsakiService
	{
		void FixedTick(float fixedDeltaTime);
	}

	// [新增] 优先级定义 (数值越小越先执行)
	public enum TickPriority
	{
		High = 0,      // Input, Sensors
		Normal = 1000, // Game Logic, FSM
		Low = 2000,    // UI, Audio, View Sync
	}
}
```

<!-- File: Asaki/Core/UI/AsakiUILayer.cs -->
<!-- GUID: 138d5b07167ecfe418680ef18e8e28a7 -->
<!-- Size: 122 bytes -->
<!-- Modified: 2025-12-22 16:37:00 -->
```csharp
namespace Asaki.Core.UI
{
	public enum AsakiUILayer
	{
		Scene,
		Normal,
		Popup,
		System,
		Hidden,
	}
}
```

<!-- File: Asaki/Core/UI/AsakiUIResourceHandleAdapter.cs -->
<!-- GUID: 707f7b6f3960403e9b936ec563624020 -->
<!-- Size: 668 bytes -->
<!-- Modified: 2025-12-22 16:37:00 -->
```csharp
using Asaki.Core.Resources;
using UnityEngine;

namespace Asaki.Core.UI
{
	/// <summary>
	/// 结构体适配器 (ZeroGC)，将 ResHandle<GameObject> 适配给 IUIResourceHandle
	/// </summary>
	public struct AsakiUIResourceHandleAdapter : IUIResourceHandle
	{
		private ResHandle<GameObject> _handle;

		public AsakiUIResourceHandleAdapter(ResHandle<GameObject> handle)
		{
			_handle = handle;
		}

		public bool IsValid => _handle is { IsValid: true };
        
		// 获取原始资源 (仅 Unity 层可见)
		public GameObject Asset => _handle?.Asset;

		public void Dispose()
		{
			_handle?.Dispose();
			_handle = null;
		}
	}
}
```

<!-- File: Asaki/Core/UI/AsakiUIWidgetType.cs -->
<!-- GUID: cd7429200d27497683f47baf296cef03 -->
<!-- Size: 408 bytes -->
<!-- Modified: 2025-12-22 16:37:00 -->
```csharp
namespace Asaki.Core.UI
{
	public enum AsakiUIWidgetType
	{
		Container,   // 空容器 (RectTransform)
		Text,        // 文本 (Legacy)
		TextMeshPro, // TextMeshPro
		Button,      // 按钮
		Image,       // 图片
		InputField,  // 输入框
		ScrollView,  // 滚动视图
		Slider,      // 滑动条
		Toggle,      // 开关
		Custom,      // 自定义 (需指定 Prefab 路径)
	}
}
```

<!-- File: Asaki/Core/UI/IAsakiUIResourceHandler.cs -->
<!-- GUID: 68ea45f22a834d44a13e3cf0f34021c0 -->
<!-- Size: 135 bytes -->
<!-- Modified: 2025-12-22 16:37:00 -->
```csharp
using System;

namespace Asaki.Core.UI
{
	public interface IUIResourceHandle : IDisposable
	{
		bool IsValid { get; }
	}
}
```

<!-- File: Asaki/Core/UI/IAsakiUIService.cs -->
<!-- GUID: 64f9832577eb4f96b35edcd8adf0f124 -->
<!-- Size: 417 bytes -->
<!-- Modified: 2025-12-22 16:37:00 -->
```csharp
using Asaki.Core.Context;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.UI
{
	public interface IAsakiUIService : IAsakiModule
	{
		Task<T> OpenAsync<T>(int uiId, object args = null, CancellationToken token = default(CancellationToken))
			where T : class, IAsakiWindow;

		void Close<T>() where T : IAsakiWindow;
		void Close(IAsakiWindow window);
		void Back();
	}
}
```

<!-- File: Asaki/Core/UI/IAsakiWindow.cs -->
<!-- GUID: 5580b7a153b94c6e898195142390a33a -->
<!-- Size: 277 bytes -->
<!-- Modified: 2025-12-22 16:36:59 -->
```csharp
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.UI
{
	public interface IAsakiWindow
	{
		Task OnOpenAsync(object args, CancellationToken token);
		Task OnCloseAsync(CancellationToken token);
		void OnCover();
		void OnReveal();
	}
}
```

<!-- File: Asaki/Editor/Configuration/AsakiConfigBaker.cs -->
<!-- GUID: 32ac560ecb734ce5b7e6cc75e8ab9e08 -->
<!-- Size: 2965 bytes -->
<!-- Modified: 2025-12-23 19:34:43 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Unity.Services.Configuration;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Configuration
{
    public static class AsakiConfigBaker
    {
        [MenuItem("Asaki/Configuration/Bake All Configs to Binary")]
        public static async void BakeAllConfigs()
        {
            // 1. 准备路径
            // 注意：这里我们把 Bin 放在 StreamingAssets 旁边，或者直接覆盖
            // 通常做法是：开发用 CSV，发布只留 Bin。
            // 这里演示生成到 PersistentDataPath 供测试，或者生成到 StreamingAssets/Binary 供打包
            
            string csvDir = Path.Combine(Application.streamingAssetsPath, "Configs");
            // 假设我们发布时把 Bin 放在 StreamingAssets/ConfigBin
            string binOutDir = Path.Combine(Application.streamingAssetsPath, "ConfigBin"); 

            if (!Directory.Exists(binOutDir)) Directory.CreateDirectory(binOutDir);

            // 2. 初始化服务 (需要借助 Service 的解析能力)
            var eventService = new AsakiEventService();
            var service = new AsakiConfigService(eventService);
            // 手动注入路径 (因为 EditMode 没有 Application.persistentDataPath 的运行时逻辑)
            // 这里我们用反射或者临时修改 Service 逻辑来支持烘焙，
            // 或者更简单：直接运行游戏，Service 会自动在 PersistentDataPath 生成 Bin。
            
            // 由于 Service 逻辑比较依赖运行时，我们这里用一种 "模拟运行" 的方式：
            // 直接调用 Service 的 LoadInternalAsync，它会自动生成缓存文件。
            
            // 既然 LoadInternalAsync 已经有 Auto-Bake 功能，我们只需要触发所有表的加载即可！
            // 但 LoadInternalAsync 写入的是 PersistentDataPath。
            // 我们可以在这里做一个文件搬运。
            
            Debug.Log("Start Baking...");
            
            // 必须先初始化
            service.OnInit(); 
            
            // 加载所有表 (这会触发 Auto-Bake 到 PersistentDataPath)
            await service.LoadAllAsync();
            
            // 3. 搬运文件
            string cacheDir = Path.Combine(Application.persistentDataPath, "ConfigCache");
            var binFiles = Directory.GetFiles(cacheDir, "*.bin");
            
            foreach (var binPath in binFiles)
            {
                string fileName = Path.GetFileName(binPath);
                string destPath = Path.Combine(binOutDir, fileName);
                File.Copy(binPath, destPath, true);
                Debug.Log($"Baked: {fileName}");
            }
            
            AssetDatabase.Refresh();
            Debug.Log($"Baking Complete! Output: {binOutDir}");
        }
    }
}```

<!-- File: Asaki/Editor/Configuration/AsakiConfigDashboardWindow.cs -->
<!-- GUID: 71a20dcad883476d9f4c075555374e22 -->
<!-- Size: 23518 bytes -->
<!-- Modified: 2025-12-22 16:40:40 -->
```csharp
using Asaki.Core.Configuration;
using Asaki.Editor.Utilities.Extensions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.Configuration
{
	public class AsakiConfigDashboardWindow : EditorWindow
	{
		[MenuItem("Asaki/Configuration/Dashboard (Editor)")]
		public static void ShowWindow()
		{
			var wnd = GetWindow<AsakiConfigDashboardWindow>("Configuration Dashboard");
			wnd.minSize = new Vector2(1000, 600);
			wnd.Show();
		}

		// =========================================================
		// 状态变量
		// =========================================================
		private static string ConfigPath => Path.Combine(Application.streamingAssetsPath, "Configs");

		private ListView _classListView;
		private VisualElement _detailContainer;
		private VisualElement _tableContainer;
		private Label _pageInfoLabel;

		private List<Type> _allConfigTypes;
		private Type _selectedType;

		// CSV 数据状态
		private List<string> _headers = new List<string>();
		private List<List<string>> _csvData = new List<List<string>>();
		private Dictionary<string, Type> _columnTypeMap = new Dictionary<string, Type>();

		// [新增] 行选择状态
		private HashSet<int> _selectedIndices = new HashSet<int>();

		private bool _isDirty = false;
		private int _currentPage = 0;
		private const int PAGE_SIZE = 10;

		// =========================================================
		// UI 构建
		// =========================================================

		public void CreateGUI()
		{
			if (!Directory.Exists(ConfigPath)) Directory.CreateDirectory(ConfigPath);

			var root = rootVisualElement;
			var splitView = new TwoPaneSplitView(0, 250, TwoPaneSplitViewOrientation.Horizontal);
			root.Add(splitView);

			// --- 左侧：列表栏 ---
			var leftPane = new VisualElement { style = { backgroundColor = new Color(0.18f, 0.18f, 0.18f) } };

			var toolbar = new Toolbar();
			toolbar.Add(new ToolbarButton(RefreshList) { text = "Refresh Scan" });
			toolbar.Add(new ToolbarButton(() => EditorUtility.RevealInFinder(ConfigPath)) { text = "Open Folder" });
			leftPane.Add(toolbar);

			_classListView = new ListView();
			_classListView.makeItem = () => new Label();
			_classListView.bindItem = BindListItem;
			_classListView.selectionChanged += OnConfigListSelected;
			_classListView.style.flexGrow = 1;
			leftPane.Add(_classListView);

			splitView.Add(leftPane);

			// --- 右侧：编辑器 ---
			var rightPane = new VisualElement { style = { paddingLeft = 10, paddingRight = 10, paddingTop = 10 } };
			_detailContainer = new VisualElement { style = { flexGrow = 1 } };
			rightPane.Add(_detailContainer);

			splitView.Add(rightPane);

			root.schedule.Execute(RefreshList).ExecuteLater(10);
		}

		private void RefreshList()
		{
			_allConfigTypes = TypeCache.GetTypesDerivedFrom<IAsakiConfig>()
			                           .Where(t => !t.IsAbstract && !t.IsInterface)
			                           .OrderBy(t => t.Name)
			                           .ToList();

			if (_classListView != null)
			{
				_classListView.itemsSource = _allConfigTypes;
				_classListView.Rebuild();
			}
		}

		private void BindListItem(VisualElement element, int index)
		{
			if (index >= _allConfigTypes.Count) return;
			var type = _allConfigTypes[index];
			var label = element as Label;
			if (label == null) return;

			string path = Path.Combine(ConfigPath, type.Name + ".csv");
			label.text = type.Name;
			label.style.color = File.Exists(path) ? new Color(0.6f, 1f, 0.6f) : new Color(1f, 0.6f, 0.6f);
		}

		private void OnConfigListSelected(IEnumerable<object> selection)
		{
			if (_isDirty)
			{
				bool save = EditorUtility.DisplayDialog("Unsaved Changes", "Save changes before switching?", "Save", "Discard");
				if (save) SaveCsv();
			}

			_selectedType = selection.FirstOrDefault() as Type;
			if (_selectedType != null)
			{
				LoadCsvForType(_selectedType);
				RebuildDetailPanel();
			}
		}

		// =========================================================
		// CSV 核心逻辑
		// =========================================================

		private void LoadCsvForType(Type type)
		{
			_csvData.Clear();
			_headers.Clear();
			_columnTypeMap.Clear();
			_selectedIndices.Clear(); // 清空选择
			_currentPage = 0;
			_isDirty = false;

			var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
			foreach (var prop in props)
			{
				_columnTypeMap[prop.Name] = prop.PropertyType;
			}

			string path = Path.Combine(ConfigPath, type.Name + ".csv");
			if (!File.Exists(path)) return;

			try
			{
				string[] lines = File.ReadAllLines(path, Encoding.UTF8);
				if (lines.Length > 0)
				{
					_headers = ParseCsvLine(lines[0]);
					for (int i = 1; i < lines.Length; i++)
					{
						if (string.IsNullOrWhiteSpace(lines[i])) continue;
						_csvData.Add(ParseCsvLine(lines[i]));
					}
				}
			}
			catch (Exception e)
			{
				Debug.LogError($"Load CSV Error: {e.Message}");
			}
		}

		private List<string> ParseCsvLine(string line)
		{
			var result = new List<string>();
			bool insideQuotes = false;
			StringBuilder current = new StringBuilder();

			for (int i = 0; i < line.Length; i++)
			{
				char c = line[i];
				if (c == '"') insideQuotes = !insideQuotes;
				else if (c == ',' && !insideQuotes)
				{
					result.Add(current.ToString());
					current.Clear();
				}
				else current.Append(c);
			}
			result.Add(current.ToString());
			return result;
		}

		// =========================================================
		// 右侧编辑器绘制
		// =========================================================

		private void RebuildDetailPanel()
		{
			_detailContainer.Clear();
			if (_selectedType == null) return;

			string path = Path.Combine(ConfigPath, _selectedType.Name + ".csv");
			bool fileExists = File.Exists(path);

			DrawHeaderInfo(fileExists);

			if (fileExists)
			{
				DrawTableEditor();
			}
			else
			{
				var btn = new Button(() => GenerateDefaultCsv(_selectedType, path))
				{
					text = "Generate Default CSV",
					style = { height = 40, marginTop = 20, backgroundColor = new Color(0.2f, 0.5f, 0.2f) }
				};
				_detailContainer.Add(btn);
			}
		}

		private void DrawHeaderInfo(bool fileExists)
		{
			// 标题栏容器
			var headerBox = new VisualElement { style = { flexDirection = FlexDirection.Column, marginBottom = 10 } };

			// 第一行：标题 + 状态
			var titleRow = new VisualElement { style = { flexDirection = FlexDirection.Row, justifyContent = Justify.SpaceBetween } };
			var title = new Label(_selectedType.Name) { style = { fontSize = 20, unityFontStyleAndWeight = FontStyle.Bold } };
			titleRow.Add(title);

			if (fileExists)
			{
				var rightTools = new VisualElement { style = { flexDirection = FlexDirection.Row } };
				var saveBtn = new Button(SaveCsv) { text = "Save Changes" };
				if (_isDirty) saveBtn.style.backgroundColor = new Color(0.8f, 0.2f, 0.2f);
				rightTools.Add(saveBtn);
				titleRow.Add(rightTools);
			}
			headerBox.Add(titleRow);

			// 第二行：操作工具栏
			if (fileExists)
			{
				var toolbar = new VisualElement { style = { flexDirection = FlexDirection.Row, marginTop = 5, backgroundColor = new Color(0.22f, 0.22f, 0.22f), borderBottomLeftRadius = 4, borderBottomRightRadius = 4 } };
				toolbar.style.SetPadding(4);
				// 数据操作
				toolbar.Add(new Label("Data Ops: ") { style = { alignSelf = Align.Center, marginRight = 5, color = Color.gray } });
				toolbar.Add(new Button(ReindexIds) { text = "Reindex ID", style = { marginRight = 2 } });
				toolbar.Add(new Button(async () => await ReorderIdsAsync()) { text = "Sort ID", style = { marginRight = 10 } });

				// [需求1] 行操作
				toolbar.Add(new Label("Row Ops: ") { style = { alignSelf = Align.Center, marginRight = 5, color = Color.gray } });
				toolbar.Add(new Button(AddNewRow) { text = "+ Add Row", style = { backgroundColor = new Color(0.2f, 0.4f, 0.2f) } });

				// [需求2] 批量删除
				string delText = _selectedIndices.Count > 0 ? $"Delete Selected ({_selectedIndices.Count})" : "Delete (Select Rows)";
				var delBtn = new Button(DeleteSelectedRows) { text = delText };
				if (_selectedIndices.Count > 0) delBtn.style.backgroundColor = new Color(0.6f, 0.2f, 0.2f);
				else delBtn.SetEnabled(false);

				toolbar.Add(delBtn);

				headerBox.Add(toolbar);
			}
			_detailContainer.Add(headerBox);
		}

		private void DrawTableEditor()
		{
			_tableContainer = new ScrollView(ScrollViewMode.Vertical);
			_tableContainer.style.flexGrow = 1;
			_tableContainer.style.backgroundColor = new Color(0.15f, 0.15f, 0.15f);

			// --- Header Row ---
			var headerRow = new VisualElement { style = { flexDirection = FlexDirection.Row, backgroundColor = new Color(0.25f, 0.25f, 0.25f), paddingBottom = 5, paddingTop = 5 } };

			// 选择全选框列
			var selectAllToggle = new Toggle { style = { width = 30, paddingLeft = 5 } };
			selectAllToggle.RegisterValueChangedCallback(evt => SelectAllOnPage(evt.newValue));
			headerRow.Add(selectAllToggle);

			for (int i = 0; i < _headers.Count; i++)
			{
				string colName = _headers[i];
				float width = IsVectorType(colName) ? 200 : 120;
				var label = new Label(colName) { style = { width = width, unityTextAlign = TextAnchor.MiddleCenter, unityFontStyleAndWeight = FontStyle.Bold } };

				// [需求3] 批量列操作：右键菜单
				int colIndex = i; // capture
				label.RegisterCallback<ContextClickEvent>(evt => ShowColumnContextMenu(evt, colIndex, colName));

				headerRow.Add(label);
			}
			_tableContainer.Add(headerRow);

			// --- Data Rows ---
			int start = _currentPage * PAGE_SIZE;
			int end = Mathf.Min(start + PAGE_SIZE, _csvData.Count);

			for (int i = start; i < end; i++)
			{
				var rowData = _csvData[i];
				bool isSelected = _selectedIndices.Contains(i);

				var rowVis = new VisualElement { style = { flexDirection = FlexDirection.Row, borderBottomWidth = 1, borderBottomColor = new Color(0.3f, 0.3f, 0.3f), alignItems = Align.Center } };
				// 选中高亮
				if (isSelected) rowVis.style.backgroundColor = new Color(0.3f, 0.4f, 0.5f, 0.5f);

				int rowIndex = i;

				// 1. 行选择 Checkbox
				var rowSelect = new Toggle { value = isSelected, style = { width = 30, paddingLeft = 5 } };
				rowSelect.RegisterValueChangedCallback(evt =>
				{
					if (evt.newValue) _selectedIndices.Add(rowIndex);
					else _selectedIndices.Remove(rowIndex);
					// 重新绘制以刷新 Header 上的删除按钮状态
					RebuildDetailPanel();
				});
				rowVis.Add(rowSelect);

				// 2. 数据列
				for (int c = 0; c < _headers.Count; c++)
				{
					int colIndex = c;
					string colName = _headers[c];
					string val = (c < rowData.Count) ? rowData[c] : "";

					Type colType = _columnTypeMap.ContainsKey(colName) ? _columnTypeMap[colName] : typeof(string);
					VisualElement cellElement = CreateCell(rowIndex, colIndex, val, colType);
					rowVis.Add(cellElement);
				}
				_tableContainer.Add(rowVis);
			}

			_detailContainer.Add(_tableContainer);
			DrawPaginationControls();
		}

		// =========================================================
		// [需求3] 批量列操作逻辑
		// =========================================================

		private void ShowColumnContextMenu(ContextClickEvent evt, int colIndex, string colName)
		{
			var menu = new GenericMenu();
			menu.AddItem(new GUIContent($"Batch Edit '{colName}'/Fill ALL Rows"), false, () => OpenBulkEditPopup(colIndex, colName, false));

			if (_selectedIndices.Count > 0)
			{
				menu.AddItem(new GUIContent($"Batch Edit '{colName}'/Fill SELECTED Rows ({_selectedIndices.Count})"), false, () => OpenBulkEditPopup(colIndex, colName, true));
			}
			else
			{
				menu.AddDisabledItem(new GUIContent($"Batch Edit '{colName}'/Fill SELECTED Rows"));
			}

			menu.ShowAsContext();
		}

		private void OpenBulkEditPopup(int colIndex, string colName, bool onlySelected)
		{
			// 弹出一个小窗口输入值
			BulkEditPopup.Show(colName, (newVal) =>
			{
				ApplyBulkEdit(colIndex, newVal, onlySelected);
			});
		}

		private void ApplyBulkEdit(int colIndex, string newValue, bool onlySelected)
		{
			int count = 0;
			for (int i = 0; i < _csvData.Count; i++)
			{
				if (onlySelected && !_selectedIndices.Contains(i)) continue;

				// 确保行有足够的列
				while (colIndex >= _csvData[i].Count) _csvData[i].Add("");

				if (_csvData[i][colIndex] != newValue)
				{
					_csvData[i][colIndex] = newValue;
					count++;
				}
			}

			if (count > 0)
			{
				_isDirty = true;
				RebuildDetailPanel();
				Debug.Log($"[Bulk Edit] Updated {count} rows in column '{_headers[colIndex]}' to '{newValue}'");
			}
		}

		// =========================================================
		// [需求1 & 2] 行操作逻辑
		// =========================================================

		private void AddNewRow()
		{
			// 1. 创建默认行
			List<string> newRow = new List<string>();
			foreach (var header in _headers)
			{
				Type t = _columnTypeMap.ContainsKey(header) ? _columnTypeMap[header] : typeof(string);
				// 特殊处理 ID：自动递增
				if (header == "Id" || header == "ID")
				{
					int maxId = 0;
					foreach (var row in _csvData)
					{
						// 尝试查找最大ID
						int idx = _headers.IndexOf(header);
						if (idx >= 0 && idx < row.Count && int.TryParse(row[idx], out int id))
						{
							if (id > maxId) maxId = id;
						}
					}
					newRow.Add((maxId + 1).ToString());
				}
				else
				{
					newRow.Add(GetDefaultValueString(t).Replace("\"", "")); // 去除默认值的引号
				}
			}

			_csvData.Add(newRow);
			_isDirty = true;

			// 2. 跳转到最后一页
			int totalPages = Mathf.CeilToInt((float)_csvData.Count / PAGE_SIZE);
			if (totalPages > 0) _currentPage = totalPages - 1;

			RebuildDetailPanel();
		}

		private void DeleteSelectedRows()
		{
			if (_selectedIndices.Count == 0) return;

			if (EditorUtility.DisplayDialog("Confirm Delete", $"Delete {_selectedIndices.Count} rows?", "Delete", "Cancel"))
			{
				// 从后往前删，防止索引偏移
				var sortedIndices = _selectedIndices.OrderByDescending(i => i).ToList();
				foreach (int index in sortedIndices)
				{
					if (index < _csvData.Count)
					{
						_csvData.RemoveAt(index);
					}
				}

				_selectedIndices.Clear();
				_isDirty = true;

				// 防止页码溢出
				int totalPages = Mathf.CeilToInt((float)_csvData.Count / PAGE_SIZE);
				if (_currentPage >= totalPages && totalPages > 0) _currentPage = totalPages - 1;

				RebuildDetailPanel();
			}
		}

		private void SelectAllOnPage(bool select)
		{
			int start = _currentPage * PAGE_SIZE;
			int end = Mathf.Min(start + PAGE_SIZE, _csvData.Count);

			for (int i = start; i < end; i++)
			{
				if (select) _selectedIndices.Add(i);
				else _selectedIndices.Remove(i);
			}
			RebuildDetailPanel();
		}

		// =========================================================
		// 辅助方法 (Cell Creation & Parsing)
		// =========================================================

		private bool IsVectorType(string colName)
		{
			if (_columnTypeMap.TryGetValue(colName, out Type t))
				return t == typeof(Vector3) || t == typeof(Vector2);
			return false;
		}

		private VisualElement CreateCell(int rowIndex, int colIndex, string val, Type type)
		{
			if (type == typeof(bool))
			{
				bool boolVal = val.ToLower() == "true" || val == "1";
				var toggle = new Toggle { value = boolVal, style = { width = 120, marginRight = 2, justifyContent = Justify.Center } };
				toggle.RegisterValueChangedCallback(evt => UpdateCellData(rowIndex, colIndex, evt.newValue.ToString().ToLower()));
				return toggle;
			}
			else if (type == typeof(Vector3))
			{
				var vec3 = ParseVector3(val);
				var field = new Vector3Field { value = vec3, style = { width = 200, marginRight = 2 } };
				field.RegisterValueChangedCallback(evt => UpdateCellData(rowIndex, colIndex, $"{evt.newValue.x},{evt.newValue.y},{evt.newValue.z}"));
				return field;
			}
			else if (type == typeof(Vector2))
			{
				var vec2 = ParseVector2(val);
				var field = new Vector2Field { value = vec2, style = { width = 200, marginRight = 2 } };
				field.RegisterValueChangedCallback(evt => UpdateCellData(rowIndex, colIndex, $"{evt.newValue.x},{evt.newValue.y}"));
				return field;
			}
			else
			{
				var textField = new TextField { value = val, style = { width = 120, marginRight = 2 } };
				textField.RegisterValueChangedCallback(evt => UpdateCellData(rowIndex, colIndex, evt.newValue));
				return textField;
			}
		}

		private Vector3 ParseVector3(string s)
		{
			s = s.Trim('"');
			var parts = s.Split(',');
			if (parts.Length < 3) return Vector3.zero;
			float.TryParse(parts[0], out float x);
			float.TryParse(parts[1], out float y);
			float.TryParse(parts[2], out float z);
			return new Vector3(x, y, z);
		}

		private Vector2 ParseVector2(string s)
		{
			s = s.Trim('"');
			var parts = s.Split(',');
			if (parts.Length < 2) return Vector2.zero;
			float.TryParse(parts[0], out float x);
			float.TryParse(parts[1], out float y);
			return new Vector2(x, y);
		}

		private void UpdateCellData(int row, int col, string newValue)
		{
			while (row >= _csvData.Count) _csvData.Add(new List<string>());
			var rowList = _csvData[row];
			while (col >= rowList.Count) rowList.Add("");

			if (rowList[col] != newValue)
			{
				rowList[col] = newValue;
				_isDirty = true;
			}
		}

		private void ReindexIds()
		{
			int idIndex = _headers.IndexOf("Id");
			if (idIndex == -1) idIndex = _headers.IndexOf("ID");
			if (idIndex == -1)
			{
				EditorUtility.DisplayDialog("Error", "Column 'Id' not found.", "OK");
				return;
			}

			for (int i = 0; i < _csvData.Count; i++)
			{
				while (idIndex >= _csvData[i].Count) _csvData[i].Add("");
				_csvData[i][idIndex] = (i + 1).ToString();
			}
			_isDirty = true;
			RebuildDetailPanel();
			Debug.Log("[AsakiDashboard] IDs reindexed from 1.");
		}

		private async Task ReorderIdsAsync()
		{
			int idIndex = _headers.IndexOf("Id");
			if (idIndex == -1) idIndex = _headers.IndexOf("ID");
			if (idIndex == -1)
			{
				EditorUtility.DisplayDialog("Error", "Column 'Id' not found.", "OK");
				return;
			}

			await Task.Run(() =>
			{
				_csvData.Sort((rowA, rowB) =>
				{
					string valA = (idIndex < rowA.Count) ? rowA[idIndex] : "0";
					string valB = (idIndex < rowB.Count) ? rowB[idIndex] : "0";
					if (int.TryParse(valA, out int a) && int.TryParse(valB, out int b)) return a.CompareTo(b);
					return string.Compare(valA, valB);
				});
			});

			_isDirty = true;
			_currentPage = 0;
			RebuildDetailPanel();
			Debug.Log("[AsakiDashboard] Async Sort Completed.");
		}

		private void SaveCsv()
		{
			if (_selectedType == null) return;
			string path = Path.Combine(ConfigPath, _selectedType.Name + ".csv");
			try
			{
				var sb = new StringBuilder();
				sb.AppendLine(string.Join(",", _headers));
				foreach (var row in _csvData)
				{
					var escapedRow = row.Select(cell =>
					{
						if (cell.Contains(",")) return $"\"{cell}\"";
						return cell;
					});
					sb.AppendLine(string.Join(",", escapedRow));
				}
				File.WriteAllText(path, sb.ToString(), Encoding.UTF8);
				_isDirty = false;
				AssetDatabase.Refresh();
				RebuildDetailPanel();
				Debug.Log($"[AsakiDashboard] Saved {_selectedType.Name}.csv");
			}
			catch (Exception ex) { Debug.LogError($"Save Failed: {ex.Message}"); }
		}

		private void GenerateDefaultCsv(Type type, string path)
		{
			var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.CanWrite && p.CanRead).ToArray();
			var sb = new StringBuilder();
			sb.AppendLine(string.Join(",", props.Select(p => p.Name)));
			var defaultValues = props.Select(p => GetDefaultValueString(p.PropertyType));
			sb.AppendLine(string.Join(",", defaultValues));
			File.WriteAllText(path, sb.ToString(), Encoding.UTF8);
			AssetDatabase.Refresh();
			RefreshList();
			LoadCsvForType(type);
			RebuildDetailPanel();
		}

		private string GetDefaultValueString(Type t)
		{
			if (t == typeof(int) || t == typeof(long) || t == typeof(float) || t == typeof(double)) return "0";
			if (t == typeof(string)) return "default";
			if (t == typeof(bool)) return "false";
			if (t == typeof(Vector3)) return "\"0,0,0\"";
			if (t == typeof(Vector2)) return "\"0,0\"";
			return "null";
		}

		private void DrawPaginationControls()
		{
			var footer = new VisualElement { style = { flexDirection = FlexDirection.Row, justifyContent = Justify.Center, marginTop = 10, height = 30 } };
			int totalPages = Mathf.CeilToInt((float)_csvData.Count / PAGE_SIZE);
			if (totalPages == 0) totalPages = 1;

			var prevBtn = new Button(() =>
			{
				if (_currentPage > 0)
				{
					_currentPage--;
					RebuildDetailPanel();
				}
			}) { text = "< Prev" };
			var nextBtn = new Button(() =>
			{
				if (_currentPage < totalPages - 1)
				{
					_currentPage++;
					RebuildDetailPanel();
				}
			}) { text = "Next >" };

			_pageInfoLabel = new Label($"Page {_currentPage + 1} / {totalPages} (Total: {_csvData.Count})")
				{ style = { unityTextAlign = TextAnchor.MiddleCenter, paddingLeft = 10, paddingRight = 10, paddingTop = 5 } };

			footer.Add(prevBtn);
			footer.Add(_pageInfoLabel);
			footer.Add(nextBtn);
			if (_isDirty) footer.Add(new Label("  [Unsaved Changes]") { style = { color = Color.yellow, paddingTop = 5 } });
			_detailContainer.Add(footer);
		}
	}

	// =========================================================
	// 简单的输入弹窗 (用于批量修改)
	// =========================================================
	public class BulkEditPopup : EditorWindow
	{
		private static Action<string> _onConfirm;
		private static string _title;
		private string _input = "";

		public static void Show(string colName, Action<string> onConfirm)
		{
			_title = $"Bulk Edit: {colName}";
			_onConfirm = onConfirm;
			var wnd = GetWindow<BulkEditPopup>(true, "Batch Edit", true);
			wnd.minSize = new Vector2(300, 100);
			wnd.maxSize = new Vector2(300, 100);
			wnd.ShowUtility();
		}

		private void OnGUI()
		{
			EditorGUILayout.LabelField(_title, EditorStyles.boldLabel);
			EditorGUILayout.HelpBox("Enter new value for this column (Vector format: x,y,z)", MessageType.Info);

			GUI.SetNextControlName("BulkInput");
			_input = EditorGUILayout.TextField(_input);

			GUILayout.FlexibleSpace();
			if (GUILayout.Button("Apply"))
			{
				_onConfirm?.Invoke(_input);
				Close();
			}

			// 自动聚焦
			if (Event.current.type == EventType.Repaint)
				EditorGUI.FocusTextInControl("BulkInput");
		}
	}
}
```

<!-- File: Asaki/Editor/Configuration/AsakiConfigDebugger.cs -->
<!-- GUID: 5d32998f9cc8489689ccdfbf8a4afa81 -->
<!-- Size: 15684 bytes -->
<!-- Modified: 2025-12-22 16:45:04 -->
```csharp
using Asaki.Core.Configuration;
using Asaki.Core.Context;
using Asaki.Unity;
using Asaki.Unity.Services.Configuration;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.Configuration
{
    public class AsakiConfigRuntimeEditor : EditorWindow
    {
        [MenuItem("Asaki/Configuration/Runtime Editor (Table)")]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiConfigRuntimeEditor>("Configuration Runtime Editor");
            wnd.minSize = new Vector2(900, 600);
            wnd.Show();
        }

        // =========================================================
        // 状态与引用
        // =========================================================
        private TwoPaneSplitView _splitView;
        private ListView _tableListView;
        private MultiColumnListView _dataGrid; // 核心组件：多列列表
        private VisualElement _rightPanelContainer;
        private Label _statusLabel;

        private IAsakiConfigService _service;
        private FieldInfo _storeField; // 用于反射获取数据源
        
        private Type _currentType;
        private IList _currentDataList; // 当前显示的配置数据列表
        private PropertyInfo[] _currentProps; // 当前配置类的属性缓存

        // =========================================================
        // UI 构建
        // =========================================================
        private void OnEnable()
        {
            // 缓存反射信息
            _storeField = typeof(AsakiConfigService).GetField("_configStore", BindingFlags.NonPublic | BindingFlags.Instance);
        }

        public void CreateGUI()
        {
            var root = rootVisualElement;

            // 1. 顶部状态栏 (运行检测)
            _statusLabel = new Label("Waiting for Runtime...") 
            { 
                style = { paddingBottom = 5, paddingTop = 5, paddingLeft = 5, unityFontStyleAndWeight = FontStyle.Bold, backgroundColor = new Color(0.2f,0.2f,0.2f) } 
            };
            root.Add(_statusLabel);

            // 2. 主分割视图
            _splitView = new TwoPaneSplitView(0, 250, TwoPaneSplitViewOrientation.Horizontal);
            root.Add(_splitView);

            // --- 左侧：表单列表 ---
            var leftPane = new VisualElement();
            leftPane.style.backgroundColor = new Color(0.18f, 0.18f, 0.18f);
            
            var leftToolbar = new Toolbar();
            leftToolbar.Add(new ToolbarButton(RefreshTables) { text = "Refresh Tables" });
            leftPane.Add(leftToolbar);

            _tableListView = new ListView();
            _tableListView.makeItem = () => new Label();
            _tableListView.bindItem = (e, i) => { 
                var type = (Type)_tableListView.itemsSource[i];
                (e as Label).text = type.Name; 
            };
            _tableListView.selectionChanged += OnTableSelectionChanged;
            _tableListView.style.flexGrow = 1;
            leftPane.Add(_tableListView);
            _splitView.Add(leftPane);

            // --- 右侧：数据表格 ---
            var rightPane = new VisualElement();
            
            // 工具栏
            var rightToolbar = new Toolbar();
            rightToolbar.Add(new ToolbarButton(() => {
                if(_currentType != null) ReloadCurrentTable();
            }) { text = "Reload from Disk" });
            
            rightToolbar.Add(new ToolbarSpacer());
            
            // 核心功能：保存回 CSV
            var saveBtn = new ToolbarButton(() => {
                if(_currentType != null) SaveCurrentToCsv();
            }) { text = "Save Memory to CSV", style = { unityFontStyleAndWeight = FontStyle.Bold, color = new Color(0.8f, 1f, 0.8f) } };
            rightToolbar.Add(saveBtn);
            
            rightPane.Add(rightToolbar);

            _rightPanelContainer = new VisualElement { style = { flexGrow = 1 } };
            rightPane.Add(_rightPanelContainer);
            _splitView.Add(rightPane);

            // 检查运行状态
            EditorApplication.update += OnEditorUpdate;
        }

        private void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }

        private void OnEditorUpdate()
        {
            bool isPlaying = Application.isPlaying;
            _splitView.SetEnabled(isPlaying);
            
            if (!isPlaying)
            {
                _statusLabel.text = "⚠️ Runtime Only. Please enter Play Mode.";
                _statusLabel.style.color = Color.yellow;
                _service = null;
            }
            else if (_service == null)
            {
                // 尝试获取服务
                _service = AsakiContext.Get<IAsakiConfigService>();
                if (_service != null)
                {
                    _statusLabel.text = "🟢 Connected to Asaki Configuration Service";
                    _statusLabel.style.color = Color.green;
                    RefreshTables();
                }
                else
                {
                    _statusLabel.text = "⚠️ Waiting for AsakiConfigService registration...";
                }
            }
        }

        // =========================================================
        // 逻辑控制
        // =========================================================

        private void RefreshTables()
        {
            if (_service == null || _storeField == null) return;

            var store = _storeField.GetValue(_service) as System.Collections.IDictionary;
            if (store == null) return;

            var types = new List<Type>();
            foreach (var key in store.Keys)
            {
                if (key is Type t) types.Add(t);
            }
            types.Sort((a, b) => string.Compare(a.Name, b.Name, StringComparison.Ordinal));

            _tableListView.itemsSource = types;
            _tableListView.Rebuild();
        }

        private void OnTableSelectionChanged(IEnumerable<object> selection)
        {
            _currentType = selection.FirstOrDefault() as Type;
            if (_currentType != null)
            {
                BuildDataGrid(_currentType);
            }
        }

        private void ReloadCurrentTable()
        {
            if (_currentType == null) return;
            
            // 反射调用 ReloadAsync
            var method = _service.GetType().GetMethod("ReloadAsync");
            var generic = method.MakeGenericMethod(_currentType);
            generic.Invoke(_service, null);

            // 延迟刷新 UI 以等待异步加载完成 (简单处理，实际应await task)
            rootVisualElement.schedule.Execute(() => BuildDataGrid(_currentType)).ExecuteLater(200);
        }

        // =========================================================
        // 核心：构建多列表格 (MultiColumnListView)
        // =========================================================

        private void BuildDataGrid(Type type)
        {
            _rightPanelContainer.Clear();

            // 1. 获取数据
            var getAllMethod = _service.GetType().GetMethod("GetAll").MakeGenericMethod(type);
            var enumerable = getAllMethod.Invoke(_service, null) as IEnumerable;
            
            // 转为非泛型 List 以便索引访问
            _currentDataList = new ArrayList();
            foreach (var item in enumerable) _currentDataList.Add(item);

            // 2. 获取属性 (Columns)
            _currentProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(p => p.CanRead && p.CanWrite) // 仅显示可读写属性
                .ToArray();

            // 3. 创建 MultiColumnListView
            _dataGrid = new MultiColumnListView
            {
                itemsSource = _currentDataList,
                style = { flexGrow = 1 }
            };

            // 4. 动态生成列
            foreach (var prop in _currentProps)
            {
                var column = new Column
                {
                    name = prop.Name,
                    title = $"{prop.Name} ({GetTypeName(prop.PropertyType)})",
                    width = GetColumnWidth(prop.PropertyType),
                    
                    // 核心：生成单元格编辑器
                    makeCell = () => CreateCellEditor(prop.PropertyType),
                    
                    // 核心：绑定数据与回调
                    bindCell = (element, index) => BindCellEditor(element, index, prop)
                };
                
                _dataGrid.columns.Add(column);
            }

            _rightPanelContainer.Add(_dataGrid);
            _statusLabel.text = $"Editing {type.Name} ({_currentDataList.Count} rows) - Changes are applied to MEMORY immediately.";
        }

        // =========================================================
        // 单元格编辑逻辑 (Cell Rendering & Binding)
        // =========================================================

        private VisualElement CreateCellEditor(Type type)
        {
            if (type == typeof(bool)) return new Toggle();
            if (type == typeof(int)) return new IntegerField();
            if (type == typeof(float)) return new FloatField();
            if (type == typeof(string)) return new TextField();
            if (type == typeof(Vector3)) return new Vector3Field();
            
            // 默认回退
            return new TextField();
        }

        private void BindCellEditor(VisualElement element, int index, PropertyInfo prop)
        {
            if (index >= _currentDataList.Count) return;
            object dataObject = _currentDataList[index];
            object value = prop.GetValue(dataObject);

            // 绑定逻辑 + 注册修改回调
            // 注意：必须先解绑旧事件(虽然创建新Cell较少复用，但MCLV会有复用机制)
            // UIToolkit 的 Bind 最佳实践通常是使用userData或者清理Callback，这里简化处理
            
            if (element is Toggle toggle)
            {
                toggle.SetValueWithoutNotify((bool)value);
                toggle.RegisterValueChangedCallback(evt => UpdateValue(index, prop, evt.newValue));
            }
            else if (element is IntegerField intField)
            {
                intField.SetValueWithoutNotify((int)value);
                intField.RegisterValueChangedCallback(evt => UpdateValue(index, prop, evt.newValue));
            }
            else if (element is FloatField floatField)
            {
                floatField.SetValueWithoutNotify((float)value);
                floatField.RegisterValueChangedCallback(evt => UpdateValue(index, prop, evt.newValue));
            }
            else if (element is Vector3Field v3Field)
            {
                v3Field.SetValueWithoutNotify((Vector3)value);
                v3Field.RegisterValueChangedCallback(evt => UpdateValue(index, prop, evt.newValue));
            }
            else if (element is TextField txtField)
            {
                txtField.SetValueWithoutNotify(value?.ToString() ?? "");
                // 字符串或其他类型的回退处理
                txtField.RegisterValueChangedCallback(evt => {
                    // 如果是纯字符串
                    if(prop.PropertyType == typeof(string))
                        UpdateValue(index, prop, evt.newValue);
                    // 如果是其他复杂类型，可以在这里解析字符串
                });
            }
        }

        private void UpdateValue(int index, PropertyInfo prop, object newValue)
        {
            if (index >= _currentDataList.Count) return;
            object dataObject = _currentDataList[index];
            
            // 修改内存中的对象
            prop.SetValue(dataObject, newValue);
            
            // 可选：高亮修改过的行，或者在控制台打印
            // Debug.Log($"[RuntimeEdit] Modified {prop.Name} -> {newValue}");
        }

        // =========================================================
        // CSV 保存逻辑
        // =========================================================

        private void SaveCurrentToCsv()
        {
            if (_currentType == null || _currentDataList == null) return;

            string path = Path.Combine(Application.streamingAssetsPath, "Configs", _currentType.Name + ".csv");
            
            if (EditorUtility.DisplayDialog("Save to CSV", 
                $"Are you sure you want to overwrite '{_currentType.Name}.csv' with current runtime memory data?", 
                "Save & Overwrite", "Cancel"))
            {
                try
                {
                    var sb = new StringBuilder();
                    
                    // 1. Header
                    sb.AppendLine(string.Join(",", _currentProps.Select(p => p.Name)));

                    // 2. Data Rows
                    foreach (var item in _currentDataList)
                    {
                        var values = _currentProps.Select(p => FormatValueForCsv(p.GetValue(item), p.PropertyType));
                        sb.AppendLine(string.Join(",", values));
                    }

                    File.WriteAllText(path, sb.ToString(), Encoding.UTF8);
                    Debug.Log($"[AsakiConfig] Saved runtime data to {path}");
                    AssetDatabase.Refresh();
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Failed to save CSV: {ex.Message}");
                }
            }
        }

        private string FormatValueForCsv(object val, Type type)
        {
            if (val == null) return "";
            if (type == typeof(Vector3))
            {
                var v = (Vector3)val;
                return $"\"{v.x},{v.y},{v.z}\""; // 加引号
            }
            // 简单处理字符串内的逗号
            if (type == typeof(string) && val.ToString().Contains(","))
            {
                return $"\"{val}\"";
            }
            return val.ToString();
        }

        // =========================================================
        // 辅助方法
        // =========================================================

        private string GetTypeName(Type t)
        {
            if (t == typeof(int)) return "int";
            if (t == typeof(float)) return "float";
            if (t == typeof(string)) return "string";
            if (t == typeof(bool)) return "bool";
            if (t == typeof(Vector3)) return "Vec3";
            return t.Name;
        }

        private float GetColumnWidth(Type t)
        {
            if (t == typeof(int)) return 60;
            if (t == typeof(bool)) return 40;
            if (t == typeof(Vector3)) return 150;
            if (t == typeof(string)) return 120;
            return 100;
        }
    }
}```

<!-- File: Asaki/Editor/Debugging/AsakiEventDebuggerWindow.cs -->
<!-- GUID: 0115744efefb47a6a183a9eeb725da1f -->
<!-- Size: 29178 bytes -->
<!-- Modified: 2025-12-23 19:34:42 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Editor.Utilities.Extensions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using AsakiBroker = Asaki.Core.Broker.AsakiBroker;
using Component = UnityEngine.Component;

namespace Asaki.Editor.Debugging
{
    public class AsakiEventDebuggerWindow : EditorWindow
    {
        [MenuItem("Asaki/Debugger/Event Inspector &F8")]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiEventDebuggerWindow>();
            wnd.titleContent = new GUIContent("Asaki Events", EditorGUIUtility.IconContent("d_EventSystem Icon").image);
            wnd.minSize = new Vector2(600, 400);
            wnd.Show();
        }

        // --- 状态数据 ---
        private List<Type> _allEventTypes = new List<Type>();
        private Type _selectedEventType;
        private string _searchFilter = "";
        private Vector2 _scrollPosLeft;
        private Vector2 _scrollPosRight;
        private float _leftPanelWidth = 200f;

        // --- 反射缓存 ---
        private Dictionary<Type, object> _paramInstances = new Dictionary<Type, object>();
        private Dictionary<Type, EventDebugInfo> _eventInfoCache = new Dictionary<Type, EventDebugInfo>();
        private Dictionary<Type, List<FieldInfo>> _fieldInfoCache = new Dictionary<Type, List<FieldInfo>>();
        // --- 性能统计 ---
        private Dictionary<Type, EventStats> _eventStats = new Dictionary<Type, EventStats>();
        private DateTime _sessionStartTime = DateTime.Now;

        private FieldInfo _busBucketsField;
        private FieldInfo _bucketHandlersField;

        private class EventDebugInfo
        {
            public string Namespace;
            public string FullName;
            public List<string> Interfaces = new List<string>();
            public List<FieldInfo> Fields = new List<FieldInfo>();
            public bool HasDocumentation;
            public Type BaseType;
        }

        private class EventStats
        {
            public int PublishCount;
            public double LastPublishTime;
            public int SubscriberCount;
        }


        private void OnEnable()
        {
            RefreshEventTypes();
            InitializeReflection();
            EditorApplication.playModeStateChanged += OnPlayModeChanged;
        }

        private void OnDisable()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeChanged;
        }
        
        private void InitializeReflection()
        {
            var busType = typeof(AsakiEventService);
            _busBucketsField = busType.GetField("_buckets", BindingFlags.NonPublic | BindingFlags.Instance);
        }
        
        private void OnPlayModeChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.EnteredPlayMode)
            {
                _eventStats.Clear();
                _sessionStartTime = DateTime.Now;
            }
            Repaint();
        }

        // 【核心修复】在 OnGUI 开始时强制钳制宽度
        private void OnGUI()
        {
            DrawToolbar();

            // 布局钳制
            float windowWidth = position.width;
            const float minPanelWidth = 150f;
            const float rightPanelMin = 400f;
            float maxPanelWidth = Mathf.Max(minPanelWidth, windowWidth - rightPanelMin);
            
            _leftPanelWidth = Mathf.Clamp(_leftPanelWidth, minPanelWidth, maxPanelWidth);

            EditorGUILayout.BeginHorizontal();
            DrawLeftPanel();
            GUILayoutExtensions.Splitter(ref _leftPanelWidth, minPanelWidth, maxPanelWidth, false,() => Repaint());
            DrawRightPanel();
            EditorGUILayout.EndHorizontal();
        }

        private void RefreshEventTypes()
        {
            _allEventTypes = TypeCache.GetTypesDerivedFrom<IAsakiEvent>()
                                      .Where(t => t.IsValueType && !t.IsAbstract)
                                      .OrderBy(t => t.Namespace)
                                      .ThenBy(t => t.Name)
                                      .ToList();

            foreach (var type in _allEventTypes)
            {
                CacheEventInfo(type);
                if (!_eventStats.ContainsKey(type))
                {
                    _eventStats[type] = new EventStats();
                }
            }
        }

        private void CacheEventInfo(Type type)
        {
            if (_eventInfoCache.ContainsKey(type)) return;

            var info = new EventDebugInfo
            {
                Namespace = type.Namespace,
                FullName = type.FullName,
                BaseType = type.BaseType,
                Fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance).ToList(),
                Interfaces = type.GetInterfaces().Select(i => i.Name).ToList()
            };

            info.HasDocumentation = !string.IsNullOrEmpty(GetTypeSummary(type));
            _eventInfoCache[type] = info;
            _fieldInfoCache[type] = info.Fields;
        }

        private string GetTypeSummary(Type type)
        {
            var attr = type.GetCustomAttribute<DescriptionAttribute>();
            return attr?.Description ?? "";
        }

        // ==================================================================================
        // UI 绘制逻辑 - 完全使用 GUILayout 自动布局
        // ==================================================================================

        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            if (GUILayout.Button("Refresh", EditorStyles.toolbarButton, GUILayout.Width(60))) RefreshEventTypes();
            
            _searchFilter = EditorGUILayout.TextField(_searchFilter, EditorStyles.toolbarSearchField, GUILayout.Width(200));
            
            GUILayout.FlexibleSpace();
            if (Application.isPlaying)
            {
                var elapsed = (DateTime.Now - _sessionStartTime).TotalSeconds;
                GUILayout.Label($"● LIVE ({elapsed:F0}s)", EditorStyles.boldLabel);
            }
            EditorGUILayout.EndHorizontal();
        }

        private void DrawLeftPanel()
        {
            EditorGUILayout.BeginVertical(GUILayout.Width(_leftPanelWidth));
            _scrollPosLeft = EditorGUILayout.BeginScrollView(_scrollPosLeft);

            var filteredTypes = string.IsNullOrEmpty(_searchFilter)
                ? _allEventTypes
                : _allEventTypes.Where(t => t.Name.IndexOf(_searchFilter, StringComparison.OrdinalIgnoreCase) >= 0).ToList();

            foreach (var type in filteredTypes)
            {
                // 实时更新订阅数
                if (Event.current.type == EventType.Layout && Application.isPlaying)
                {
                    _eventStats[type].SubscriberCount = GetSubscriberCount(type);
                }
                DrawEventListItem(type, _eventStats[type]);
            }

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        /// <summary>
        /// 【核心修复】使用纯 GUILayout，移除所有固定宽度限制
        /// </summary>
        private void DrawEventListItem(Type type, EventStats stats)
        {
            bool isSelected = type == _selectedEventType;
            GUIStyle style = new GUIStyle(GUI.skin.button) { alignment = TextAnchor.MiddleLeft };
            if (isSelected) style.normal.textColor = Color.cyan;

            EditorGUILayout.BeginHorizontal(style);
            
            if (GUILayout.Button(type.Name, style, GUILayout.ExpandWidth(true)))
            {
                _selectedEventType = type;
                EnsureParamInstance(type);
                GUI.FocusControl(null);
            }

            // 订阅数 Badge
            if (stats.SubscriberCount > 0)
            {
                var originalColor = GUI.color;
                GUI.color = Color.green;
                GUILayout.Label(stats.SubscriberCount.ToString(), EditorStyles.miniLabel, GUILayout.Width(20));
                GUI.color = originalColor;
            }

            EditorGUILayout.EndHorizontal();
        }

        private GUIStyle GetListItemStyle(bool isSelected)
        {
            var style = new GUIStyle(GUI.skin.button)
            {
                alignment = TextAnchor.MiddleLeft,
                padding = new RectOffset(8, 8, 6, 6),
                margin = new RectOffset(0, 0, 1, 1),
                richText = true,
                fixedHeight = 36,
                wordWrap = true  // [Fix 5] 允许文字换行
            };

            if (isSelected)
            {
                var bgTex = new Texture2D(1, 1);
                bgTex.SetPixel(0, 0, new Color(0.2f, 0.5f, 0.8f, 0.25f));
                bgTex.Apply();
                style.normal.background = bgTex;
                style.hover.background = bgTex;
                style.normal.textColor = Color.cyan;
                style.hover.textColor = Color.cyan;
            }

            return style;
        }

        private void DrawRightPanel()
        {
            EditorGUILayout.BeginVertical();
            _scrollPosRight = EditorGUILayout.BeginScrollView(_scrollPosRight);

            if (_selectedEventType != null)
            {
                var info = _eventInfoCache[_selectedEventType];
                var stats = _eventStats[_selectedEventType];

                DrawHeader(info);
                DrawManualTriggerCard(_selectedEventType);
                DrawSubscribersCard(_selectedEventType, stats); // 现在能正确显示了
            }
            else
            {
                GUILayout.Label("Select an event to inspect", EditorStyles.centeredGreyMiniLabel);
            }

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        
        private void DrawHeader(EventDebugInfo info)
        {
            EditorGUILayout.LabelField(info.FullName, EditorStyles.boldLabel);
            EditorGUILayout.LabelField(info.Namespace, EditorStyles.miniLabel);
            EditorGUILayout.Space();
        }

        private void DrawTag(string text, Color color)
        {
            var bgColor = GUI.color;
            GUI.color = color;
            GUILayout.Label(text, EditorStyles.miniButton, GUILayout.Width(70));
            GUI.color = bgColor;
        }

        private void DrawMetadataCard(EventDebugInfo info)
        {
            EditorGUILayout.BeginVertical(Styles.Card);
            EditorGUILayout.LabelField("Metadata", EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Namespace:", GUILayout.Width(90));
            EditorGUILayout.SelectableLabel(info.Namespace, EditorStyles.textField, GUILayout.Height(16));
            EditorGUILayout.EndHorizontal();
            if (info.BaseType != null && info.BaseType != typeof(ValueType))
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Base Type:", GUILayout.Width(90));
                EditorGUILayout.LabelField(info.BaseType.Name, EditorStyles.miniLabel);
                EditorGUILayout.EndHorizontal();
            }
            if (info.Interfaces.Any())
            {
                EditorGUILayout.Space(2);
                EditorGUILayout.LabelField("Interfaces:", EditorStyles.miniLabel);
                foreach (var iface in info.Interfaces.Take(3))
                {
                    EditorGUILayout.LabelField($"  • {iface}", EditorStyles.miniLabel);
                }
                if (info.Interfaces.Count > 3)
                {
                    EditorGUILayout.LabelField($"  ... and {info.Interfaces.Count - 3} more", EditorStyles.miniLabel);
                }
            }
            if (info.Fields.Any())
            {
                EditorGUILayout.Space(2);
                EditorGUILayout.LabelField($"Fields ({info.Fields.Count}):", EditorStyles.miniLabel);
                foreach (var field in info.Fields.Take(5))
                {
                    EditorGUILayout.LabelField($"  • <b>{field.Name}</b>: {field.FieldType.Name}",
                        Styles.RichTextMiniLabel);
                }
                if (info.Fields.Count > 5)
                {
                    EditorGUILayout.LabelField($"  ... and {info.Fields.Count - 5} more", EditorStyles.miniLabel);
                }
            }
            EditorGUILayout.EndVertical();
            EditorGUILayout.Space(5);
        }

        private void DrawStatsCard(EventStats stats)
        {
            EditorGUILayout.BeginVertical(Styles.Card);
            EditorGUILayout.LabelField("Runtime Statistics", EditorStyles.boldLabel);
            EditorGUI.BeginDisabledGroup(!Application.isPlaying);
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Total Publishes:", GUILayout.Width(120));
            EditorGUILayout.LabelField(stats.PublishCount.ToString("N0"), Styles.BoldValue);
            EditorGUILayout.EndHorizontal();
            if (stats.LastPublishTime > 0)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Last Publish:", GUILayout.Width(120));
                double timeSinceLast = EditorApplication.timeSinceStartup - stats.LastPublishTime;
                EditorGUILayout.LabelField($"{timeSinceLast:F2}s ago", Styles.BoldValue);
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Subscribers:", GUILayout.Width(120));
            GUI.color = stats.SubscriberCount > 0 ? Color.green : Color.gray;
            EditorGUILayout.LabelField(stats.SubscriberCount.ToString(), Styles.BoldValue);
            GUI.color = Color.white;
            EditorGUILayout.EndHorizontal();
            EditorGUI.EndDisabledGroup();
            if (!Application.isPlaying)
            {
                EditorGUILayout.HelpBox("Statistics available only in Play mode.", MessageType.Info);
            }
            EditorGUILayout.EndVertical();
            EditorGUILayout.Space(5);
        }

        private void DrawSubscribersCard(Type eventType, EventStats stats)
        {
            EditorGUILayout.LabelField("Active Subscribers", EditorStyles.boldLabel);
            
            if (!Application.isPlaying)
            {
                EditorGUILayout.HelpBox("Subscribers only visible in Play Mode.", MessageType.Info);
                return;
            }

            var subscribers = GetSubscribers(eventType);
            if (subscribers.Count == 0)
            {
                EditorGUILayout.LabelField("No active subscribers.", EditorStyles.miniLabel);
            }
            else
            {
                for (int i = 0; i < subscribers.Count; i++)
                {
                    var sub = subscribers[i];
                    EditorGUILayout.BeginHorizontal("box");
                    // 尝试识别 Unity Object
                    if (sub is UnityEngine.Object obj)
                    {
                        EditorGUILayout.ObjectField(obj, typeof(UnityEngine.Object), true);
                    }
                    else
                    {
                        EditorGUILayout.LabelField(sub.GetType().Name);
                        EditorGUILayout.LabelField(sub.ToString(), EditorStyles.miniLabel);
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }
            EditorGUILayout.Space();
        }

        private void DrawSubscriberItem(object handler, int index)
        {
            EditorGUILayout.BeginVertical(Styles.SubscriberItem);
            if (handler == null)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label(EditorGUIUtility.IconContent("console.erroricon"), GUILayout.Width(20));
                EditorGUILayout.LabelField($"Handler #{index}: <Destroyed/Null>", Styles.ErrorLabel);
                EditorGUILayout.EndHorizontal();
            }
            else if (handler is UnityEngine.Object unityObj)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.ObjectField(unityObj, unityObj.GetType(), true, GUILayout.Height(20));
                if (unityObj is Component comp && comp.gameObject != null)
                {
                    string path = GetGameObjectPath(comp.gameObject);
                    GUI.contentColor = new Color(0.7f, 0.7f, 0.7f);
                    EditorGUILayout.LabelField(path, Styles.MiniLabel, GUILayout.MaxWidth(200));
                    GUI.contentColor = Color.white;
                }
                EditorGUILayout.EndHorizontal();
            }
            else
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Label(EditorGUIUtility.IconContent("cs Script Icon"), GUILayout.Width(20));
                EditorGUILayout.LabelField(handler.GetType().Name, Styles.NormalLabel);
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.LabelField(handler.ToString(), Styles.MiniLabel);
            }
            EditorGUILayout.EndVertical();
        }

        private void DrawManualTriggerCard(Type eventType)
        {
            EditorGUILayout.LabelField("Manual Trigger", EditorStyles.boldLabel);
            
            EnsureParamInstance(eventType);
            object instance = _paramInstances[eventType];
            
            if (instance == null) return;

            // 绘制字段编辑器
            foreach (var field in _fieldInfoCache[eventType])
            {
                DrawEnhancedField(field, instance); // 复用之前的 UI 逻辑
            }

            if (GUILayout.Button("Publish Event"))
            {
                // 使用兼容层触发
                PublishEvent(eventType, instance);
            }
        }

        private void DrawEmptyState()
        {
            GUILayout.FlexibleSpace();
            EditorGUILayout.BeginVertical();
            GUILayout.FlexibleSpace();
            var icon = EditorGUIUtility.IconContent("d_EventSystem Icon");
            icon.text = "\nSelect an event from the list to inspect";
            var style = new GUIStyle(EditorStyles.label)
            {
                alignment = TextAnchor.MiddleCenter,
                fontSize = 14,
                richText = true
            };
            GUILayout.Label(icon, style, GUILayout.ExpandWidth(true));
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }

        // ==================================================================================
        // 核心反射逻辑
        // ==================================================================================

        private Type GetBucketType(Type eventType)
        {
            Type genericBucket = typeof(AsakiBroker).GetNestedType("EventBucket`1",
                BindingFlags.NonPublic | BindingFlags.Static);
            return genericBucket?.MakeGenericType(eventType);
        }

        private int GetSubscriberCount(Type eventType)
        {
            if (!Application.isPlaying) return 0;
            
            // 1. 获取 Bus 实例
            if (!AsakiContext.TryGet<IAsakiEventService>(out var busInterface)) return 0;
            if (!(busInterface is AsakiEventService bus)) return 0;

            // 2. 反射获取 _buckets 字典
            if (_busBucketsField == null) return 0;
            var buckets = _busBucketsField.GetValue(bus) as IDictionary; // Dictionary<Type, IEventBucket>
            if (buckets == null || !buckets.Contains(eventType)) return 0;

            // 3. 获取 Bucket 实例
            var bucket = buckets[eventType];
            if (bucket == null) return 0;

            // 4. 反射获取 _handlers 列表
            // 注意：bucket 是泛型类 AsakiEventService.EventBucket<T>
            var bucketType = bucket.GetType();
            var handlersField = bucketType.GetField("_handlers", BindingFlags.NonPublic | BindingFlags.Instance);
            if (handlersField == null) return 0;

            var list = handlersField.GetValue(bucket) as IList;
            return list?.Count ?? 0;
        }

        private List<object> GetSubscribers(Type eventType)
        {
            if (!Application.isPlaying) return new List<object>();

            if (!AsakiContext.TryGet<IAsakiEventService>(out var busInterface)) return new List<object>();
            if (!(busInterface is AsakiEventService bus)) return new List<object>();

            if (_busBucketsField == null) return new List<object>();
            var buckets = _busBucketsField.GetValue(bus) as IDictionary;
            if (buckets == null || !buckets.Contains(eventType)) return new List<object>();

            var bucket = buckets[eventType];
            var bucketType = bucket.GetType();
            var handlersField = bucketType.GetField("_handlers", BindingFlags.NonPublic | BindingFlags.Instance);
            
            var list = handlersField?.GetValue(bucket) as IEnumerable;
            return list?.Cast<object>().ToList() ?? new List<object>();
        }

        private void PublishEvent(Type eventType, object data)
        {
            // 使用 AsakiBroker.Publish 泛型方法 (它会自动转发给 Context.Bus)
            var method = typeof(AsakiBroker).GetMethod("Publish", BindingFlags.Public | BindingFlags.Static);
            if (method != null)
            {
                var generic = method.MakeGenericMethod(eventType);
                generic.Invoke(null, new[] { data });
            }

            // Debug Log
            Debug.Log($"[Debugger] Published {eventType.Name}");
        }


        private void EnsureParamInstance(Type type)
        {
            if (!_paramInstances.ContainsKey(type) || _paramInstances[type] == null)
            {
                try { _paramInstances[type] = Activator.CreateInstance(type); }
                catch { _paramInstances[type] = null; }
            }
        }

        private string GetGameObjectPath(GameObject go)
        {
            string path = go.name;
            Transform parent = go.transform.parent;
            while (parent != null)
            {
                path = $"{parent.name}/{path}";
                parent = parent.parent;
            }
            return path;
        }

        private void DrawEnhancedField(FieldInfo field, object instance)
        {
            object value = field.GetValue(instance);
            string name = ObjectNames.NicifyVariableName(field.Name);
            Type t = field.FieldType;

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField(name, GUILayout.Width(150));

            try
            {
                if (t == typeof(int)) field.SetValue(instance, EditorGUILayout.IntField((int)value));
                else if (t == typeof(float)) field.SetValue(instance, EditorGUILayout.FloatField((float)value));
                else if (t == typeof(double)) field.SetValue(instance, EditorGUILayout.DoubleField((double)value));
                else if (t == typeof(string)) field.SetValue(instance, EditorGUILayout.TextField((string)(value ?? "")));
                else if (t == typeof(bool)) field.SetValue(instance, EditorGUILayout.Toggle((bool)value));
                else if (t == typeof(Vector3)) field.SetValue(instance, EditorGUILayout.Vector3Field("", (Vector3)value));
                else if (t == typeof(Vector2)) field.SetValue(instance, EditorGUILayout.Vector2Field("", (Vector2)value));
                else if (t == typeof(Vector4)) field.SetValue(instance, EditorGUILayout.Vector4Field("", (Vector4)value));
                else if (t == typeof(Color)) field.SetValue(instance, EditorGUILayout.ColorField((Color)value));
                else if (t == typeof(AnimationCurve)) field.SetValue(instance, EditorGUILayout.CurveField((AnimationCurve)value));
                else if (t == typeof(LayerMask)) field.SetValue(instance, (LayerMask)EditorGUILayout.LayerField((LayerMask)value));
                else if (t.IsEnum) field.SetValue(instance, EditorGUILayout.EnumPopup((Enum)value));
                else if (t.IsArray || (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(List<>)))
                {
                    EditorGUILayout.LabelField($"({t.Name}) Use code to set", EditorStyles.miniLabel);
                }
                else if (t.IsValueType && !t.IsPrimitive)
                {
                    EditorGUILayout.LabelField($"Nested: {t.Name}", EditorStyles.miniLabel);
                }
                else
                {
                    GUI.enabled = false;
                    EditorGUILayout.LabelField($"({t.Name}) Unsupported", EditorStyles.miniLabel);
                    GUI.enabled = true;
                }
            }
            catch (Exception ex)
            {
                EditorGUILayout.LabelField($"Error: {ex.Message}", Styles.ErrorLabel);
            }

            EditorGUILayout.EndHorizontal();
        }

        private void DrawSeparator()
        {
            GUILayout.Box("", GUILayout.ExpandWidth(true), GUILayout.Height(1));
        }

        // ==================================================================================
        // 样式定义
        // ==================================================================================
        private static class Styles
        {
            public static GUIStyle Card;
            public static GUIStyle BigTitle;
            public static GUIStyle BoldValue;
            public static GUIStyle NormalLabel;
            public static GUIStyle BoldLabel;
            public static GUIStyle MiniLabel;
            public static GUIStyle RichTextMiniLabel;
            public static GUIStyle ErrorLabel;
            public static GUIStyle SubscriberItem;
            public static GUIStyle Description;
            public static GUIStyle RightAlignedLabel;

            static Styles()
            {
                Card = new GUIStyle(GUI.skin.box)
                {
                    padding = new RectOffset(12, 12, 12, 12),
                    margin = new RectOffset(0, 0, 6, 6)
                };

                BigTitle = new GUIStyle(EditorStyles.boldLabel)
                {
                    fontSize = 16,
                    fixedHeight = 24,
                    richText = true
                };

                BoldValue = new GUIStyle(EditorStyles.boldLabel)
                {
                    alignment = TextAnchor.MiddleRight,
                    richText = true
                };

                NormalLabel = new GUIStyle(EditorStyles.label) { richText = true };
                BoldLabel = new GUIStyle(EditorStyles.boldLabel) { richText = true };
                MiniLabel = new GUIStyle(EditorStyles.miniLabel) { richText = true };
                
                RichTextMiniLabel = new GUIStyle(EditorStyles.miniLabel)
                {
                    richText = true,
                    wordWrap = false
                };

                ErrorLabel = new GUIStyle(EditorStyles.miniLabel)
                {
                    normal = { textColor = Color.red },
                    richText = true
                };

                SubscriberItem = new GUIStyle(GUI.skin.box)
                {
                    margin = new RectOffset(0, 0, 2, 2),
                    padding = new RectOffset(8, 8, 6, 6)
                };

                Description = new GUIStyle(EditorStyles.wordWrappedLabel)
                {
                    fontStyle = FontStyle.Italic,
                    normal = { textColor = new Color(0.7f, 0.7f, 0.7f) },
                    richText = true
                };

                RightAlignedLabel = new GUIStyle(EditorStyles.label)
                {
                    alignment = TextAnchor.MiddleRight,
                    richText = true
                };
            }
        }
    }
}```

<!-- File: Asaki/Editor/Debugging/AsakiResDebuggerWindow.cs -->
<!-- GUID: 32f180138c614648bc7244f729653829 -->
<!-- Size: 28302 bytes -->
<!-- Modified: 2025-12-22 16:45:50 -->
```csharp
using Asaki.Core.Resources;
using Asaki.Editor.Utilities.Extensions;
using Asaki.Unity;
using Asaki.Unity.Services.Resources;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Editor.Debugging
{
    public class AsakiResDebuggerWindow : EditorWindow
    {
        // ==================== 反射字段缓存 ====================
        private FieldInfo cacheField;
        private FieldInfo lockField;
        private FieldInfo strategyField;
        private FieldInfo locationField;
        private FieldInfo assetField;
        private FieldInfo refCountField;
        private FieldInfo dependencyLocationsField;
        private FieldInfo loadingTcsField;
        private FieldInfo progressCallbacksField;
        private PropertyInfo taskProperty;
        private PropertyInfo strategyNameProperty;

        // AsakiContext 反射相关
        private Type asakiContextType;
        private MethodInfo getServiceMethod;
        
        // ==================== 窗口状态 ====================
        private IAsakiResService targetService;
        private Vector2 leftScrollPos;
        private Vector2 rightScrollPos;
        private string selectedLocation;
        private float splitterPos = 300f;
        private bool isReflectionInitialized = false;
        private double lastRefreshTime;
        private const float AUTO_REFRESH_INTERVAL = 1f;

        // 自动获取服务状态
        private bool isAutoFetching = true;
        private string fetchStatusMessage = "等待获取服务...";
        private MessageType fetchStatusType = MessageType.Info;

        // ==================== 尺寸限制 ====================
        private const float MIN_LEFT_WIDTH = 200f;
        private const float MIN_RIGHT_WIDTH = 300f;

        [MenuItem("Asaki/Debugger/Resources Debugger")]
        public static void ShowWindow()
        {
            var window = GetWindow<AsakiResDebuggerWindow>("Resources Debugger");
            window.minSize = new Vector2(700, 500);
            window.Show();
        }

        void OnEnable()
        {
            InitializeReflection();
            EditorApplication.update += OnEditorUpdate;
            isAutoFetching = true;
            fetchStatusMessage = "正在尝试从 AsakiContext 获取服务...";
        }

        void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }

        void OnEditorUpdate()
        {
            double currentTime = EditorApplication.timeSinceStartup;
            
            // 每1秒尝试获取一次服务
            if (isAutoFetching && currentTime - lastRefreshTime > AUTO_REFRESH_INTERVAL)
            {
                TryFetchServiceFromContext();
                lastRefreshTime = currentTime;
            }
            
            // 每秒刷新UI
            if (currentTime - lastRefreshTime > AUTO_REFRESH_INTERVAL * 0.5f)
            {
                Repaint();
            }
        }

        void InitializeReflection()
        {
            try
            {
                // 初始化 AsakiContext 反射
                InitializeContextReflection();
                
                // 初始化 AsakiResService 反射
                InitializeServiceReflection();

                isReflectionInitialized = true;
            }
            catch (Exception ex)
            {
                Debug.LogError($"反射初始化失败: {ex.Message}\n{ex.StackTrace}");
                fetchStatusMessage = $"反射初始化失败: {ex.Message}";
                fetchStatusType = MessageType.Error;
                isAutoFetching = false;
                isReflectionInitialized = false;
            }
        }

        void InitializeContextReflection()
        {
            // 尝试多种方式查找AsakiContext类型
            string[] possibleTypeNames = new[]
            {
                "Asaki.Core.AsakiContext, Asaki.Core",
                "Asaki.Core.AsakiContext",
                "AsakiContext, Asaki.Core",
                "AsakiContext"
            };

            foreach (var typeName in possibleTypeNames)
            {
                asakiContextType = Type.GetType(typeName);
                if (asakiContextType != null) break;
            }

            // 如果还找不到，扫描所有程序集
            if (asakiContextType == null)
            {
                foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
                {
                    var types = assembly.GetTypes().Where(t => t.Name == "AsakiContext" && t.IsClass && t.IsPublic);
                    if (types.Any())
                    {
                        asakiContextType = types.First();
                        break;
                    }
                }
            }

            if (asakiContextType == null)
            {
                throw new Exception("无法在任何程序集中找到 AsakiContext 类型。请确保包含 Asaki.Core 命名空间。");
            }

            // 获取 Get<T> 方法
            var genericGetMethod = asakiContextType.GetMethod("Get", BindingFlags.Public | BindingFlags.Static);
            if (genericGetMethod == null)
            {
                throw new Exception($"AsakiContext 中未找到 Get<T> 方法。");
            }

            getServiceMethod = genericGetMethod.MakeGenericMethod(typeof(IAsakiResService));
        }

        void InitializeServiceReflection()
        {
            var serviceType = typeof(AsakiResService);

            // 获取私有字段
            cacheField = serviceType.GetField("_cache", BindingFlags.NonPublic | BindingFlags.Instance);
            lockField = serviceType.GetField("_lock", BindingFlags.NonPublic | BindingFlags.Instance);
            strategyField = serviceType.GetField("_strategy", BindingFlags.NonPublic | BindingFlags.Instance);

            if (cacheField == null)
            {
                throw new Exception("未找到 '_cache' 字段。请检查 AsakiResService 定义。");
            }

            // 获取ResRecord嵌套类型
            var recordType = serviceType.GetNestedType("ResRecord", BindingFlags.NonPublic);
            if (recordType == null)
            {
                throw new Exception("未找到 ResRecord 嵌套类型。");
            }

            // 获取记录字段
            locationField = recordType.GetField("Location");
            assetField = recordType.GetField("Asset");
            refCountField = recordType.GetField("RefCount");
            dependencyLocationsField = recordType.GetField("DependencyLocations");
            loadingTcsField = recordType.GetField("LoadingTcs");
            progressCallbacksField = recordType.GetField("ProgressCallbacks");

            // 获取Task属性
            var tcsType = loadingTcsField.FieldType;
            taskProperty = tcsType.GetProperty("Task");

            // 获取策略名称属性
            if (strategyField != null)
            {
                var strategyType = strategyField.FieldType;
                strategyNameProperty = strategyType.GetProperty("StrategyName");
            }
        }

        void OnGUI()
        {
            if (!isReflectionInitialized)
            {
                EditorGUILayout.HelpBox("反射初始化失败！", MessageType.Error);
                return;
            }

            DrawToolbar();

            if (targetService == null)
            {
                DrawServiceSelector();
            }
            else
            {
                DrawSplitterLayout();
            }
        }

        void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

            if (GUILayout.Button("Refresh", EditorStyles.toolbarButton, GUILayout.Width(60)))
            {
                Repaint();
            }

            if (targetService != null && GUILayout.Button("Clear Selection", EditorStyles.toolbarButton, GUILayout.Width(90)))
            {
                selectedLocation = null;
            }

            if (targetService != null)
            {
                GUILayout.Label($"<color=green>{GetStrategyName()}</color>", EditorStyles.toolbarButton);
            }

            GUILayout.FlexibleSpace();

            // 停止/开始自动获取按钮
            if (GUILayout.Button(isAutoFetching ? "Stop Auto Fetch" : "Start Auto Fetch", 
                EditorStyles.toolbarButton, GUILayout.Width(120)))
            {
                isAutoFetching = !isAutoFetching;
                if (isAutoFetching)
                {
                    fetchStatusMessage = "正在尝试从 AsakiContext 获取服务...";
                    fetchStatusType = MessageType.Info;
                }
            }

            if (targetService != null && GUILayout.Button("Release All", EditorStyles.toolbarButton, GUILayout.Width(80)))
            {
                var cache = GetCacheDictionary();
                if (EditorUtility.DisplayDialog("Release All Resources", 
                    $"释放所有 {cache?.Count ?? 0} 个资源？", "Yes", "No"))
                {
                    ReleaseAllResources();
                }
            }

            EditorGUILayout.EndHorizontal();
        }

        void DrawServiceSelector()
        {
            EditorGUILayout.BeginVertical();
            GUILayout.FlexibleSpace();
            
            if (isAutoFetching)
            {
                EditorGUILayout.HelpBox(fetchStatusMessage, fetchStatusType);
            }
            else
            {
                EditorGUILayout.HelpBox("无法自动从 AsakiContext 获取服务。\n\n" +
                                       "可能的原因：\n" +
                                       "1. AsakiContext 未初始化\n" +
                                       "2. IAsakiResService 未注册到上下文\n" +
                                       "3. 命名空间或程序集名称不匹配\n\n" +
                                       "临时方案：手动拖拽服务实例到下方字段", MessageType.Warning);
            }

            // 备用手动赋值方案
            EditorGUILayout.Space();
            var obj = EditorGUILayout.ObjectField("手动指定服务", null, typeof(Object), true);
            if (obj != null)
            {
                if (obj is IAsakiResService service && service.GetType() == typeof(AsakiResService))
                {
                    targetService = service;
                    isAutoFetching = false;
                    selectedLocation = null;
                }
                else if (obj is IAsakiResService)
                {
                    EditorUtility.DisplayDialog("类型错误", 
                        $"服务类型不匹配: {obj.GetType().Name}\n需要: AsakiResService", "确定");
                }
                else
                {
                    EditorUtility.DisplayDialog("类型错误", 
                        "对象未实现 IAsakiResService 接口", "确定");
                }
            }

            if (!isAutoFetching && GUILayout.Button("重试自动获取"))
            {
                isAutoFetching = true;
                fetchStatusMessage = "正在尝试从 AsakiContext 获取服务...";
            }

            GUILayout.FlexibleSpace();
            EditorGUILayout.EndVertical();
        }

        void TryFetchServiceFromContext()
        {
            if (getServiceMethod == null)
            {
                fetchStatusMessage = "AsakiContext.Get<T> 方法未找到";
                fetchStatusType = MessageType.Error;
                isAutoFetching = false;
                return;
            }

            try
            {
                object result = getServiceMethod.Invoke(null, null);
                if (result is IAsakiResService service && service.GetType() == typeof(AsakiResService))
                {
                    targetService = service;
                    fetchStatusMessage = "✓ 服务获取成功";
                    fetchStatusType = MessageType.Info;
                    isAutoFetching = false;
                }
                else if (result != null)
                {
                    fetchStatusMessage = $"服务类型不匹配: {result.GetType().Name}";
                    fetchStatusType = MessageType.Warning;
                }
            }
            catch (TargetInvocationException targetEx)
            {
                var innerEx = targetEx.InnerException;
                fetchStatusMessage = $"获取失败: {innerEx?.Message ?? targetEx.Message}";
                fetchStatusType = MessageType.Error;
            }
            catch (Exception ex)
            {
                fetchStatusMessage = $"获取异常: {ex.Message}";
                fetchStatusType = MessageType.Error;
                isAutoFetching = false;
            }
        }

        void DrawSplitterLayout()
        {
            EditorGUILayout.BeginHorizontal();

            // 左侧面板
            GUILayout.BeginVertical(GUILayout.Width(splitterPos));
            DrawLeftPanel();
            GUILayout.EndVertical();

            // 使用分隔条
            GUILayoutExtensions.Splitter(ref splitterPos, MIN_LEFT_WIDTH, position.width - MIN_RIGHT_WIDTH);

            // 右侧面板
            GUILayout.BeginVertical();
            DrawRightPanel();
            GUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();
        }

        void DrawLeftPanel()
        {
            EditorGUILayout.LabelField("Loaded Resources", EditorStyles.boldLabel);

            leftScrollPos = EditorGUILayout.BeginScrollView(leftScrollPos);

            try
            {
                var cache = GetCacheDictionary();
                if (cache != null && cache.Count > 0)
                {
                    // 正确遍历非泛型IDictionary
                    var entries = new List<DictionaryEntry>();
                    foreach (DictionaryEntry entry in cache)
                    {
                        entries.Add(entry);
                    }

                    // 按引用计数排序
                    foreach (var entry in entries.OrderByDescending(e => GetRefCount(e.Value)))
                    {
                        DrawResourceButton((string)entry.Key, entry.Value);
                    }
                }
                else
                {
                    EditorGUILayout.HelpBox("No resources loaded.", MessageType.Info);
                }
            }
            catch (Exception ex)
            {
                EditorGUILayout.HelpBox($"渲染资源列表失败: {ex.Message}", MessageType.Error);
            }

            EditorGUILayout.EndScrollView();
        }

        void DrawResourceButton(string location, object record)
        {
            var refCount = (int)refCountField.GetValue(record);
            var asset = assetField.GetValue(record) as Object;

            // 创建按钮内容
            GUIContent content = new GUIContent
            {
                text = $"{location} [{refCount}]",
                tooltip = asset != null ? asset.GetType().Name : "Loading..."
            };

            // 根据状态设置样式
            GUIStyle style = selectedLocation == location ? EditorStyles.boldLabel : EditorStyles.label;
            Color originalColor = GUI.color;

            // 状态颜色
            if (asset == null)
            {
                GUI.color = Color.yellow; // 加载中
            }
            else if (refCount == 0)
            {
                GUI.color = Color.gray; // 待释放
            }

            if (GUILayout.Button(content, style, GUILayout.ExpandWidth(true)))
            {
                selectedLocation = location;
            }

            GUI.color = originalColor;
        }

        void DrawRightPanel()
        {
            if (string.IsNullOrEmpty(selectedLocation))
            {
                EditorGUILayout.HelpBox("Select a resource from the left panel to view details.", MessageType.Info);
                return;
            }

            rightScrollPos = EditorGUILayout.BeginScrollView(rightScrollPos);

            try
            {
                var cache = GetCacheDictionary();
                if (cache != null)
                {
                    // 查找选中的记录
                    foreach (DictionaryEntry entry in cache)
                    {
                        if ((string)entry.Key == selectedLocation)
                        {
                            DrawRecordDetails(entry.Value);
                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                EditorGUILayout.HelpBox($"渲染资源详情失败: {ex.Message}", MessageType.Error);
            }

            EditorGUILayout.EndScrollView();
        }

        void DrawRecordDetails(object record)
        {
            DrawBasicInfo(record);
            DrawDependencies(record);
            DrawProgressCallbacks(record);
            DrawLoadingStatus(record);
            DrawActionButtons(record);
        }

        void DrawBasicInfo(object record)
        {
            EditorGUILayout.LabelField("Resource Details", EditorStyles.boldLabel);
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);

            var location = locationField.GetValue(record) as string;
            EditorGUILayout.LabelField("Location", location ?? "Null");

            var asset = assetField.GetValue(record) as Object;
            EditorGUILayout.ObjectField("Asset", asset, typeof(Object), false);

            if (asset != null)
            {
                EditorGUILayout.LabelField("Type", asset.GetType().Name);
                
                // 显示资源路径
                var path = AssetDatabase.GetAssetPath(asset);
                if (!string.IsNullOrEmpty(path))
                {
                    EditorGUILayout.LabelField("Asset Path", path);
                }
            }

            var refCount = (int)refCountField.GetValue(record);
            EditorGUILayout.LabelField("Reference Count", refCount.ToString());

            // 策略信息
            string strategyName = GetStrategyName();
            if (!string.IsNullOrEmpty(strategyName))
            {
                EditorGUILayout.LabelField("Strategy", strategyName);
            }

            EditorGUILayout.EndVertical();
        }

        void DrawDependencies(object record)
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Dependencies", EditorStyles.boldLabel);

            var dependencies = dependencyLocationsField.GetValue(record) as IEnumerable;
            if (dependencies != null)
            {
                EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                
                bool hasDeps = false;
                foreach (var dep in dependencies)
                {
                    if (dep is string depStr)
                    {
                        hasDeps = true;
                        GUIStyle buttonStyle = new GUIStyle(EditorStyles.label);
                        buttonStyle.normal.textColor = Color.cyan;
                    
                        if (GUILayout.Button($"• {depStr}", buttonStyle))
                        {
                            selectedLocation = depStr;
                        }
                    }
                }

                if (!hasDeps)
                {
                    EditorGUILayout.LabelField("No dependencies");
                }
                
                EditorGUILayout.EndVertical();
            }
            else
            {
                EditorGUILayout.HelpBox("No dependencies", MessageType.Info);
            }
        }

        void DrawProgressCallbacks(object record)
        {
            var progressCallbacks = progressCallbacksField.GetValue(record) as Action<float>;
            if (progressCallbacks != null)
            {
                var invocationList = progressCallbacks.GetInvocationList();
                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Progress Callbacks", $"{invocationList.Length} subscriber(s)");
            
                if (invocationList.Length > 0)
                {
                    EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                    foreach (var callback in invocationList)
                    {
                        string targetName = callback.Target?.ToString() ?? "Null";
                        if (targetName.Length > 50) targetName = targetName.Substring(0, 50) + "...";
                        
                        string methodName = callback.Method.Name;
                        EditorGUILayout.LabelField($"• {targetName}.{methodName}");
                    }
                    EditorGUILayout.EndVertical();
                }
            }
        }

        void DrawLoadingStatus(object record)
        {
            var loadingTcs = loadingTcsField.GetValue(record);
            if (loadingTcs != null && taskProperty != null)
            {
                var task = taskProperty.GetValue(loadingTcs) as Task;
                if (task != null)
                {
                    EditorGUILayout.Space();
                    EditorGUILayout.LabelField("Loading Status", EditorStyles.boldLabel);
                    EditorGUILayout.BeginVertical(EditorStyles.helpBox);
                
                    EditorGUILayout.LabelField("Status", task.Status.ToString());
                
                    if (task.IsFaulted)
                    {
                        var errorMsg = task.Exception?.InnerException?.Message ?? task.Exception?.Message ?? "Unknown error";
                        EditorGUILayout.HelpBox($"Error: {errorMsg}", MessageType.Error);
                    }
                    else if (task.IsCanceled)
                    {
                        EditorGUILayout.HelpBox("Loading was canceled.", MessageType.Warning);
                    }
                    else if (task.IsCompletedSuccessfully)
                    {
                        EditorGUILayout.HelpBox("Loading completed successfully.", MessageType.Info);
                    }
                
                    EditorGUILayout.EndVertical();
                }
            }
        }

        void DrawActionButtons(object record)
        {
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();

            if (GUILayout.Button("Release This", GUILayout.Height(30)))
            {
                if (EditorUtility.DisplayDialog("Release Resource", $"Release '{selectedLocation}'?", "Yes", "No"))
                {
                    targetService.Release(selectedLocation);
                    selectedLocation = null;
                }
            }

            GUI.backgroundColor = Color.red;
            if (GUILayout.Button("Force Unload", GUILayout.Height(30)))
            {
                if (EditorUtility.DisplayDialog("Force Unload", 
                    $"Force unload '{selectedLocation}'? This bypasses reference counting and may cause issues!", "Yes", "Cancel"))
                {
                    ForceUnloadResource(record);
                }
            }
            GUI.backgroundColor = Color.white;

            EditorGUILayout.EndHorizontal();
        }

        void ForceUnloadResource(object record)
        {
            var asset = assetField.GetValue(record) as Object;
            var location = locationField.GetValue(record) as string;

            if (asset == null)
            {
                EditorUtility.DisplayDialog("Force Unload", "Asset is null, cannot unload.", "OK");
                return;
            }

            var strategy = strategyField?.GetValue(targetService);
            if (strategy == null)
            {
                EditorUtility.DisplayDialog("Error", "Strategy is null.", "OK");
                return;
            }

            var unloadMethod = strategy.GetType().GetMethod("UnloadAssetInternal");
            if (unloadMethod != null)
            {
                try
                {
                    unloadMethod.Invoke(strategy, new object[] { location, asset });
                    Debug.Log($"[AsakiResDebugger] Force unloaded: {location}");
                    Repaint();
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[AsakiResDebugger] Force unload failed: {ex.Message}");
                    EditorUtility.DisplayDialog("Error", $"Force unload failed: {ex.Message}", "OK");
                }
            }
            else
            {
                EditorUtility.DisplayDialog("Error", "未找到 UnloadAssetInternal 方法", "OK");
            }
        }

        void ReleaseAllResources()
        {
            var cache = GetCacheDictionary();
            if (cache != null && cache.Count > 0)
            {
                int count = cache.Count;
                var locations = new List<string>();
                foreach (DictionaryEntry entry in cache)
                {
                    locations.Add((string)entry.Key);
                }
                
                foreach (var location in locations)
                {
                    targetService.Release(location);
                }
                Debug.Log($"[AsakiResDebugger] Released all {count} resources.");
                selectedLocation = null;
                Repaint();
            }
        }

        string GetStrategyName()
        {
            if (strategyField == null || targetService == null) return "Unknown";
        
            try
            {
                var strategy = strategyField.GetValue(targetService);
                return strategyNameProperty?.GetValue(strategy) as string ?? "Unknown Strategy";
            }
            catch
            {
                return "Unknown";
            }
        }

        // 关键修复：返回 IDictionary 而不是 Dictionary<string, object>
        IDictionary GetCacheDictionary()
        {
            if (targetService == null) return null;

            object lockObj = GetLockObject();
            if (lockObj == null) return null;

            lock (lockObj)
            {
                try
                {
                    var cache = cacheField.GetValue(targetService);
                    return cache as IDictionary;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[AsakiResDebugger] Failed to get cache: {ex.Message}");
                    return null;
                }
            }
        }

        object GetLockObject()
        {
            try
            {
                return lockField?.GetValue(targetService) ?? new object();
            }
            catch
            {
                return new object();
            }
        }

        int GetRefCount(object record)
        {
            try
            {
                return (int)refCountField.GetValue(record);
            }
            catch
            {
                return 0;
            }
        }
    }
}```

<!-- File: Asaki/Editor/Debugging/AsakiSaveInspector.cs -->
<!-- GUID: 17095087d48a4cd3aca2940eda6db656 -->
<!-- Size: 10518 bytes -->
<!-- Modified: 2025-12-22 16:38:00 -->
```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.Debugging
{
    public class AsakiSaveInspector : EditorWindow
    {
        // === UI 成员变量 (直接持有引用，拒绝 Query) ===
        private ListView _slotListView;
        private Label _contentLabel;
        private Label _statusLabel;
        private Label _fileNameLabel;
        private Label _metaLabel;
        private VisualElement _rightPane; // 直接持有右侧面板
        private ToolbarSearchField _searchField;

        // === 数据 ===
        private string _saveRoot;
        // 存储的是目录信息，而非单个文件 - 使用新版本的数据模型
        private List<DirectoryInfo> _slots = new List<DirectoryInfo>();

        [MenuItem("Asaki/Debugger/Save Inspector", false, 100)]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiSaveInspector>();
            wnd.titleContent = new GUIContent("Save Inspector", EditorGUIUtility.IconContent("SaveActive").image);
            wnd.minSize = new Vector2(800, 500);
        }

        public void CreateGUI()
        {
            // 路径适配新的 Slot 结构 - 使用新版本的路径
            _saveRoot = Path.Combine(Application.persistentDataPath, "Saves");

            // 1. 根节点设置：确保填满窗口
            rootVisualElement.style.flexGrow = 1;

            // 2. 分割视图 (SplitView)
            var splitView = new TwoPaneSplitView(0, 250, TwoPaneSplitViewOrientation.Horizontal);
            splitView.style.flexGrow = 1; // 关键：让 SplitView 填满窗口
            rootVisualElement.Add(splitView);

            // =========================================================
            // 左侧栏 (Left Pane)
            // =========================================================
            var leftPane = new VisualElement();
            leftPane.style.minWidth = 200;
            splitView.Add(leftPane); // 第一个添加的是左栏

            // 工具栏
            var toolbar = new Toolbar();
            toolbar.Add(new ToolbarButton(RefreshFileList) { text = "Refresh" });
            toolbar.Add(new ToolbarButton(() => EditorUtility.RevealInFinder(_saveRoot)) { text = "Open Folder" });
            leftPane.Add(toolbar);

            // 搜索框
            _searchField = new ToolbarSearchField();
            _searchField.RegisterValueChangedCallback(evt => FilterSlots(evt.newValue));
            _searchField.style.width = StyleKeyword.Auto;
            leftPane.Add(_searchField);

            // Slot 列表 (ListView) - 保持旧版本的UI风格
            _slotListView = new ListView();
            _slotListView.style.flexGrow = 1; // 关键：让列表填满剩余空间
            _slotListView.makeItem = () => 
            {
                var label = new Label();
                label.style.paddingLeft = 5;
                label.style.paddingTop = 2;
                label.style.paddingBottom = 2;
                label.style.unityTextAlign = TextAnchor.MiddleLeft;
                return label;
            };
            _slotListView.bindItem = (element, index) => 
            { 
                var label = (Label)element;
                label.text = _slots[index].Name;
                // 偶数行稍微变色，增加可读性
                // label.style.backgroundColor = index % 2 == 0 ? new Color(0,0,0,0) : new Color(1,1,1,0.03f);
            };
            _slotListView.selectionType = SelectionType.Single;
            _slotListView.selectionChanged += OnSlotSelected; 
            _slotListView.fixedItemHeight = 20;
            leftPane.Add(_slotListView);

            // 状态栏
            _statusLabel = new Label("Ready");
            _statusLabel.style.fontSize = 10;
            _statusLabel.style.color = Color.gray;
            _statusLabel.style.paddingLeft = 5;
            _statusLabel.style.borderTopWidth = 1;
            _statusLabel.style.borderTopColor = new Color(0.15f, 0.15f, 0.15f);
            leftPane.Add(_statusLabel);

            // =========================================================
            // 右侧栏 (Right Pane)
            // =========================================================
            _rightPane = new VisualElement();
            _rightPane.style.flexGrow = 1;
            _rightPane.style.paddingTop = 10;
            _rightPane.style.paddingLeft = 15;
            _rightPane.style.paddingRight = 5;
            // 使用 Unity 默认背景色，避免太黑
            _rightPane.style.backgroundColor = new Color(0.18f, 0.18f, 0.18f); 
            splitView.Add(_rightPane); // 第二个添加的是右栏

            // 详情头部
            var headerContainer = new VisualElement();
            headerContainer.style.borderBottomWidth = 1;
            headerContainer.style.borderBottomColor = new Color(0.4f, 0.4f, 0.4f);
            headerContainer.style.marginBottom = 10;
            headerContainer.style.paddingBottom = 5;
            _rightPane.Add(headerContainer);

            _fileNameLabel = new Label("No Selection");
            _fileNameLabel.style.fontSize = 18;
            _fileNameLabel.style.unityFontStyleAndWeight = FontStyle.Bold;
            _fileNameLabel.style.color = new Color(0.4f, 0.7f, 1.0f); // Asaki Blue
            headerContainer.Add(_fileNameLabel);

            _metaLabel = new Label("-");
            _metaLabel.style.fontSize = 11;
            _metaLabel.style.color = new Color(0.6f, 0.6f, 0.6f);
            headerContainer.Add(_metaLabel);

            // JSON 内容区域 (ScrollView)
            var scrollView = new ScrollView();
            scrollView.style.flexGrow = 1;
            _rightPane.Add(scrollView);

            _contentLabel = new Label();
            _contentLabel.style.whiteSpace = WhiteSpace.Normal;
            _contentLabel.selection.isSelectable = true; // 允许复制
            // 尝试设置等宽字体 (Consolas / Menlo)
            _contentLabel.style.unityFont = Font.CreateDynamicFontFromOSFont("Consolas", 12);
            if (_contentLabel.style.unityFont.value == null) 
                 _contentLabel.style.unityFont = Font.CreateDynamicFontFromOSFont("Menlo", 12);
            
            _contentLabel.style.color = new Color(0.85f, 0.85f, 0.85f);
            scrollView.Add(_contentLabel);

            // 初始刷新
            RefreshFileList();
        }

        private void RefreshFileList()
        {
            if (!Directory.Exists(_saveRoot))
            {
                _slots.Clear();
                _slotListView.itemsSource = _slots;
                _slotListView.Rebuild();
                _statusLabel.text = "Save folder not found.";
                return;
            }

            // 扫描所有以 Slot_ 开头的文件夹 - 使用新版本的逻辑
            var dir = new DirectoryInfo(_saveRoot);
            _slots = dir.GetDirectories("Slot_*")
                        .OrderByDescending(d => d.LastWriteTime)
                        .ToList();

            _slotListView.itemsSource = _slots;
            _slotListView.Rebuild();
            _statusLabel.text = $"{_slots.Count} save slots found.";

            // 恢复搜索
            if (_searchField != null && !string.IsNullOrEmpty(_searchField.value))
            {
                FilterSlots(_searchField.value);
            }
        }

        private void FilterSlots(string filter)
        {
            if (string.IsNullOrEmpty(filter))
            {
                _slotListView.itemsSource = _slots;
            }
            else
            {
                var filtered = _slots.Where(s => s.Name.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0).ToList();
                _slotListView.itemsSource = filtered;
            }
            _slotListView.Rebuild();
        }

        private void OnSlotSelected(IEnumerable<object> selection)
        {
            var dirInfo = selection.FirstOrDefault() as DirectoryInfo;

            if (dirInfo == null)
            {
                _fileNameLabel.text = "No Selection";
                _metaLabel.text = "-";
                _contentLabel.text = "";
                return;
            }

            // 显示 Slot_X - 使用新版本的显示逻辑
            _fileNameLabel.text = dirInfo.Name;
            
            string metaPath = Path.Combine(dirInfo.FullName, "meta.json");
            string dataPath = Path.Combine(dirInfo.FullName, "data.bin");

            try
            {
                if (File.Exists(metaPath))
                {
                    string json = File.ReadAllText(metaPath);
                    
                    // 保留旧版本的大文件保护逻辑
                    if (json.Length > 100 * 1024) 
                        _contentLabel.text = json.Substring(0, 100 * 1024) + "\n... <File too large> ...";
                    else
                        _contentLabel.text = json;
                    
                    // 组合元数据信息 - 保留旧版本的格式化风格
                    string metaInfo = "";
                    if (File.Exists(dataPath))
                    {
                        var dataFile = new FileInfo(dataPath);
                        metaInfo = $"{FormatSize(dataFile.Length)}  |  ";
                    }
                    metaInfo += $"{dirInfo.LastWriteTime:yyyy-MM-dd HH:mm:ss}";
                    _metaLabel.text = metaInfo;
                }
                else
                {
                    _contentLabel.text = "<Meta file missing>";
                    _metaLabel.text = $"Folder  |  {dirInfo.LastWriteTime:yyyy-MM-dd HH:mm:ss}";
                }
            }
            catch (Exception e)
            {
                _contentLabel.text = $"<Error reading slot>: {e.Message}";
            }
        }

        private string FormatSize(long bytes)
        {
            if (bytes < 1024) return $"{bytes} B";
            if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
            return $"{bytes / (1024.0 * 1024.0):F2} MB";
        }
    }
}```

<!-- File: Asaki/Editor/Debugging/AsakiSmartPoolDebuggerWindow.cs -->
<!-- GUID: b423139499564953b1be15b393dfb948 -->
<!-- Size: 11242 bytes -->
<!-- Modified: 2025-12-23 18:27:03 -->
```csharp
using Asaki.Core.Context;
using Asaki.Core.Pooling; // 引用 V5.1 的对象池命名空间
using Asaki.Editor.Utilities.Extensions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Debugging
{
    public class AsakiSmartPoolDebuggerWindow : EditorWindow
    {
        [MenuItem("Asaki/Debugger/Smart Pool Inspector")]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiSmartPoolDebuggerWindow>();
            wnd.titleContent = new GUIContent("Smart Pool (V5.1)");
            wnd.minSize = new Vector2(600, 400);
            wnd.Show();
        }

        // --- 数据模型 (DTO) ---
        private class PoolViewData
        {
            public string Key;
            public int InactiveCount;
            public GameObject Prefab;
            public bool HasValidHandle;
        }

        // --- 状态 ---
        private List<PoolViewData> _viewData = new List<PoolViewData>();
        private string _searchFilter = "";
        private string _selectedKey;
        private Vector2 _scrollLeft;
        private Vector2 _scrollRight;
        private bool _autoRefresh = true;
        private double _lastRefreshTime;
        private float _splitSize = 250f;

        // --- 样式 ---
        private GUIStyle _itemStyle;

        private void OnEnable()
        {
            EditorApplication.update += OnEditorUpdate;
        }

        private void OnDisable()
        {
            EditorApplication.update -= OnEditorUpdate;
        }

        private void OnEditorUpdate()
        {
            if (Application.isPlaying && _autoRefresh)
            {
                if (EditorApplication.timeSinceStartup - _lastRefreshTime > 0.5f) // 降低刷新频率
                {
                    FetchData();
                    _lastRefreshTime = EditorApplication.timeSinceStartup;
                    Repaint();
                }
            }
        }

        private void OnGUI()
        {
            InitStyles();
            DrawToolbar();

            if (!Application.isPlaying)
            {
                EditorGUILayout.HelpBox("AsakiSmartPool runs in Play Mode.", MessageType.Info);
                return;
            }

            // 检查服务是否就绪
            if (!AsakiContext.TryGet<IAsakiPoolService>(out var service))
            {
                EditorGUILayout.HelpBox("IAsakiPoolService not found in Context.\nMake sure Bootstrapper has started.", MessageType.Warning);
                return;
            }

            EditorGUILayout.BeginHorizontal();

            // 1. 左侧列表
            DrawListPanel();

            // 2. 分隔条
            // 注意：如果你没有 GUILayoutExtensions，可以用简单的 Space 代替
            // GUILayoutExtensions.Splitter(ref _splitSize, 150f, position.width - 200f);
            GUILayout.Box("", GUILayout.Width(1), GUILayout.ExpandHeight(true)); 

            // 3. 右侧详情
            DrawDetailsPanel();

            EditorGUILayout.EndHorizontal();
        }

        private void InitStyles()
        {
            if (_itemStyle == null)
            {
                _itemStyle = new GUIStyle(GUI.skin.button);
                _itemStyle.alignment = TextAnchor.MiddleLeft;
                _itemStyle.padding = new RectOffset(10, 10, 5, 5);
            }
        }

        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            
            if (GUILayout.Button("Release Selected", EditorStyles.toolbarButton, GUILayout.Width(120)))
            {
                if (!string.IsNullOrEmpty(_selectedKey))
                {
                    AsakiSmartPool.ReleasePool(_selectedKey);
                    FetchData();
                }
            }

            GUILayout.Space(10);
            _autoRefresh = GUILayout.Toggle(_autoRefresh, "Auto Refresh", EditorStyles.toolbarButton, GUILayout.Width(90));
            
            GUILayout.FlexibleSpace();
            _searchFilter = EditorGUILayout.TextField(_searchFilter, EditorStyles.toolbarSearchField, GUILayout.Width(200));
            
            EditorGUILayout.EndHorizontal();
        }

        private void DrawListPanel()
        {
            EditorGUILayout.BeginVertical(GUILayout.Width(_splitSize));
            _scrollLeft = EditorGUILayout.BeginScrollView(_scrollLeft);

            if (_viewData != null)
            {
                foreach (var data in _viewData)
                {
                    if (!string.IsNullOrEmpty(_searchFilter) && 
                        !data.Key.IndexOf(_searchFilter, StringComparison.OrdinalIgnoreCase).Equals(-1))
                        continue;

                    bool isSelected = data.Key == _selectedKey;
                    
                    // 显示逻辑
                    string label = $"{data.Key} ({data.InactiveCount})";
                    if (!data.HasValidHandle) label += " [Invalid]";

                    GUIStyle currentStyle = new GUIStyle(_itemStyle);
                    if (isSelected) 
                    {
                        currentStyle.normal.textColor = Color.cyan;
                        currentStyle.fontStyle = FontStyle.Bold;
                    }

                    if (GUILayout.Button(label, currentStyle))
                    {
                        _selectedKey = data.Key;
                        GUI.FocusControl(null);
                    }
                }
            }

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void DrawDetailsPanel()
        {
            EditorGUILayout.BeginVertical();
            _scrollRight = EditorGUILayout.BeginScrollView(_scrollRight);

            var data = _viewData.FirstOrDefault(d => d.Key == _selectedKey);

            if (data != null)
            {
                DrawPoolDetails(data);
            }
            else
            {
                EditorGUILayout.HelpBox("Select a pool to inspect.", MessageType.Info);
            }

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void DrawPoolDetails(PoolViewData data)
        {
            EditorGUILayout.LabelField(data.Key, EditorStyles.boldLabel);
            EditorGUILayout.Space();

            // 1. 资源状态
            EditorGUILayout.BeginVertical("HelpBox");
            EditorGUILayout.LabelField("Resource Status", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Handle Valid:", GUILayout.Width(100));
            EditorGUILayout.LabelField(data.HasValidHandle.ToString(), 
                data.HasValidHandle ? EditorStyles.label : new GUIStyle(EditorStyles.label) { normal = { textColor = Color.red } });
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Prefab Asset:", GUILayout.Width(100));
            EditorGUILayout.ObjectField(data.Prefab, typeof(GameObject), false);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();

            EditorGUILayout.Space();

            // 2. 运行时状态
            EditorGUILayout.BeginVertical("HelpBox");
            EditorGUILayout.LabelField("Runtime Status", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Inactive Count:", GUILayout.Width(100));
            EditorGUILayout.LabelField(data.InactiveCount.ToString(), EditorStyles.largeLabel);
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();

            EditorGUILayout.Space();

            // 3. 操作
            EditorGUILayout.LabelField("Actions", EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("Spawn (+1)", GUILayout.Height(30)))
            {
                AsakiSmartPool.Spawn(data.Key, Vector3.zero);
                FetchData();
            }

            if (GUILayout.Button("Prewarm (+5)", GUILayout.Height(30)))
            {
                _ = AsakiSmartPool.PrewarmAsync(data.Key, 5, 5);
                FetchData();
            }
            
            EditorGUILayout.EndHorizontal();
        }

        // ==================================================================================
        // Reflection Logic (V5.1 Adapted)
        // ==================================================================================

        private void FetchData()
        {
            _viewData.Clear();

            // 1. 获取 Service 实例
            if (!AsakiContext.TryGet<IAsakiPoolService>(out var service)) return;

            // 2. 反射获取 _pools 字典
            // 注意：这里必须反射 AsakiPoolService 类型，而不是接口
            Type serviceType = service.GetType(); 
            var poolsField = serviceType.GetField("_pools", BindingFlags.NonPublic | BindingFlags.Instance);
            
            if (poolsField == null) return;

            var poolsDict = poolsField.GetValue(service) as IDictionary;
            if (poolsDict == null) return;

            // 3. 遍历 PoolData
            foreach (DictionaryEntry kvp in poolsDict)
            {
                string key = (string)kvp.Key;
                object poolDataObj = kvp.Value;

                if (poolDataObj == null) continue;

                // 反射 PoolData (internal class)
                Type dataType = poolDataObj.GetType();
                
                // 获取 Stack
                var stackField = dataType.GetField("Stack");
                var stackObj = stackField?.GetValue(poolDataObj) as ICollection;
                int count = stackObj != null ? stackObj.Count : 0;

                // 获取 Handle
                var handleField = dataType.GetField("PrefabHandle");
                var handleObj = handleField?.GetValue(poolDataObj);
                
                GameObject prefab = null;
                bool hasHandle = false;

                if (handleObj != null)
                {
                    // 反射 ResHandle<T>
                    Type handleType = handleObj.GetType();
                    var assetField = handleType.GetField("Asset");
                    prefab = assetField?.GetValue(handleObj) as GameObject;
                    hasHandle = prefab != null;
                }

                _viewData.Add(new PoolViewData
                {
                    Key = key,
                    InactiveCount = count,
                    Prefab = prefab,
                    HasValidHandle = hasHandle
                });
            }
        }
    }
}```

<!-- File: Asaki/Editor/GraphEditors/AsakiBlackboardProvider.cs -->
<!-- GUID: b8eff20ad06d4af69c40cd7fb25e9740 -->
<!-- Size: 12227 bytes -->
<!-- Modified: 2025-12-22 23:44:00 -->
```csharp
using System;
using System.Collections.Generic;
using Asaki.Core.Graphs;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors
{
    /// <summary>
    /// 负责管理 GraphView 中的 Blackboard 面板 (UI Toolkit)
    /// </summary>
    public class AsakiBlackboardProvider
    {
        public Blackboard Blackboard { get; private set; }
        
        private readonly AsakiGraphView _graphView;
        private readonly AsakiGraphBase _graphAsset;
        private readonly SerializedObject _serializedGraph;

        public AsakiBlackboardProvider(AsakiGraphView graphView, AsakiGraphBase graphAsset, SerializedObject serializedGraph)
        {
            _graphView = graphView;
            _graphAsset = graphAsset;
            _serializedGraph = serializedGraph;

            InitializeBlackboard();
            RefreshBlackboard();
        }

        private void InitializeBlackboard()
        {
            // 1. 创建 Blackboard UI 控件
            Blackboard = new Blackboard(_graphView)
            {
                title = "Blackboard",
                subTitle = "Variables"
            };

            // 2. 配置添加按钮 (Add Item)
            Blackboard.addItemRequested = _ =>
            {
                var menu = new GenericMenu();
                foreach (AsakiBlackboardPropertyType type in Enum.GetValues(typeof(AsakiBlackboardPropertyType)))
                {
                    menu.AddItem(new GUIContent(type.ToString()), false, () => AddVariable(type));
                }
                menu.ShowAsContext();
            };

            // 3. 配置重命名与移动
            Blackboard.editTextRequested = (bb, element, newName) =>
            {
                var field = (BlackboardField)element;
                var variable = (AsakiVariableDef)field.userData;
                
                if (string.IsNullOrEmpty(newName) || newName == variable.Name) return;

                // 简单的重名检查
                if (_graphAsset.Variables.Exists(v => v.Name == newName))
                {
                    EditorUtility.DisplayDialog("Error", "Variable name already exists!", "OK");
                    return;
                }

                Undo.RecordObject(_graphAsset, "Rename Variable");
                variable.Name = newName;
                field.text = newName;
                EditorUtility.SetDirty(_graphAsset);
            };

            // 4. 设置位置 (默认左上角，稍微偏移)
            Blackboard.SetPosition(new Rect(10, 30, 200, 300));
            
            // 5. 添加到 GraphView
            _graphView.Add(Blackboard);
            
            // 6. 开启 Scrollable
            Blackboard.scrollable = true;
            
            Blackboard.RegisterCallback<KeyDownEvent>(evt =>
            {
                if (evt.keyCode == KeyCode.Delete || evt.keyCode == KeyCode.Backspace)
                {
                    DeleteSelectedVariables();
                    evt.StopImmediatePropagation();
                }
            });
        }
        
        private void DeleteSelectedVariables()
        {
            // 1. 获取当前选中的黑板元素
            var selection = Blackboard.selection;
            if (selection == null || selection.Count == 0) return;

            // 2. 记录 Undo (支持撤销)
            Undo.RecordObject(_graphAsset, "Delete Variables");

            bool changed = false;
            
            // 3. 倒序遍历删除（防止索引错位，虽然这里是 foreach，但在 List Remove 时需小心）
            // 这里我们先收集要删除的变量，再统一移除
            var varsToRemove = new List<AsakiVariableDef>();

            foreach (var element in selection)
            {
                // 只有选中的是 BlackboardField (具体变量行) 时才删除
                if (element is BlackboardField field && field.userData is AsakiVariableDef def)
                {
                    varsToRemove.Add(def);
                }
            }

            foreach (var def in varsToRemove)
            {
                _graphAsset.Variables.Remove(def);
                changed = true;
            }

            // 4. 如果有数据变动，刷新 UI 并标记 Dirty
            if (changed)
            {
                // 刷新黑板 UI
                RefreshBlackboard();
                
                // 标记 Asset 已修改
                EditorUtility.SetDirty(_graphAsset);
            }
        }

        private void AddVariable(AsakiBlackboardPropertyType type)
        {
            Undo.RecordObject(_graphAsset, "Add Variable");
            
            // 生成唯一名字
            string name = "New" + type;
            int i = 1;
            while (_graphAsset.Variables.Exists(v => v.Name == name))
                name = $"New{type}_{i++}";

            var newVar = new AsakiVariableDef { Name = name, Type = type };
            _graphAsset.Variables.Add(newVar);
            
            EditorUtility.SetDirty(_graphAsset);
            
            // 刷新 UI
            RefreshBlackboard();
        }

        public void RefreshBlackboard()
        {
            Blackboard.Clear();
            var section = new BlackboardSection { title = "Exposed Properties" };
            Blackboard.Add(section);

            foreach (var variable in _graphAsset.Variables)
            {
                var field = new BlackboardField
                {
                    text = variable.Name,
                    typeText = variable.Type.ToString(),
                    userData = variable // ★ 关键：将数据绑定到 VisualElement
                };

                // ★ [New] 注册拖拽事件
                EnableDrag(field, variable);

                var row = new BlackboardRow(field, CreateValueView(variable));
                section.Add(row);
            }
        }
        
        private void EnableDrag(VisualElement element, AsakiVariableDef variable)
        {
            Vector2 _mouseDownPos = Vector2.zero;
            bool _readyToDrag = false;

            element.RegisterCallback<MouseDownEvent>(evt =>
            {
                if (evt.button == 0)
                {
                    _mouseDownPos = evt.localMousePosition;
                    _readyToDrag = true;
                }
            });

            element.RegisterCallback<MouseMoveEvent>(evt =>
            {
                // 1. 基础状态检查
                if (!_readyToDrag || evt.pressedButtons != 1) return;

            
                if (DragAndDrop.GetGenericData("AsakiVariable") != null) 
                {
                    _readyToDrag = false;
                    return;
                }

                // 3. 距离阈值检测
                if (Vector2.Distance(evt.localMousePosition, _mouseDownPos) > 5f)
                {
                    _readyToDrag = false;
                    
                    DragAndDrop.PrepareStartDrag();
                    DragAndDrop.SetGenericData("AsakiVariable", variable);
                    DragAndDrop.StartDrag("Dragging " + variable.Name);
                    
                    evt.StopImmediatePropagation();
                }
            });

            element.RegisterCallback<MouseUpEvent>(evt =>
            {
                _readyToDrag = false;
            });
            
            element.RegisterCallback<MouseLeaveEvent>(evt => 
            {
                _readyToDrag = false; 
            });
        }

        // 创建行内的小编辑器 (修改默认值)
        private VisualElement CreateValueView(AsakiVariableDef variable)
        {
            // 这里我们使用简易的 IMGUIContainer 或者 UI Elements
            // 为了简单，直接根据类型创建对应的 Field
            VisualElement container = new VisualElement();
            container.style.paddingLeft = 10;

            switch (variable.Type)
            {
                case AsakiBlackboardPropertyType.Int:
                    var intField = new IntegerField { value = variable.IntVal };
                    intField.RegisterValueChangedCallback(evt => {
                        variable.IntVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    container.Add(intField);
                    break;
                case AsakiBlackboardPropertyType.Float:
                    var floatField = new FloatField { value = variable.FloatVal };
                    floatField.RegisterValueChangedCallback(evt => {
                        variable.FloatVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    container.Add(floatField);
                    break;
                case AsakiBlackboardPropertyType.Bool:
                    var boolField = new Toggle { value = variable.BoolVal };
                    boolField.RegisterValueChangedCallback(evt => {
                        variable.BoolVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    container.Add(boolField);
                    break;
                case AsakiBlackboardPropertyType.String:
                    var strField = new TextField { value = variable.StringVal };
                    strField.RegisterValueChangedCallback(evt => {
                        variable.StringVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    container.Add(strField);
                    break;
                case AsakiBlackboardPropertyType.Vector3:
                    var vec3Field = new Vector3Field { value = variable.Vector3Val };
                    vec3Field.RegisterValueChangedCallback(evt => {
                        variable.Vector3Val = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    container.Add(vec3Field);
                    break;
                case AsakiBlackboardPropertyType.Vector2:
                    var vec2Field = new Vector2Field { value = variable.Vector2Val };
                    vec2Field.RegisterValueChangedCallback(evt => {
                        variable.Vector2Val = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    break;
                case AsakiBlackboardPropertyType.Vector3Int:
                    var vec3IntField = new Vector3IntField { value = variable.Vector3IntVal };
                    vec3IntField.RegisterValueChangedCallback(evt =>
                    {
                        variable.Vector3IntVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    break;
                case AsakiBlackboardPropertyType.Vector2Int:
                    var vec2IntField = new Vector2IntField { value = variable.Vector2IntVal };
                    vec2IntField.RegisterValueChangedCallback(evt =>
                    {
                        variable.Vector2IntVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    break;
                case AsakiBlackboardPropertyType.Color:
                    var colorField = new ColorField { value = variable.ColorVal };
                    colorField.RegisterValueChangedCallback(evt =>
                    {
                        variable.ColorVal = evt.newValue;
                        EditorUtility.SetDirty(_graphAsset);
                    });
                    break;
            }
            return container;
        }
    }
}```

<!-- File: Asaki/Editor/GraphEditors/AsakiGraphDebugger.cs -->
<!-- GUID: 9a833e2cdd7c4964a735ce058884593f -->
<!-- Size: 3340 bytes -->
<!-- Modified: 2025-12-22 23:30:40 -->
```csharp
using Asaki.Core.Graphs;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.GraphEditors
{
	/// <summary>
	/// 负责连接 Editor Window 和 Runtime Runner
	/// </summary>
	public class AsakiGraphDebugger
	{
		private readonly AsakiGraphView _graphView;

		// 当前连接的 Runner 实例
		private MonoBehaviour _currentRunner;
		private System.Reflection.EventInfo _eventInfo;
		private System.Delegate _handler;

		public AsakiGraphDebugger(AsakiGraphView graphView)
		{
			_graphView = graphView;

			// 监听编辑器选区变化
			Selection.selectionChanged += OnSelectionChanged;

			// 尝试初始化
			OnSelectionChanged();
		}

		public void Dispose()
		{
			Selection.selectionChanged -= OnSelectionChanged;
			Disconnect();
		}

		private void OnSelectionChanged()
		{
			// 1. 如果没在运行，不需要连接
			if (!Application.isPlaying)
			{
				Disconnect();
				return;
			}

			var go = Selection.activeGameObject;
			if (go == null) return;

			// 2. 查找 GameObject 上是否有对应的 Runner
			// 注意：我们不知道具体的 Runner 类型 (AsakiGraphRunner<T>)，所以需要反射查找
			// 或者我们可以让所有 Runner 实现一个非泛型接口 IAsakiGraphRunner

			var runners = go.GetComponents<MonoBehaviour>();
			foreach (var runner in runners)
			{
				// 简单的鸭子类型匹配：看它有没有 "GraphAsset" 字段且资产匹配
				var runnerType = runner.GetType();
				var assetField = runnerType.GetField("GraphAsset");

				if (assetField != null)
				{
					var asset = assetField.GetValue(runner) as AsakiGraphBase;

					// 3. 只有当选中的 Runner 运行的是当前编辑器打开的 Graph 时，才连接
					// (对比 Asset 引用是否一致，或者 GUID 是否一致)
					if (asset == _graphView.GraphAsset) // 需要在 GraphView 公开 GraphAsset
					{
						Connect(runner);
						return;
					}
				}
			}
		}

		private void Connect(MonoBehaviour runner)
		{
			if (_currentRunner == runner) return;

			Disconnect();
			_currentRunner = runner;

			// 4. 反射订阅 OnNodeExecuted 事件
			// 因为 Runner 是泛型的，我们在 Editor 层不知道具体的 T
			var eventInfo = runner.GetType().GetEvent("OnNodeExecuted");
			if (eventInfo != null)
			{
				// 创建委托： (AsakiNodeBase node) => OnNodeExecuted(node)
				System.Action<AsakiNodeBase> action = OnNodeExecuted;
				_handler = System.Delegate.CreateDelegate(eventInfo.EventHandlerType, action.Target, action.Method);
				eventInfo.AddEventHandler(runner, _handler);

				_eventInfo = eventInfo;
				Debug.Log($"[AsakiDebugger] Connected to {runner.name}");
			}
		}

		private void Disconnect()
		{
			if (_currentRunner != null && _handler != null && _eventInfo != null)
			{
				_eventInfo.RemoveEventHandler(_currentRunner, _handler);
			}
			_currentRunner = null;
			_handler = null;
			_eventInfo = null;
		}

		// 5. 收到运行时事件 -> 更新 UI
		private void OnNodeExecuted(AsakiNodeBase nodeData)
		{
			// 必须在主线程更新 UI (Unity 事件本来就是主线程，安全)
			var nodeView = _graphView.GetNodeByGUID(nodeData.GUID);
			if (nodeView != null)
			{
				nodeView.Highlight();
			}
		}

		

	}
}
```

<!-- File: Asaki/Editor/GraphEditors/AsakiGraphIOUtils.cs -->
<!-- GUID: 8b1608f28f444bc1ae20ad7417c77628 -->
<!-- Size: 2599 bytes -->
<!-- Modified: 2025-12-22 22:45:58 -->
```csharp
using Asaki.Core.Graphs;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.GraphEditors
{
    public static class AsakiGraphIOUtils
    {
        // ★ T 必须有无参构造函数 (new())，不再是 ScriptableObject
        public static T AddNode<T>(AsakiGraphBase graph, Vector2 pos) where T : AsakiNodeBase, new()
        {
            // 1. 记录 Graphs 的状态 (因为节点是 Graphs 的一部分)
            Undo.RecordObject(graph, "Add Node");

            // 2. 创建纯 C# 对象
            var node = new T();
            node.GUID = System.Guid.NewGuid().ToString();
            node.Position = pos;
            
            // 如果有基类初始化逻辑
            node.OnCreated(); 

            // 3. 直接加入列表
            graph.Nodes.Add(node);

            // 4. 标记脏数据
            EditorUtility.SetDirty(graph);
            
            return node;
        }

        public static void DeleteNode(AsakiGraphBase graph, AsakiNodeBase node)
        {
            Undo.RecordObject(graph, "Delete Node");

            // 1. 移除节点
            graph.Nodes.Remove(node);

            // 2. 清理相关连线
            graph.Edges.RemoveAll(e => 
                e.BaseNodeGUID == node.GUID || 
                e.TargetNodeGUID == node.GUID
            );

            EditorUtility.SetDirty(graph);
        }

        public static void AddEdge(AsakiGraphBase graph, AsakiEdgeData edgeData)
        {
            Undo.RecordObject(graph, "Add Edge");
            // 简单的去重检查
            bool exists = graph.Edges.Exists(e => 
                e.BaseNodeGUID == edgeData.BaseNodeGUID && 
                e.BasePortName == edgeData.BasePortName &&
                e.TargetNodeGUID == edgeData.TargetNodeGUID && 
                e.TargetPortName == edgeData.TargetPortName);
            
            if (!exists)
            {
                graph.Edges.Add(edgeData);
            }
            EditorUtility.SetDirty(graph);
        }

        public static void RemoveEdge(AsakiGraphBase graph, AsakiEdgeData edgeData)
        {
            Undo.RecordObject(graph, "Remove Edge");
            graph.Edges.RemoveAll(e => 
                e.BaseNodeGUID == edgeData.BaseNodeGUID &&
                e.BasePortName == edgeData.BasePortName &&
                e.TargetNodeGUID == edgeData.TargetNodeGUID &&
                e.TargetPortName == edgeData.TargetPortName
            );
            EditorUtility.SetDirty(graph);
        }
    }
}```

<!-- File: Asaki/Editor/GraphEditors/AsakiGraphTypeCache.cs -->
<!-- GUID: 4f1a881ed4cc47dd87bd34a116eccdc8 -->
<!-- Size: 1894 bytes -->
<!-- Modified: 2025-12-22 23:50:38 -->
```csharp
using Asaki.Core;
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.GraphEditors
{
	public struct PortInfo
	{
		public string FieldName;
		public string PortName;
		public bool IsInput;
		public bool AllowMultiple;
		public Type DataType;
	}
	
	public static class AsakiGraphTypeCache
	{
		// 缓存：Type -> PortList
		private static readonly Dictionary<Type, List<PortInfo>> _portCache = new Dictionary<Type, List<PortInfo>>();

		/// <summary>
		/// 获取某个节点类型的所有端口定义 (O(1) 访问)
		/// </summary>
		public static List<PortInfo> GetPorts(Type nodeType)
		{
			if (_portCache.TryGetValue(nodeType, out var list))
			{
				return list;
			}

			// 缓存未命中，执行反射扫描
			var result = new List<PortInfo>();
			var fields = nodeType.GetFields(BindingFlags.Public | BindingFlags.Instance);

			foreach (var field in fields)
			{
				// 扫描 Input
				var inputAttr = field.GetCustomAttribute<AsakiNodeInputAttribute>();
				if (inputAttr != null)
				{
					result.Add(new PortInfo
					{
						FieldName = field.Name,
						PortName = inputAttr.PortName,
						IsInput = true,
						AllowMultiple = inputAttr.Multiple,
						DataType = field.FieldType
					});
				}

				// 扫描 Output
				var outputAttr = field.GetCustomAttribute<AsakiNodeOutputAttribute>();
				if (outputAttr != null)
				{
					result.Add(new PortInfo
					{
						FieldName = field.Name,
						PortName = outputAttr.PortName,
						IsInput = false,
						AllowMultiple = outputAttr.Multiple,
						DataType = field.FieldType
					});
				}
			}

			_portCache[nodeType] = result;
			return result;
		}
		
		[InitializeOnLoadMethod]
		private static void ClearCache()
		{
			_portCache.Clear();
		}
	}
}
```

<!-- File: Asaki/Editor/GraphEditors/AsakiGraphView.cs -->
<!-- GUID: 22b3b1af98004045b71fcd611c437d5e -->
<!-- Size: 11322 bytes -->
<!-- Modified: 2025-12-22 23:31:19 -->
```csharp
using Asaki.Core.Graphs;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors
{
    public class AsakiGraphView : GraphView
    {
        private AsakiGraphBase _graph;
        public AsakiGraphBase GraphAsset => _graph;
        private SerializedObject _serializedGraph; // 缓存 Graphs 的 SO
        public AsakiBlackboardProvider BlackboardProvider;
        public AsakiGraphView(AsakiGraphBase graph)
        {
            _graph = graph;
            _serializedGraph = new SerializedObject(graph); // 初始化 SO

			// 1. 基础交互配置
			SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale);
			this.AddManipulator(new ContentDragger());
			this.AddManipulator(new SelectionDragger());
			this.AddManipulator(new RectangleSelector());


			var grid = new GridBackground();
			Insert(0, grid);
			grid.StretchToParentSize();

			var styleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>("Assets/Asaki/Editor/Style/AsakiGraphView.uss");
			if (styleSheet != null)
			{
				styleSheets.Add(styleSheet);
			}
			else
			{
				Debug.LogWarning("[AsakiGraph] Could not find 'AsakiGraphView.uss' in Resources folder.");
			}
			// 3. 生成节点
			PopulateView();

            graphViewChanged = OnGraphViewChanged;
            Undo.undoRedoPerformed += OnUndoRedo;
            RegisterCallback<DetachFromPanelEvent>(OnDetach);
            nodeCreationRequest = OnNodeCreationRequest;
            
            
            BlackboardProvider = new AsakiBlackboardProvider(this, graph, _serializedGraph);
            RegisterCallback<DragEnterEvent>(OnDragEnter);
            RegisterCallback<DragUpdatedEvent>(OnDragUpdated);
            RegisterCallback<DragPerformEvent>(OnDragPerform);
            RegisterCallback<DragLeaveEvent>(OnDragLeave);
        }

        private void OnDragEnter(DragEnterEvent evt)
        {
            // 检查数据源是否合法
            var data = DragAndDrop.GetGenericData("AsakiVariable");
            if (data != null)
            {
                // 设置鼠标样式为 "Copy" (绿加号)
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                evt.StopImmediatePropagation();
            }
        }

        // 2. 拖拽更新 (每帧调用)
        private void OnDragUpdated(DragUpdatedEvent evt)
        {
            var data = DragAndDrop.GetGenericData("AsakiVariable");
            if (data != null)
            {
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                evt.StopImmediatePropagation();
            }
        }
        
        // 3. 离开区域 (重置)
        private void OnDragLeave(DragLeaveEvent evt)
        {
            // DragAndDrop.visualMode = DragAndDropVisualMode.None; // 不需要手动重置，Unity 会处理
        }

        // 4. 执行放置 (松开鼠标)
        private void OnDragPerform(DragPerformEvent evt)
        {
            var data = DragAndDrop.GetGenericData("AsakiVariable") as AsakiVariableDef;
            if (data != null)
            {
                // 计算放置位置 (鼠标屏幕坐标 -> Graph 本地坐标)
                var localPos = contentViewContainer.WorldToLocal(evt.mousePosition);
                
                // 弹出菜单供用户选择 Get 或 Set
                ShowVariableMenu(data, localPos);
                
                DragAndDrop.AcceptDrag();
                evt.StopImmediatePropagation();
            }
        }
        
        private void ShowVariableMenu(AsakiVariableDef variable, Vector2 position)
        {
            var menu = new GenericMenu();
            
            // Option 1: Get Variable
            menu.AddItem(new GUIContent($"Get {variable.Name}"), false, () =>
            {
                CreateVariableNode<AsakiGetVariableNode>(variable, position);
            });
            
            // Option 2: Set Variable
            menu.AddItem(new GUIContent($"Set {variable.Name}"), false, () =>
            {
                CreateVariableNode<AsakiSetVariableNode>(variable, position);
            });
            
            menu.ShowAsContext();
        }
        
        private void CreateVariableNode<T>(AsakiVariableDef variable, Vector2 position) where T : AsakiNodeBase, new()
        {
            // 使用 IO 工具创建纯数据节点
            var nodeData = AsakiGraphIOUtils.AddNode<T>(_graph, position);
            
            // ★ 注入变量信息
            // 这里利用反射或模式匹配，因为 T 是泛型
            if (nodeData is AsakiGetVariableNode getNode)
            {
                getNode.VariableName = variable.Name;
                getNode.VariableType = variable.Type;
            }
            else if (nodeData is AsakiSetVariableNode setNode)
            {
                setNode.VariableName = variable.Name;
                setNode.VariableType = variable.Type;
            }
            
            // 立即在视图中生成
            CreateNodeView(nodeData);
        }
        private void OnNodeCreationRequest(NodeCreationContext context)
        {
            var searchWindow = ScriptableObject.CreateInstance<AsakiNodeSearchWindow>();
            var window = EditorWindow.focusedWindow;
            searchWindow.Initialize(this, _graph, window);
            SearchWindow.Open(new SearchWindowContext(context.screenMousePosition), searchWindow);
        }

        private void OnDetach(DetachFromPanelEvent evt)
        {
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        private void OnUndoRedo()
        {
            schedule.Execute(PopulateView);
        }

        private void PopulateView()
        {
            graphViewChanged -= OnGraphViewChanged;
            DeleteElements(graphElements.ToList());

            // 必须更新 SO，否则 Undo 后获取的 Property 可能是旧的
            _serializedGraph.Update(); 

            foreach (var nodeData in _graph.Nodes)
            {
                CreateNodeView(nodeData);
            }

			foreach (var edgeData in _graph.Edges)
			{
				var baseNode = GetNodeByGUID(edgeData.BaseNodeGUID);
				var targetNode = GetNodeByGUID(edgeData.TargetNodeGUID);

				if (baseNode != null && targetNode != null)
				{
					var outputPort = baseNode.Outputs.FirstOrDefault(p => (string)p.userData == edgeData.BasePortName);
					var inputPort = targetNode.Inputs.FirstOrDefault(p => (string)p.userData == edgeData.TargetPortName);

					if (outputPort != null && inputPort != null)
					{
						var edge = outputPort.ConnectTo(inputPort);
						AddElement(edge);
					}
				}
			}

            graphViewChanged += OnGraphViewChanged;
        }

        public void CreateNodeView(AsakiNodeBase node)
        {
            // ★ 传入 SerializedObject，以便 NodeView 能够绘制 Inspector
            var nodeView = new AsakiNodeView(node, _serializedGraph);
            AddElement(nodeView);
            nodeView.SetPosition(new Rect(node.Position, Vector2.zero));
        }

        public AsakiNodeView GetNodeByGUID(string guid)
        {
            return nodes.ToList().Cast<AsakiNodeView>().FirstOrDefault(n => n.node.GUID == guid);
        }

        private GraphViewChange OnGraphViewChanged(GraphViewChange graphViewChange)
        {
            if (graphViewChange.movedElements != null)
            {
                // ★ 关键修改：Undo 记录的是 Graphs 本身
                Undo.RecordObject(_graph, "Move Nodes");

                foreach (var element in graphViewChange.movedElements)
                {
                    if (element is AsakiNodeView nodeView)
                    {
                        // 只需要更新内存中的数据
                        nodeView.SyncPosition();
                    }
                }
                // 标记 Dirty 确保保存
                EditorUtility.SetDirty(_graph);
            }

            if (graphViewChange.edgesToCreate != null)
            {
                foreach (var edge in graphViewChange.edgesToCreate)
                {
                    var outputNode = edge.output.node as AsakiNodeView;
                    var inputNode = edge.input.node as AsakiNodeView;
                    if (outputNode == null || inputNode == null) continue;

                    var newEdge = new AsakiEdgeData
                    {
                        BaseNodeGUID = outputNode.node.GUID,
                        BasePortName = (string)edge.output.userData,
                        TargetNodeGUID = inputNode.node.GUID,
                        TargetPortName = (string)edge.input.userData
                    };
                    AsakiGraphIOUtils.AddEdge(_graph, newEdge);
                }
            }

            if (graphViewChange.elementsToRemove != null)
            {
                Undo.IncrementCurrentGroup();
                Undo.SetCurrentGroupName("Delete Elements");
                var undoGroup = Undo.GetCurrentGroup();

                foreach (var element in graphViewChange.elementsToRemove)
                {
                    if (element is AsakiNodeView nodeView)
                    {
                        // 这里逻辑不变，Utility 内部已经处理了 Undo.RecordObject(_graph)
                        AsakiGraphIOUtils.DeleteNode(_graph, nodeView.node);
                    }
                    else if (element is Edge edge)
                    {
                        var outputNode = edge.output.node as AsakiNodeView;
                        var inputNode = edge.input.node as AsakiNodeView;
                        if (outputNode != null && inputNode != null)
                        {
                            var edgeToRemove = new AsakiEdgeData
                            {
                                BaseNodeGUID = outputNode.node.GUID,
                                BasePortName = (string)edge.output.userData,
                                TargetNodeGUID = inputNode.node.GUID,
                                TargetPortName = (string)edge.input.userData
                            };
                            AsakiGraphIOUtils.RemoveEdge(_graph, edgeToRemove);
                        }
                    }
                }
                Undo.CollapseUndoOperations(undoGroup);
            }

            return graphViewChange;
        }

        // ... (GetCompatiblePorts 保持不变) ...
        public override List<Port> GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter)
        {
            var compatiblePorts = new List<Port>();
            ports.ForEach(port =>
            {
                if (startPort != port && startPort.node != port.node && startPort.direction != port.direction)
                {
                    compatiblePorts.Add(port);
                }
            });
            return compatiblePorts;
        }
    }
}```

<!-- File: Asaki/Editor/GraphEditors/AsakiGraphWindow.cs -->
<!-- GUID: 2cb64508364b4418a3352cae69cab0c4 -->
<!-- Size: 3030 bytes -->
<!-- Modified: 2025-12-23 19:23:58 -->
```csharp
using Asaki.Core.Graphs;
using Asaki.Editor.GraphEditors;
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using UnityEngine.UIElements; // 引用 UI Elements 扩展

namespace Asaki.Editor.GraphEditors
{
	public class AsakiGraphWindow : EditorWindow
	{
		private IAsakiGraphViewController _controller;
		private AsakiGraphDebugger _debugger;
		private static Dictionary<Type, Func<AsakiGraphBase, IAsakiGraphViewController>> _registry
			= new Dictionary<Type, Func<AsakiGraphBase, IAsakiGraphViewController>>();
		
		public static void Register<TGraph>(Func<TGraph, IAsakiGraphViewController> factory)
			where TGraph : AsakiGraphBase
		{
			var type = typeof(TGraph);
			if (_registry.ContainsKey(type)) _registry[type] = (asset) => factory((TGraph)asset);
			else _registry.Add(type, (asset) => factory((TGraph)asset));
		}

		[OnOpenAsset(1)]
		public static bool OnOpenAsset(int instanceId, int line)
		{
			var obj = EditorUtility.InstanceIDToObject(instanceId);
			if (obj is not AsakiGraphBase graphAsset) return false;

			var type = graphAsset.GetType();
			if (!_registry.ContainsKey(type))
			{
				Debug.LogWarning($"[AsakiGraph] No controller registered for graph type: {type.Name}");
				return false; 
			}

			var window = GetWindow<AsakiGraphWindow>("Asaki Graph Editor");
			window.Initialize(_registry[type](graphAsset));
			return true;
		}

		// 支持打开内存实例
		public static void OpenInstance(AsakiGraphBase graph)
		{
			if (graph == null) return;
			var type = graph.GetType();

			if (!_registry.ContainsKey(type))
			{
				Debug.LogWarning($"[AsakiGraph] No controller registered for graph type: {type.Name}");
				return;
			}

			var window = GetWindow<AsakiGraphWindow>("Asaki Graph Editor");
			window.Initialize(_registry[type](graph));
			window.Show();
			window.Focus();
		}

		private void Initialize(IAsakiGraphViewController controller)
		{
			if (_controller != null) _controller.Dispose();

			_controller = controller;

			// 清理旧 UI
			rootVisualElement.Clear();

			if (_controller != null)
			{
				var graphView = _controller.CreateGraphView() as AsakiGraphView;
				if (graphView != null)
				{
					// ★★★ [修复] 强制 GraphView 填满整个窗口 ★★★
					// 如果不加这句，GraphView 高度可能为 0，导致看不见网格和节点
					graphView.StretchToParentSize(); 
					
					rootVisualElement.Add(graphView);
                
					_debugger?.Dispose();
					_debugger = new AsakiGraphDebugger(graphView);

					// [可选优化] 自动聚焦所有节点 (延迟一帧执行以等待布局计算完毕)
					rootVisualElement.schedule.Execute(() => 
					{
						graphView.FrameAll();
					});
				}
			}
		}

		private void Update()
		{
			_controller?.Update();
		}

		private void OnDisable()
		{
			_controller?.Dispose();
			_debugger?.Dispose(); 
		}
	}
}```

<!-- File: Asaki/Editor/GraphEditors/AsakiNodeSearchWindow.cs -->
<!-- GUID: 83078dc71db34e508241f28587978563 -->
<!-- Size: 3075 bytes -->
<!-- Modified: 2025-12-22 22:45:54 -->
```csharp
using Asaki.Core;
using Asaki.Core.Graphs;
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors
{
	public class AsakiNodeSearchWindow : ScriptableObject, ISearchWindowProvider
	{
		private AsakiGraphView _graphView;
		private AsakiGraphBase _graphAsset;
		private EditorWindow _window;
		private Texture2D _indentationIcon;

		public void Initialize(AsakiGraphView graphView, AsakiGraphBase graphAsset, EditorWindow window)
		{
			_graphView = graphView;
			_graphAsset = graphAsset;
			_window = window;

			// 创建一个透明图片用于缩进排版（纯视觉优化）
			_indentationIcon = new Texture2D(1, 1);
			_indentationIcon.SetPixel(0, 0, new Color(0, 0, 0, 0));
			_indentationIcon.Apply();
		}

		public List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context)
		{
			var tree = new List<SearchTreeEntry>
			{
				new SearchTreeGroupEntry(new GUIContent("Create Node"), 0),
			};

			var nodeTypes = TypeCache.GetTypesDerivedFrom<AsakiNodeBase>();

			foreach (var type in nodeTypes)
			{
				if (type.IsAbstract) continue;

				// ★ 核心变革：上下文过滤
				// 1. 获取节点的 [GraphContext] 特性
				var contextAttr = System.Attribute.GetCustomAttribute(type, typeof(AsakiGraphContextAttribute)) as AsakiGraphContextAttribute;
                
				// 2. 如果没有标记，或者标记的图类型与当前打开的图不匹配，则跳过
				// _graphAsset.GetType() 获取当前打开的图类型
				if (contextAttr == null || contextAttr.GraphType != _graphAsset.GetType()) 
					continue;

				// 3. 使用 Path 属性构建菜单 (支持 Log/DebugLog 这种子菜单)
				// 这里为了简单，暂且直接用 Name，后续可以解析 Path 分组
				tree.Add(new SearchTreeEntry(new GUIContent(type.Name, _indentationIcon))
				{
					userData = type, 
					level = 1
				});
			}

			return tree;
		}

		public bool OnSelectEntry(SearchTreeEntry SearchTreeEntry, SearchWindowContext context)
		{
			var type = SearchTreeEntry.userData as Type;
			if (type == null) return false;

			var windowRoot = _window.rootVisualElement;
			var windowMousePosition = windowRoot.ChangeCoordinatesTo(windowRoot.parent, context.screenMousePosition - _window.position.position);
			var graphMousePosition = _graphView.contentViewContainer.WorldToLocal(windowMousePosition);

			// 调用 IO 工具创建数据
			var method = typeof(AsakiGraphIOUtils).GetMethod("AddNode")?.MakeGenericMethod(type);
			if (method != null)
			{
				// ★ 修复：获取返回值 (新创建的 Node 数据)
				var newNode = method.Invoke(null, new object[] { _graphAsset, graphMousePosition }) as AsakiNodeBase;

				// ★ 修复：立刻在 View 中创建对应的视觉节点
				if (newNode != null)
				{
					_graphView.CreateNodeView(newNode);
				}

				return true;
			}

			return false;
		}
	}
}
```

<!-- File: Asaki/Editor/GraphEditors/AsakiNodeView.cs -->
<!-- GUID: 93113bdf78cd446aa92e0cf4341f0c51 -->
<!-- Size: 7458 bytes -->
<!-- Modified: 2025-12-22 23:28:40 -->
```csharp
using Asaki.Core;
using Asaki.Core.Graphs;
using Asaki.Editor.GraphEditors;
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors
{
    public class AsakiNodeView : Node
    {
        public AsakiNodeBase node;
        public List<Port> Inputs = new List<Port>();
        public List<Port> Outputs = new List<Port>();

        // 需要持有 Graphs 的 SO 才能绘制子属性
        private SerializedObject _graphSerializedObject;

        public AsakiNodeView(AsakiNodeBase data, SerializedObject graphSO)
        {
            this.node = data;
            this._graphSerializedObject = graphSO;
            this.viewDataKey = data.GUID;
            
            // 设置位置
            style.left = data.Position.x;
            style.top = data.Position.y;
            
            title = data.Title;

            // 1. 使用缓存生成端口 (O(1) 访问)
            GeneratePortsFromCache();
            
            // 2. 绘制节点内容 (PropertyField)
            CreateExtension();
            
            base.expanded = true;
            RefreshExpandedState();
        }

        private void GeneratePortsFromCache()
        {
            // ★ 使用缓存，不再直接反射
            var ports = AsakiGraphTypeCache.GetPorts(node.GetType());

            foreach (var info in ports)
            {
                var direction = info.IsInput ? Direction.Input : Direction.Output;
                var capacity = info.AllowMultiple ? Port.Capacity.Multi : Port.Capacity.Single;
                
                // 为了通用性，端口类型暂时用 info.DataType 或 typeof(float)
                // GraphView 的类型检查比较弱，主要靠 PortName 匹配
                var port = InstantiatePort(Orientation.Horizontal, direction, capacity, typeof(float));
                
                port.portName = info.PortName;
                port.userData = info.PortName;

                if (info.IsInput)
                {
                    inputContainer.Add(port);
                    Inputs.Add(port);
                }
                else
                {
                    outputContainer.Add(port);
                    Outputs.Add(port);
                }
            }
        }

        private void CreateExtension()
        {
            if (_graphSerializedObject == null) return;
            
            _graphSerializedObject.Update();

            var nodesProp = _graphSerializedObject.FindProperty("Nodes");
            if (nodesProp == null || !nodesProp.isArray) return;

            SerializedProperty myProp = null;
            for (int i = 0; i < nodesProp.arraySize; i++)
            {
                var element = nodesProp.GetArrayElementAtIndex(i);
                if (element.managedReferenceValue == node)
                {
                    myProp = element;
                    break;
                }
            }

            if (myProp != null)
            {
                var iterator = myProp.Copy();
                var endProperty = iterator.GetEndProperty();
                
                // ★ [New] 获取节点类型，用于检测字段是否有端口属性
                var nodeType = node.GetType();

                if (iterator.NextVisible(true))
                {
                    do
                    {
                        if (SerializedProperty.EqualContents(iterator, endProperty))
                            break;

                        // 1. 排除基础字段
                        if (iterator.name == "GUID" || iterator.name == "Position" || iterator.name == "ExecutionOrder") 
                            continue;

                        // 2. ★ [修复] 排除端口字段 (Port Fields)
                        // 如果绘制这些空结构体或用于连接的字段，会导致 SerializedProperty 偏移量计算错误
                        var fieldInfo = nodeType.GetField(iterator.name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                        if (fieldInfo != null)
                        {
                            // 检查是否有 [AsakiNodeInput] 或 [AsakiNodeOutput] 特性
                            if (Attribute.IsDefined(fieldInfo, typeof(AsakiNodeInputAttribute)) ||
                                Attribute.IsDefined(fieldInfo, typeof(AsakiNodeOutputAttribute)))
                            {
                                continue; // 跳过绘制端口字段
                            }
                        }

                        var field = new PropertyField(iterator.Copy());
                        field.Bind(_graphSerializedObject);
                        extensionContainer.Add(field);

                    } while (iterator.NextVisible(false));
                }
            }
        }
        
        // 当移动结束时，我们需要同步位置数据
        public void SyncPosition()
        {
            node.Position = GetPosition().position;
        }
        
        // ================================================================
        // ★ Debug Visuals
        // ================================================================

        private const float HIGHLIGHT_DURATION = 0.5f; // 高亮持续 0.5秒
        private float _highlightTime = 0f;
        private bool _isActive = false;

        public void Highlight()
        {
            _isActive = true;
            _highlightTime = (float)EditorApplication.timeSinceStartup;
            
            // 立即变色 (例如：明亮的青色边框)
            style.borderLeftColor = new StyleColor(Color.cyan);
            style.borderRightColor = new StyleColor(Color.cyan);
            style.borderTopColor = new StyleColor(Color.cyan);
            style.borderBottomColor = new StyleColor(Color.cyan);
            style.borderLeftWidth = 2f;
            style.borderRightWidth = 2f;
            style.borderTopWidth = 2f;
            style.borderBottomWidth = 2f;

            // 确保每帧刷新以执行 Fade Out
            EditorApplication.update -= UpdateHighlight;
            EditorApplication.update += UpdateHighlight;
        }

        private void UpdateHighlight()
        {
            if (!_isActive) return;

            float elapsed = (float)EditorApplication.timeSinceStartup - _highlightTime;
            
            if (elapsed > HIGHLIGHT_DURATION)
            {
                // 时间到，恢复原状
                ResetStyle();
                _isActive = false;
                EditorApplication.update -= UpdateHighlight;
            }
        }
        
        private void ResetStyle()
        {
            // 恢复默认边框 (通常是黑色或灰色)
            style.borderLeftColor = new StyleColor(Color.clear);
            style.borderRightColor = new StyleColor(Color.clear);
            style.borderTopColor = new StyleColor(Color.clear);
            style.borderBottomColor = new StyleColor(Color.clear);
            style.borderLeftWidth = 0f; // 或者恢复到 1f
        }
    }
}```

<!-- File: Asaki/Editor/GraphEditors/IAsakiGraphViewController.cs -->
<!-- GUID: 5334490db2b44978a72f5f04b17f6e99 -->
<!-- Size: 442 bytes -->
<!-- Modified: 2025-12-22 22:45:58 -->
```csharp
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors
{
	public interface IAsakiGraphViewController
	{
		// 创建 GraphView 视觉元素
		VisualElement CreateGraphView();
        
		// 更新逻辑 (每帧调用，处理 Copy/Paste 等)
		void Update();
        
		// 保存逻辑 (虽然我们有 Undo，但有时需要手动触发编译)
		void Save();
        
		// 清理资源
		void Dispose();
	}
}
```

<!-- File: Asaki/Editor/GraphEditors/Impl/GenericAsakiGraphController.cs -->
<!-- GUID: 82e39daac9e04a83a4e7363d16ab9f99 -->
<!-- Size: 686 bytes -->
<!-- Modified: 2025-12-22 22:45:47 -->
```csharp
using Asaki.Core.Graphs;
using Asaki.Editor.GraphEditors;
using UnityEngine.UIElements;

namespace Asaki.Editor.GraphEditors.Impl
{
	public class GenericAsakiGraphController : IAsakiGraphViewController
	{
		private readonly AsakiGraphBase _graph;
		private AsakiGraphView _graphView; // 持有引用
		
		public GenericAsakiGraphController(AsakiGraphBase graph)
		{
			_graph = graph;
		}
		public VisualElement CreateGraphView()
		{
			_graphView = new AsakiGraphView(_graph);
			_graphView.style.flexGrow = 1; // 填满窗口
			return _graphView;
		}
		public void Update()
		{
		}
		public void Save()
		{
		}
		public void Dispose()
		{
		}
	}
}
```

<!-- File: Asaki/Editor/ModuleSystem/AsakiModuleDashboard.cs -->
<!-- GUID: daf94daaf8ff49e38de17865374c43cc -->
<!-- Size: 14441 bytes -->
<!-- Modified: 2025-12-23 19:48:04 -->
```csharp
using Asaki.Core;
using Asaki.Core.Context;
using Asaki.Editor.GraphEditors;
using Asaki.Editor.ModuleSystem.Graph;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.ModuleSystem
{
    public class AsakiModuleDashboard : EditorWindow
    {
        [MenuItem("Asaki/Module Dashboard")]
        public static void ShowWindow()
        {
            GetWindow<AsakiModuleDashboard>("Asaki Modules");
        }

        private class ModuleNode
        {
            public Type Type;
            public int Priority;
            public List<Type> Dependencies = new List<Type>();
            public List<Type> Dependents = new List<Type>();
            public bool HasCircularError = false;
            
            // [New] 拓扑深度 (0 = Root)
            public int Depth = 0;
            // [New] 优先级配置警告
            public string PriorityWarning = null;
        }

        private List<ModuleNode> _sortedNodes = new List<ModuleNode>();
        private Dictionary<Type, ModuleNode> _nodeMap = new Dictionary<Type, ModuleNode>();
        private ModuleNode _selectedNode;
        private Vector2 _scrollPos;
        private string _circularErrorMsg;
        private int _editPriorityValue;

        private void OnEnable() => RefreshData();

        private void OnGUI()
        {
            DrawToolbar();
            if (!string.IsNullOrEmpty(_circularErrorMsg))
                EditorGUILayout.HelpBox($"Graphs Error: {_circularErrorMsg}", MessageType.Error);

            EditorGUILayout.BeginHorizontal();
            DrawLeftPanel();
            DrawRightPanel();
            EditorGUILayout.EndHorizontal();
        }

        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            if (GUILayout.Button("Refresh Data", EditorStyles.toolbarButton, GUILayout.Width(100))) RefreshData();
            GUILayout.Space(10);
            
            var originalColor = GUI.backgroundColor;
            GUI.backgroundColor = new Color(0.6f, 1f, 0.6f); 
            if (GUILayout.Button("Open Dependency Graph", EditorStyles.toolbarButton, GUILayout.Width(160))) OpenVisualGraph();
            GUI.backgroundColor = originalColor;

            GUILayout.FlexibleSpace();
            GUILayout.Label($"Modules: {_sortedNodes.Count}", EditorStyles.miniLabel);
            EditorGUILayout.EndHorizontal();
        }

        private void OpenVisualGraph()
        {
            try { AsakiGraphWindow.OpenInstance(AsakiModuleGraphBuilder.Build()); }
            catch (Exception e) { Debug.LogError($"[Asaki] Failed to open graph: {e}"); }
        }

        private void DrawLeftPanel()
        {
            EditorGUILayout.BeginVertical(GUILayout.Width(350)); // 加宽一点以适应层级缩进
            GUILayout.Label("Initialization Order (Topological Sort)", EditorStyles.boldLabel);
            GUILayout.Space(5);

            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos, "box");

            for (int i = 0; i < _sortedNodes.Count; i++)
            {
                var node = _sortedNodes[i];
                DrawNodeItem(i, node);
            }

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void DrawNodeItem(int index, ModuleNode node)
        {
            var style = new GUIStyle(EditorStyles.helpBox);
            style.richText = true;

            // 高亮逻辑
            if (_selectedNode == node) GUI.backgroundColor = new Color(0.3f, 0.5f, 0.8f);
            else if (_selectedNode != null)
            {
                if (_selectedNode.Dependencies.Contains(node.Type)) GUI.backgroundColor = new Color(1f, 0.8f, 0.4f);
                else if (_selectedNode.Dependents.Contains(node.Type)) GUI.backgroundColor = new Color(0.4f, 0.8f, 0.4f);
                else GUI.backgroundColor = Color.white;
            }
            else GUI.backgroundColor = Color.white;

            EditorGUILayout.BeginHorizontal(style);
            
            // 序号
            GUILayout.Label($"<b>{index + 1}.</b>", new GUIStyle(EditorStyles.label) { richText = true, fixedWidth = 25 });

            // 缩进 (基于拓扑深度)
            GUILayout.Space(node.Depth * 15);

            // 绘制模块信息
            string label = $"<b>{node.Type.Name}</b>";
            if (!string.IsNullOrEmpty(node.PriorityWarning))
            {
                label += $" <color=red>⚠</color>"; // 警告图标
            }
            label += $"\n<size=10>Priority: {node.Priority}</size>";

            if (GUILayout.Button(label, new GUIStyle(EditorStyles.label) { richText = true }))
            {
                SelectNode(node);
            }
            
            // 如果有警告，显示红色提示文字
            if (!string.IsNullOrEmpty(node.PriorityWarning))
            {
                 GUILayout.Label($"<color=red>Priority < Dep</color>", new GUIStyle(EditorStyles.miniLabel) { richText = true, alignment = TextAnchor.MiddleRight }, GUILayout.Width(80));
            }

            EditorGUILayout.EndHorizontal();
            GUI.backgroundColor = Color.white;
        }

        private void DrawRightPanel()
        {
            EditorGUILayout.BeginVertical();
            if (_selectedNode == null)
            {
                GUILayout.Label("Select a module to view details.", EditorStyles.centeredGreyMiniLabel);
            }
            else
            {
                GUILayout.Space(10);
                GUILayout.Label($"Inspector: {_selectedNode.Type.Name}", EditorStyles.boldLabel);
                EditorGUILayout.Separator();

                // 警告信息展示
                if (!string.IsNullOrEmpty(_selectedNode.PriorityWarning))
                {
                    EditorGUILayout.HelpBox(_selectedNode.PriorityWarning, MessageType.Warning);
                }

                DrawPriorityEditor();
                EditorGUILayout.Space(10);

                GUILayout.Label("Dependencies (Upstream):", EditorStyles.boldLabel);
                if (_selectedNode.Dependencies.Count == 0) GUILayout.Label("  - None", EditorStyles.miniLabel);
                else foreach (var dep in _selectedNode.Dependencies)
                {
                    var depNode = _nodeMap[dep];
                    // 显示依赖项的优先级，方便对比
                    if (GUILayout.Button($"  ➡ {dep.Name} (P: {depNode.Priority})", EditorStyles.linkLabel)) SelectNode(depNode);
                }

                EditorGUILayout.Space(10);

                GUILayout.Label("Dependents (Downstream):", EditorStyles.boldLabel);
                if (_selectedNode.Dependents.Count == 0) GUILayout.Label("  - None", EditorStyles.miniLabel);
                else foreach (var dept in _selectedNode.Dependents)
                {
                     var deptNode = _nodeMap[dept];
                     if (GUILayout.Button($"  ⬅ {dept.Name} (P: {deptNode.Priority})", EditorStyles.linkLabel)) SelectNode(deptNode);
                }
                
                GUILayout.FlexibleSpace();
                if (GUILayout.Button("Open Script File", GUILayout.Height(30))) OpenScriptFile(_selectedNode.Type);
            }
            EditorGUILayout.EndVertical();
        }

        private void DrawPriorityEditor()
        {
            EditorGUILayout.BeginVertical("box");
            GUILayout.Label("Settings Modification", EditorStyles.miniBoldLabel);
            EditorGUILayout.BeginHorizontal();
            _editPriorityValue = EditorGUILayout.IntField("Priority", _editPriorityValue);
            
            if (_editPriorityValue != _selectedNode.Priority)
            {
                GUI.backgroundColor = Color.green;
                if (GUILayout.Button("Apply", GUILayout.Width(60)))
                {
                    if (EditorUtility.DisplayDialog("Confirm", $"Set Priority to {_editPriorityValue}?", "Yes", "No"))
                        UpdateScriptPriority(_selectedNode.Type, _editPriorityValue);
                }
                GUI.backgroundColor = Color.white;
            }
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
        }

        private void SelectNode(ModuleNode node)
        {
            _selectedNode = node;
            _editPriorityValue = node.Priority;
            GUI.FocusControl(null);
        }

        private void RefreshData()
        {
            _nodeMap.Clear();
            _sortedNodes.Clear();
            _circularErrorMsg = null;
            _selectedNode = null;
            var missingDependencies = new List<string>();

            // 1. 扫描与构建节点
            var types = TypeCache.GetTypesDerivedFrom<IAsakiModule>()
                .Where(t => !t.IsAbstract && t.IsDefined(typeof(AsakiModuleAttribute), false));

            foreach (var type in types)
            {
                var attr = type.GetCustomAttribute<AsakiModuleAttribute>();
                _nodeMap[type] = new ModuleNode { Type = type, Priority = attr.Priority };
            }

            // 2. 构建连接
            foreach (var node in _nodeMap.Values)
            {
                var attr = node.Type.GetCustomAttribute<AsakiModuleAttribute>();
                foreach (var depType in attr.Dependencies)
                {
                    if (_nodeMap.TryGetValue(depType, out var parentNode))
                    {
                        node.Dependencies.Add(depType);
                        parentNode.Dependents.Add(node.Type);
                    }
                    else missingDependencies.Add($"[{node.Type.Name}] missing dependency '{depType.Name}'");
                }
            }

            if (missingDependencies.Count > 0)
                _circularErrorMsg = "Missing Dependencies:\n" + string.Join("\n", missingDependencies);

            // 3. 拓扑排序 (Kahn's Algorithm) + 深度计算 + 优先级检查
            var inDegree = _nodeMap.Values.ToDictionary(n => n.Type, n => n.Dependencies.Count);
            
            // 初始队列：入度为0的节点（Root），按 Priority 排序
            var queue = new Queue<ModuleNode>(
                _nodeMap.Values.Where(n => inDegree[n.Type] == 0).OrderBy(n => n.Priority) 
            );

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();
                _sortedNodes.Add(current);

                // --- 健康检查逻辑 ---
                int maxDepPriority = int.MinValue;
                int maxDepDepth = -1;

                foreach (var depType in current.Dependencies)
                {
                    var depNode = _nodeMap[depType];
                    if (depNode.Priority > maxDepPriority) maxDepPriority = depNode.Priority;
                    if (depNode.Depth > maxDepDepth) maxDepDepth = depNode.Depth;
                }

                // 计算深度：基于依赖链最深处 + 1
                current.Depth = maxDepDepth + 1;

                // 检查优先级倒置：如果我的优先级比依赖项还小（或者相等），这虽然在拓扑排序中能跑通，
                // 但在语义上通常是错的（通常依赖项 Priority 数值更小，启动更早）。
                // Asaki 规则：Priority 越小越早。
                // 如果 DepPriority = 100, MyPriority = 50。
                // MyPriority < DepPriority，意味着我想在 50 启动，但必须等 100。
                // 这是一个倒置警告。
                // 正确情况：DepPriority (100) < MyPriority (200)。
                
                if (current.Dependencies.Count > 0 && current.Priority <= maxDepPriority)
                {
                    current.PriorityWarning = $"Priority ({current.Priority}) <= Dependency Max Priority ({maxDepPriority}).\nIdeally, dependent modules should have higher priority values (run later).";
                }
                // ------------------

                // 处理后续节点
                var sortedDependents = current.Dependents
                    .Select(t => _nodeMap[t])
                    .OrderBy(n => n.Priority); // 同级按 Priority 排

                foreach (var neighbor in sortedDependents)
                {
                    inDegree[neighbor.Type]--;
                    if (inDegree[neighbor.Type] == 0) queue.Enqueue(neighbor);
                }
            }

            if (_sortedNodes.Count != _nodeMap.Count && string.IsNullOrEmpty(_circularErrorMsg))
                _circularErrorMsg = "Circular dependency detected!";
        }

        // ... OpenScriptFile & UpdateScriptPriority 保持不变 ...
        private void OpenScriptFile(Type type)
        {
            string[] guids = AssetDatabase.FindAssets("t:script " + type.Name);
            if (guids.Length > 0)
            {
                string path = AssetDatabase.GUIDToAssetPath(guids[0]);
                var obj = AssetDatabase.LoadAssetAtPath<MonoScript>(path);
                AssetDatabase.OpenAsset(obj);
            }
        }

        private void UpdateScriptPriority(Type type, int newPriority)
        {
            string[] guids = AssetDatabase.FindAssets("t:script " + type.Name);
            if (guids.Length == 0) return;
            string fullPath = Path.GetFullPath(AssetDatabase.GUIDToAssetPath(guids[0]));
            try
            {
                string content = File.ReadAllText(fullPath);
                var regex = new Regex(@"\[AsakiModule\s*\(\s*(\d+)");
                if (regex.IsMatch(content))
                {
                    File.WriteAllText(fullPath, regex.Replace(content, m => m.Value.Replace(m.Groups[1].Value, newPriority.ToString())));
                    AssetDatabase.Refresh();
                }
            }
            catch (Exception ex) { Debug.LogError(ex); }
        }
    }
}```

<!-- File: Asaki/Editor/ModuleSystem/Graph/AsakiModuleGraphBuilder.cs -->
<!-- GUID: 83ae966d31e448c6bd62d9cb8d0f1b5c -->
<!-- Size: 3352 bytes -->
<!-- Modified: 2025-12-23 19:08:12 -->
```csharp
using Asaki.Core;
using Asaki.Core.Context;
using Asaki.Core.Graphs;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.ModuleSystem.Graph
{
    public static class AsakiModuleGraphBuilder
    {
        public static AsakiModuleGraph Build()
        {
            var graph = ScriptableObject.CreateInstance<AsakiModuleGraph>();
            graph.name = "Module Dependency Graph (Generated)";
            
            // 1. 扫描模块
            var moduleTypes = TypeCache.GetTypesDerivedFrom<IAsakiModule>()
                .Where(t => !t.IsAbstract && t.IsDefined(typeof(AsakiModuleAttribute), false))
                .ToList();

            var nodeMap = new Dictionary<Type, AsakiModuleNode>();
            
            // 2. 创建节点 (Nodes)
            // 简单布局：按 Priority 分层，或者直接网格排列，后续让 GraphView 自动布局
            int x = 0;
            int y = 0;
            int colWidth = 250;
            
            // 按优先级排序，方便视觉分层
            var sortedTypes = moduleTypes.OrderBy(t => t.GetCustomAttribute<AsakiModuleAttribute>().Priority).ToList();

            foreach (var type in sortedTypes)
            {
                var attr = type.GetCustomAttribute<AsakiModuleAttribute>();
                
                var node = new AsakiModuleNode
                {
                    GUID = Guid.NewGuid().ToString(),
                    Position = new Vector2(x, y),
                    ModuleName = type.Name,
                    Priority = attr.Priority
                };
                
                graph.Nodes.Add(node);
                nodeMap[type] = node;

                // 简单的自动换行布局
                x += colWidth;
                if (x > 1000)
                {
                    x = 0;
                    y += 150;
                }
            }

            // 3. 创建连线 (Edges)
            foreach (var type in sortedTypes)
            {
                var attr = type.GetCustomAttribute<AsakiModuleAttribute>();
                var sourceNode = nodeMap[type];

                foreach (var depType in attr.Dependencies)
                {
                    if (nodeMap.TryGetValue(depType, out var targetNode))
                    {
                        // 依赖关系: Source -> Dependency
                        // 即 Source 的 "Out" 连到 Dependency 的 "In"
                        // 或者是反过来？看你习惯。
                        // 通常依赖图是：使用者 -> 被使用者。
                        // AsakiPoolModule -> AsakiResKitModule
                        
                        var edge = new AsakiEdgeData
                        {
                            BaseNodeGUID = sourceNode.GUID,
                            BasePortName = "Out",       // 我依赖...
                            TargetNodeGUID = targetNode.GUID,
                            TargetPortName = "In"       // ...被依赖
                        };
                        graph.Edges.Add(edge);
                    }
                }
            }

            return graph;
        }
    }
}```

<!-- File: Asaki/Editor/ModuleSystem/Graph/AsakiModuleGraphController.cs -->
<!-- GUID: 1301b6a433744b9eb8cb6f63270c4945 -->
<!-- Size: 663 bytes -->
<!-- Modified: 2025-12-23 19:10:18 -->
```csharp
using Asaki.Editor.GraphEditors;
using UnityEngine.UIElements;

namespace Asaki.Editor.ModuleSystem.Graph
{
	[AsakiCustomGraphEditor(typeof(AsakiModuleGraph))]
	public class AsakiModuleGraphController : IAsakiGraphViewController
	{
		private AsakiModuleGraph _graph;
		public AsakiModuleGraphController(AsakiModuleGraph graph) => _graph = graph;

		public VisualElement CreateGraphView()
		{
			var view = new AsakiGraphView(_graph);
			// 禁用创建新节点，因为这是生成的图
			view.nodeCreationRequest = null; 
			return view;
		}
    
		public void Update() { }
		public void Save() { }
		public void Dispose() { }
	}
}
```

<!-- File: Asaki/Editor/ModuleSystem/Graph/AsakiModuleNode.cs -->
<!-- GUID: 2c9b151eec9c48308ee4afff71091958 -->
<!-- Size: 919 bytes -->
<!-- Modified: 2025-12-23 19:05:35 -->
```csharp
using Asaki.Core;
using Asaki.Core.Graphs;
using System;

namespace Asaki.Editor.ModuleSystem.Graph
{
	// 这是一个纯展示用的节点
	[Serializable]
	// 标记它属于 ModuleGraph 上下文
	[AsakiGraphContext(typeof(AsakiModuleGraph), "Module")] 
	public class AsakiModuleNode : AsakiNodeBase
	{
		public string ModuleName;
		public int Priority;
        
		// 我们利用 Port 机制来显示连线
		// "In" 表示谁依赖我 (Dependents)
		[AsakiNodeInput("In", Multiple = true)]
		public AsakiFlowPort Input;

		// "Out" 表示我依赖谁 (Dependencies)
		[AsakiNodeOutput("Out", Multiple = true)]
		public AsakiFlowPort Output;

		public override string Title => $"{ModuleName} ({Priority})";
	}
    
	// 这是一个虚拟的图类型，用于区分上下文
	public class AsakiModuleGraph : AsakiGraphBase { }
    
	[Serializable] public struct AsakiFlowPort { }
}
```

<!-- File: Asaki/Editor/PropertyDrawers/AsakiPropertyDrawer.cs -->
<!-- GUID: dd9311e04d4c4a5581c5d825490645f2 -->
<!-- Size: 1227 bytes -->
<!-- Modified: 2025-12-22 16:39:54 -->
```csharp
using Asaki.Core.MVVM;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.PropertyDrawers
{
	[CustomPropertyDrawer(typeof(AsakiProperty<>))]
	public class AsakiPropertyDrawer : PropertyDrawer
	{
		// 对应 Core 层中变量的名字
		private const string FieldName = "_value"; 

		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(position, label, property);
            
			// 查找内部的 _value 字段
			SerializedProperty valueProp = property.FindPropertyRelative(FieldName);

			if (valueProp != null)
			{
				// 使用 includeChildren=true 以支持 Vector3/Struct 等复杂类型
				EditorGUI.PropertyField(position, valueProp, label, true);
			}
			else
			{
				EditorGUI.LabelField(position, label.text, "Error: serialization mismatch");
			}

			EditorGUI.EndProperty();
		}

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			SerializedProperty valueProp = property.FindPropertyRelative(FieldName);
			return valueProp != null 
				? EditorGUI.GetPropertyHeight(valueProp, label, true) 
				: EditorGUIUtility.singleLineHeight;
		}
	}
}
```

<!-- File: Asaki/Editor/UI/AsakiUIGeneratorWindow.cs -->
<!-- GUID: f3ab1cbc9f8b4c99b4cc30fc23c6b305 -->
<!-- Size: 15722 bytes -->
<!-- Modified: 2025-12-22 16:43:08 -->
```csharp
using Asaki.Core.UI;
using Asaki.Unity;
using Asaki.Unity.Configuration;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.UI
{
    public class AsakiUIGeneratorWindow : EditorWindow
    {
        // ================= 配置区域 =================
        private const string CODE_GEN_PATH = "Assets/Asaki/Generated/UIID.cs";
        private const string CONFIG_ASSET_PATH = "Assets/Resources/Asaki/Configuration/AsakiUIConfig.asset";
        // ===========================================

        [System.Serializable]
        private class UIItem
        {
            public GameObject Prefab;
            public AsakiUILayer Layer = AsakiUILayer.Normal;
            public string EnumName;
            
            // [新增] 自定义加载路径 (Addressable Key 或 Resources Path)
            public string LoadPath; 
            
            public bool HasConflict;

            public UIItem(GameObject prefab, string overridePath = null)
            {
                Prefab = prefab;
                RefreshName();

                if (!string.IsNullOrEmpty(overridePath))
                {
                    LoadPath = overridePath;
                }
                else
                {
                    // 默认智能路径生成逻辑
                    string rawPath = AssetDatabase.GetAssetPath(prefab);
                    if (rawPath.Contains("/Resources/"))
                    {
                        // 如果在 Resources 下，自动裁剪为 Resources 加载路径
                        string ext = Path.GetExtension(rawPath);
                        int resIndex = rawPath.IndexOf("/Resources/") + 11;
                        LoadPath = rawPath.Substring(resIndex).Replace(ext, "");
                    }
                    else
                    {
                        // 否则使用 AssetPath (Addressable 默认通常是路径，用户可手动改)
                        LoadPath = rawPath;
                    }
                }
            }

            public void RefreshName()
            {
                if (Prefab != null)
                    EnumName = SanitizeName(Prefab.name);
            }
        }

        private List<UIItem> _items = new List<UIItem>();
        private Vector2 _scrollPos;
        private bool _hasGlobalConflict = false;

        [MenuItem("Asaki/UI/UI Generator Window")]
        public static void OpenWindow()
        {
            var window = GetWindow<AsakiUIGeneratorWindow>("Asaki UI Gen");
            window.minSize = new Vector2(600, 400); // 加宽窗口以容纳路径编辑
            window.Show();
            window.LoadCurrentConfig(); 
        }

        private void OnGUI()
        {
            DrawToolbar();
            DrawDragDropArea();
            DrawList();
            DrawFooter();
        }

        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            if (GUILayout.Button("Load From Configuration", EditorStyles.toolbarButton))
            {
                LoadCurrentConfig();
            }
            if (GUILayout.Button("Clear All", EditorStyles.toolbarButton))
            {
                _items.Clear();
                _hasGlobalConflict = false;
            }
            GUILayout.FlexibleSpace();
            EditorGUILayout.EndHorizontal();
        }

        private void DrawDragDropArea()
        {
            Event evt = Event.current;
            Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));
            GUI.Box(dropArea, "Drag UI Prefabs or Folders Here", EditorStyles.helpBox);

            if (evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform)
            {
                if (!dropArea.Contains(evt.mousePosition)) return;

                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;

                if (evt.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();
                    foreach (Object draggedTask in DragAndDrop.objectReferences)
                    {
                        AddObject(draggedTask);
                    }
                    ValidateConflicts();
                }
                Event.current.Use();
            }
        }

        private void AddObject(Object obj)
        {
            string path = AssetDatabase.GetAssetPath(obj);

            if (Directory.Exists(path))
            {
                string[] guids = AssetDatabase.FindAssets("t:Prefab", new[] { path });
                foreach (string guid in guids)
                {
                    string assetPath = AssetDatabase.GUIDToAssetPath(guid);
                    GameObject go = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath);
                    if (go != null) AddSingleItem(go);
                }
            }
            else if (obj is GameObject go)
            {
                if (PrefabUtility.IsPartOfPrefabAsset(obj))
                {
                    AddSingleItem(go);
                }
            }
        }

        private void AddSingleItem(GameObject go)
        {
            if (_items.Any(x => x.Prefab == go)) return;
            _items.Add(new UIItem(go));
        }

        private void DrawList()
        {
            EditorGUILayout.LabelField($"Total Items: {_items.Count}", EditorStyles.boldLabel);
            
            // 表头
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Prefab", EditorStyles.boldLabel, GUILayout.Width(150));
            EditorGUILayout.LabelField("Generated Enum", EditorStyles.boldLabel, GUILayout.Width(180));
            EditorGUILayout.LabelField("Load Path (Key)", EditorStyles.boldLabel, GUILayout.Width(200)); // [新增]
            EditorGUILayout.LabelField("Layer", EditorStyles.boldLabel, GUILayout.Width(80));
            EditorGUILayout.EndHorizontal();

            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            
            for (int i = 0; i < _items.Count; i++)
            {
                var item = _items[i];
                if (item.Prefab == null) continue;

                GUI.backgroundColor = item.HasConflict ? new Color(1f, 0.5f, 0.5f) : Color.white;
                
                EditorGUILayout.BeginHorizontal("box");
                
                // 1. Prefab 对象引用
                EditorGUI.BeginChangeCheck();
                GameObject newPrefab = (GameObject)EditorGUILayout.ObjectField(item.Prefab, typeof(GameObject), false, GUILayout.Width(150));
                if (EditorGUI.EndChangeCheck())
                {
                    item.Prefab = newPrefab;
                    item.RefreshName();
                    ValidateConflicts();
                }

                // 2. Enum 名称显示
                EditorGUILayout.LabelField(item.EnumName, GUILayout.Width(180));

                // 3. [新增] Load Path 编辑框 (支持 Addressable Key 修改)
                item.LoadPath = EditorGUILayout.TextField(item.LoadPath, GUILayout.Width(200));

                // 4. Layer 选择
                item.Layer = (AsakiUILayer)EditorGUILayout.EnumPopup(item.Layer, GUILayout.Width(80));

                // 5. 删除按钮
                GUI.backgroundColor = Color.red;
                if (GUILayout.Button("X", GUILayout.Width(20)))
                {
                    _items.RemoveAt(i);
                    ValidateConflicts();
                    i--;
                }
                GUI.backgroundColor = Color.white;

                EditorGUILayout.EndHorizontal();
            }

            EditorGUILayout.EndScrollView();
            
            if (_hasGlobalConflict)
            {
                EditorGUILayout.HelpBox("Duplicate Enum Names detected! Please rename your prefabs or remove duplicates.", MessageType.Error);
            }
        }

        private void DrawFooter()
        {
            GUILayout.Space(10);
            GUI.enabled = !_hasGlobalConflict && _items.Count > 0;
            
            // 按钮文字改为 "Sync & Generate" 以体现同步功能
            if (GUILayout.Button("Sync Configuration & Generate Code", GUILayout.Height(40)))
            {
                SyncAndGenerate();
            }
            GUI.enabled = true;
        }

        // ================= 逻辑区域 =================

        private void ValidateConflicts()
        {
            _hasGlobalConflict = false;
            var nameCount = new Dictionary<string, int>();

            foreach (var item in _items)
            {
                if (item.Prefab == null) continue;
                item.RefreshName();
                if (!nameCount.ContainsKey(item.EnumName)) nameCount[item.EnumName] = 0;
                nameCount[item.EnumName]++;
            }

            foreach (var item in _items)
            {
                if (item.Prefab == null) continue;
                bool isConflict = nameCount[item.EnumName] > 1;
                item.HasConflict = isConflict;
                if (isConflict) _hasGlobalConflict = true;
            }
        }

        private void SyncAndGenerate()
        {
            try
            {
                EditorUtility.DisplayProgressBar("Asaki UI Gen", "Processing...", 0.5f);

                // 1. 获取或创建配置
                AsakiUIConfig config = LoadOrCreateConfig();

                // 2. 生成 C# 枚举代码
                GenerateCode(_items);

                // 3. 同步数据到 ScriptableObject (包含手动修改后的 Path)
                UpdateConfigData(config, _items);

                // 4. 刷新 AssetDatabase
                AssetDatabase.Refresh();
                EditorUtility.DisplayDialog("Success", $"Synced {_items.Count} items to Configuration & UIID.cs", "OK");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"[AsakiUI] Failed: {e.Message}");
            }
            finally
            {
                EditorUtility.ClearProgressBar();
            }
        }

        private static void GenerateCode(List<UIItem> items)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// This file is generated by AsakiUIGeneratorWindow.");
            sb.AppendLine();
            sb.AppendLine("namespace Asaki.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public enum UIID");
            sb.AppendLine("    {");
            sb.AppendLine("        None = 0,");

            foreach (var item in items.OrderBy(x => x.EnumName))
            {
                int id = Animator.StringToHash(item.EnumName);
                sb.AppendLine($"        {item.EnumName} = {id},");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            WriteFile(CODE_GEN_PATH, sb.ToString());
        }

        private static void UpdateConfigData(AsakiUIConfig config, List<UIItem> items)
        {
            config.UIList.Clear();
            foreach (var item in items.OrderBy(x => x.EnumName))
            {
                config.UIList.Add(new UIInfo
                {
                    Name = item.EnumName,
                    ID = Animator.StringToHash(item.EnumName),
                    Layer = item.Layer,
                    AssetPath = item.LoadPath // [关键] 保存用户编辑过的路径
                });
            }
            EditorUtility.SetDirty(config);
            AssetDatabase.SaveAssets();
        }

        private static AsakiUIConfig LoadOrCreateConfig()
        {
            AsakiUIConfig config = AssetDatabase.LoadAssetAtPath<AsakiUIConfig>(CONFIG_ASSET_PATH);
            if (config == null)
            {
                config = ScriptableObject.CreateInstance<AsakiUIConfig>();
                string dir = Path.GetDirectoryName(CONFIG_ASSET_PATH);
                if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
                AssetDatabase.CreateAsset(config, CONFIG_ASSET_PATH);
            }
            return config;
        }

        private void LoadCurrentConfig()
        {
            AsakiUIConfig config = AssetDatabase.LoadAssetAtPath<AsakiUIConfig>(CONFIG_ASSET_PATH);
            if (config == null) return;

            _items.Clear();
            foreach (var info in config.UIList)
            {
                // 尝试反向查找 Prefab，用于编辑器显示
                // 逻辑：如果 info.AssetPath 是完整路径，直接加载
                // 如果是 Addressable Key，我们可能找不到 Prefab，
                // 但为了列表不丢失数据，我们尽量尝试在项目中按名称搜索
                
                GameObject prefab = null;
                string searchPath = info.AssetPath;

                // 1. 尝试作为绝对路径加载
                prefab = AssetDatabase.LoadAssetAtPath<GameObject>(searchPath);
                
                // 2. 如果是 Resources 短路径，尝试还原
                if (prefab == null)
                {
                     prefab = AssetDatabase.LoadAssetAtPath<GameObject>("Assets/Resources/" + searchPath + ".prefab");
                }

                // 3. 如果还是找不到 (比如是自定义 Key "Inventory"), 尝试全局搜索同名 Prefab
                if (prefab == null && !searchPath.Contains("/"))
                {
                     string[] guids = AssetDatabase.FindAssets(searchPath + " t:Prefab");
                     if (guids.Length > 0)
                     {
                         // 取第一个匹配的，风险是可能匹配错，但好过丢失
                         prefab = AssetDatabase.LoadAssetAtPath<GameObject>(AssetDatabase.GUIDToAssetPath(guids[0]));
                     }
                }

                if (prefab != null)
                {
                    _items.Add(new UIItem(prefab, info.AssetPath) // 传入配置中保存的 Path
                    {
                        Layer = info.Layer,
                        // EnumName 会在构造函数中刷新
                    });
                }
                else
                {
                    Debug.LogWarning($"[AsakiUI] Could not find prefab for config ID: {info.Name} (Path: {info.AssetPath}). Item skipped in editor list.");
                }
            }
            ValidateConflicts();
        }

        private static string SanitizeName(string rawName)
        {
            string name = rawName.Replace(" ", "_")
                                 .Replace("-", "_")
                                 .Replace(".", "_")
                                 .Replace("(", "")
                                 .Replace(")", "");
            if (char.IsDigit(name[0])) name = "UI_" + name;
            return name;
        }

        private static void WriteFile(string path, string content)
        {
            string dir = Path.GetDirectoryName(path);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            File.WriteAllText(path, content, Encoding.UTF8);
        }
    }
}```

<!-- File: Asaki/Editor/UI/AsakiUIPanel.cs -->
<!-- GUID: 1abc92a3dff84acab4c4f64868b52115 -->
<!-- Size: 2165 bytes -->
<!-- Modified: 2025-12-22 16:40:16 -->
```csharp
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.UI
{
    public class AsakiUIPanel : EditorWindow
    {
        [MenuItem("Asaki/Tools/Layout Panel", false, 1)]
        public static void ShowWindow()
        {
            var win = GetWindow<AsakiUIPanel>("UI Ops");
            win.minSize = new Vector2(200, 100);
        }

        private void OnGUI()
        {
            GUILayout.Label("Quick Anchors", EditorStyles.boldLabel);
            
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("Fill (全屏)", GUILayout.Height(30))) ApplyPreset(AsakiUITools.FillParent);
            if (GUILayout.Button("Snap (吸附)", GUILayout.Height(30))) AsakiUITools.SnapAnchors();
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            if (GUILayout.Button("Top", GUILayout.Height(25))) ApplyPreset(AsakiUITools.TopStretch);
            if (GUILayout.Button("Center", GUILayout.Height(25))) ApplyPreset(AsakiUITools.CenterAndZero);
            GUILayout.EndHorizontal();
            
            GUILayout.Space(10);
            GUILayout.Label("Alignment", EditorStyles.boldLabel);
            
            // 这里可以添加“左对齐”、“右对齐”等功能，原理就是修改 anchoredPosition
            if (GUILayout.Button("Align X (Reset)", GUILayout.Height(20)))
            {
                foreach(var go in Selection.gameObjects)
                {
                    var rt = go.GetComponent<RectTransform>();
                    if(rt) {
                        Undo.RecordObject(rt, "Align X");
                        rt.anchoredPosition = new Vector2(0, rt.anchoredPosition.y);
                    }
                }
            }
        }

        // 包装一下之前的 ContextMenu 方法调用
        private void ApplyPreset(System.Action<UnityEditor.MenuCommand> action)
        {
            foreach (var go in Selection.gameObjects)
            {
                var rt = go.GetComponent<RectTransform>();
                if (rt) action(new MenuCommand(rt));
            }
        }
    }
}```

<!-- File: Asaki/Editor/UI/AsakiUIScaffolder.cs -->
<!-- GUID: 42632971648c448b938c58abd0c80f57 -->
<!-- Size: 8016 bytes -->
<!-- Modified: 2025-12-22 16:40:16 -->
```csharp
using Asaki.Core;
using Asaki.Core.UI;
using Asaki.Unity;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.UI
{
	public static class AsakiUIScaffolder
	{
		private const string CONFIG_PATH = "Assets/Resources/Asaki/Configuration/AsakiUITemplateConfig.asset";

		// =========================================================
		// 入口 1: 从 Project 窗口的脚本直接生成 (新需求)
		// =========================================================
		[MenuItem("Assets/Asaki/Scaffold UI Object", false, 10)]
		public static void CreateUIFromScript()
		{
			// 1. 校验选中项是否为 C# 脚本
			MonoScript script = Selection.activeObject as MonoScript;
			if (script == null)
			{
				Debug.LogWarning("[AsakiUI] Please select a C# script.");
				return;
			}

			System.Type type = script.GetClass();
			if (type == null || !type.IsSubclassOf(typeof(MonoBehaviour)))
			{
				EditorUtility.DisplayDialog("Error", "Selected script must inherit from MonoBehaviour (or AsakiUIWindow).", "OK");
				return;
			}

			// 2. 寻找放置环境 (Canvas)
			Transform canvasTransform = GetActiveCanvasTransform();

			// 3. 创建根对象
			GameObject root = new GameObject(type.Name);
			if (canvasTransform != null)
			{
				root.transform.SetParent(canvasTransform, false);
			}

			// 4. 挂载脚本
			root.AddComponent(type);

			// 注册撤销
			Undo.RegisterCreatedObjectUndo(root, "Create UI from Script");

			// 5. 执行核心生成逻辑
			ProcessScaffolding(root);

			// 6. 选中新生成的对象
			Selection.activeGameObject = root;
		}

		// =========================================================
		// 入口 2: 从 Hierarchy 中选中的 GameObject 生成 (旧功能)
		// =========================================================
		[MenuItem("Asaki/UI/Scaffold UI from GameObject", false, 20)]
		public static void ScaffoldFromScene()
		{
			GameObject root = Selection.activeGameObject;
			if (root == null)
			{
				EditorUtility.DisplayDialog("Error", "Please select a UI Root GameObject.", "OK");
				return;
			}
			ProcessScaffolding(root);
		}

		public static void ScaffoldFromTarget(MonoBehaviour target)
		{
			ProcessScaffolding(target.gameObject);
		}

		// =========================================================
		// 核心生成逻辑 (复用)
		// =========================================================
		private static void ProcessScaffolding(GameObject root)
		{
			MonoBehaviour[] scripts = root.GetComponents<MonoBehaviour>();
			if (scripts.Length == 0) return;
			MonoBehaviour targetScript = scripts[0];
			System.Type type = targetScript.GetType();

			AsakiUITemplateConfig config = AssetDatabase.LoadAssetAtPath<AsakiUITemplateConfig>(CONFIG_PATH);
			if (config == null)
			{
				EditorUtility.DisplayDialog("Error", $"Configuration not found at {CONFIG_PATH}", "OK");
				return;
			}

			// 确保 Root 名称一致性
			if (root.name != type.Name)
			{
				Undo.RecordObject(root, "Rename UI Root");
				root.name = type.Name;
			}

			// 确保有 RectTransform
			if (root.GetComponent<RectTransform>() == null) root.AddComponent<RectTransform>();

			// 1. 收集字段与属性
			var fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			var buildList = new List<BuildItem>();

			foreach (var field in fields)
			{
				var attr = field.GetCustomAttribute<AsakiUIBuilderAttribute>();
				if (attr != null)
				{
					buildList.Add(new BuildItem { Field = field, Attr = attr });
				}
			}

			// 2. 排序 (Order 越小越先生成 -> 被压在下面; Order 越大越后生成 -> 浮在上面)
			var sortedList = buildList.OrderBy(x => x.Attr.Order).ToList();

			// 3. 循环生成
			foreach (var item in sortedList)
			{
				var field = item.Field;
				var attr = item.Attr;

				// 解析名称
				string nodeName = !string.IsNullOrEmpty(attr.Name) ? attr.Name : SanitizeFieldName(field.Name);

				// 解析容器
				Transform container = root.transform;
				if (!string.IsNullOrEmpty(attr.Parent))
				{
					container = GetOrCreateContainer(root.transform, attr.Parent);
				}

				// 检查已存在
				Transform existing = container.Find(nodeName);
				if (existing != null)
				{
					// 仅更新顺序和引用
					existing.SetAsLastSibling();
					AssignReference(field, targetScript, existing.gameObject);
					continue;
				}

				// 实例化
				GameObject prefab = null;
				if (attr.Type == AsakiUIWidgetType.Custom)
				{
					Debug.LogWarning($"[AsakiUI] Custom prefab loading not implemented for {nodeName}");
					continue;
				}
				else
				{
					prefab = config.GetTemplate(attr.Type);
				}

				if (prefab != null)
				{
					GameObject instance = (GameObject)PrefabUtility.InstantiatePrefab(prefab, container);
					instance.name = nodeName;

					RectTransform rect = instance.GetComponent<RectTransform>();
					if (rect != null)
					{
						rect.anchoredPosition3D = Vector3.zero;
						rect.localScale = Vector3.one;
					}

					instance.transform.SetAsLastSibling(); // 确保 Order 生效
					AssignReference(field, targetScript, instance);

					// 注册撤销 (InstantiatePrefab 内部已处理部分，但 SetParent 等可能需要)
					Undo.RegisterCreatedObjectUndo(instance, "Create UI Widget");
				}
			}

			Debug.Log($"[AsakiUI] Scaffolding complete for {root.name}");
		}

		// =========================================================
		// 辅助方法
		// =========================================================

		private class BuildItem
		{
			public FieldInfo Field;
			public AsakiUIBuilderAttribute Attr;
		}

		private static Transform GetActiveCanvasTransform()
		{
			// 优先找当前选中的 Canvas
			if (Selection.activeGameObject != null)
			{
				Canvas c = Selection.activeGameObject.GetComponentInParent<Canvas>();
				if (c != null) return c.transform;
			}
			// 否则找场景里第一个 Canvas
			Canvas canvas = Object.FindFirstObjectByType<Canvas>();
			return canvas != null ? canvas.transform : null;
		}

		private static string SanitizeFieldName(string fieldName)
		{
			string name = fieldName;
			if (name.StartsWith("_")) name = name.Substring(1);
			if (name.Length > 0) name = char.ToUpper(name[0]) + name.Substring(1);
			return name;
		}

		private static Transform GetOrCreateContainer(Transform root, string path)
		{
			string[] parts = path.Split('/');
			Transform current = root;

			foreach (var part in parts)
			{
				if (string.IsNullOrEmpty(part)) continue;

				Transform child = current.Find(part);
				if (child == null)
				{
					GameObject go = new GameObject(part, typeof(RectTransform));
					go.transform.SetParent(current, false);

					RectTransform rect = go.GetComponent<RectTransform>();
					rect.anchorMin = Vector2.zero;
					rect.anchorMax = Vector2.one;
					rect.offsetMin = Vector2.zero;
					rect.offsetMax = Vector2.zero;
					rect.localScale = Vector3.one;

					child = go.transform;
					Undo.RegisterCreatedObjectUndo(go, "Create UI Container");
				}
				current = child;
			}
			return current;
		}

		private static void AssignReference(FieldInfo field, MonoBehaviour script, GameObject instance)
		{
			if (IsSerialized(field))
			{
				Component comp = instance.GetComponent(field.FieldType);
				if (comp != null)
				{
					field.SetValue(script, comp);
					EditorUtility.SetDirty(script);
				}
				else if (field.FieldType == typeof(GameObject))
				{
					field.SetValue(script, instance);
					EditorUtility.SetDirty(script);
				}
			}
		}

		private static bool IsSerialized(FieldInfo field)
		{
			return field.IsPublic || field.GetCustomAttribute<SerializeField>() != null;
		}
	}
}
```

<!-- File: Asaki/Editor/UI/AsakiUITools.cs -->
<!-- GUID: 332c64fca7804a9a83aa1136b42c31ae -->
<!-- Size: 4461 bytes -->
<!-- Modified: 2025-12-22 16:40:16 -->
```csharp
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.UI
{
    /// <summary>
    /// Asaki UI 生产力工具
    /// 提供行业标准的快速布局功能，替代手动计算锚点。
    /// </summary>
    public static class AsakiUITools
    {
        // =========================================================
        // 1. 核心神器：智能锚点吸附 (Snap Anchors to Corners)
        // 行业痛点：手动拖拽 UI 到合适位置后，需要繁琐地计算 Anchor Min/Max 才能适配分辨率。
        // 解决方案：一键将 Anchor 吸附到当前 UI 的四个角，瞬间完成适配设置。
        // 快捷键：Alt + Shift + A
        // =========================================================
        
        [MenuItem("Asaki/Tools/Snap Anchors to Corners &#a")] // & = Alt, # = Shift
        public static void SnapAnchors()
        {
            foreach (GameObject go in Selection.gameObjects)
            {
                RectTransform rt = go.GetComponent<RectTransform>();
                if (rt == null) continue;
                
                Undo.RecordObject(rt, "Snap Anchors");
                SnapAnchorsToCorners(rt);
            }
        }

        // =========================================================
        // 2. 常用布局预设 (右键 RectTransform 组件菜单)
        // =========================================================

        [MenuItem("CONTEXT/RectTransform/Asaki - Fill Parent (全屏拉伸)")]
        public static void FillParent(MenuCommand command)
        {
            RectTransform rt = (RectTransform)command.context;
            Undo.RecordObject(rt, "Fill Parent");

            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
            rt.localScale = Vector3.one;
        }

        [MenuItem("CONTEXT/RectTransform/Asaki - Center & Zero (居中归零)")]
        public static void CenterAndZero(MenuCommand command)
        {
            RectTransform rt = (RectTransform)command.context;
            Undo.RecordObject(rt, "Center Zero");

            rt.anchorMin = new Vector2(0.5f, 0.5f);
            rt.anchorMax = new Vector2(0.5f, 0.5f);
            rt.pivot = new Vector2(0.5f, 0.5f);
            rt.anchoredPosition = Vector2.zero;
            rt.localScale = Vector3.one;
        }

        [MenuItem("CONTEXT/RectTransform/Asaki - Top Stretch (顶部吸附)")]
        public static void TopStretch(MenuCommand command)
        {
            RectTransform rt = (RectTransform)command.context;
            Undo.RecordObject(rt, "Top Stretch");
            
            // 保持当前高度
            float height = rt.rect.height;

            rt.anchorMin = new Vector2(0, 1);
            rt.anchorMax = new Vector2(1, 1);
            rt.pivot = new Vector2(0.5f, 1);
            rt.anchoredPosition = new Vector2(0, 0);
            rt.sizeDelta = new Vector2(0, height); // Width=0(Stretch), Height=Keep
        }

        // =========================================================
        // 内部算法
        // =========================================================

        private static void SnapAnchorsToCorners(RectTransform rt)
        {
            RectTransform parent = rt.parent as RectTransform;
            if (parent == null) return;

            // 获取当前 rect 的四个角在父级空间中的位置
            Vector2 offsetMin = rt.offsetMin;
            Vector2 offsetMax = rt.offsetMax;
            Vector2 anchorMin = rt.anchorMin;
            Vector2 anchorMax = rt.anchorMax;
            Vector2 parentSize = parent.rect.size;

            // 计算新的锚点 (归一化坐标 0~1)
            // 公式：NewAnchorMin = OldAnchorMin + (OffsetMin / ParentSize)
            Vector2 newAnchorMin = anchorMin + new Vector2(offsetMin.x / parentSize.x, offsetMin.y / parentSize.y);
            Vector2 newAnchorMax = anchorMax + new Vector2(offsetMax.x / parentSize.x, offsetMax.y / parentSize.y);

            // 应用新锚点
            rt.anchorMin = newAnchorMin;
            rt.anchorMax = newAnchorMax;

            // 归零 Offset (因为锚点已经移动到了边缘)
            rt.offsetMin = Vector2.zero;
            rt.offsetMax = Vector2.zero;
        }
    }
}```

<!-- File: Asaki/Editor/UI/AsakiUIWindowEditor.cs -->
<!-- GUID: 0cdf28064c6b4dde87ae560804e68f5d -->
<!-- Size: 2821 bytes -->
<!-- Modified: 2025-12-22 16:47:28 -->
```csharp
using Asaki.Core;
using Asaki.Unity;
using Asaki.Unity.Services.UI;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.UI
{
    // [关键] 对所有继承自 AsakiUIWindow 的脚本生效 (第二个参数 true)
    [CustomEditor(typeof(AsakiUIWindow), true)]
    public class AsakiUIWindowEditor : UnityEditor.Editor
    {
        private bool _showBindings = true;

        public override void OnInspectorGUI()
        {
            // 1. 绘制默认的脚本引用框
            DrawDefaultInspector();

            EditorGUILayout.Space(10);
            EditorGUILayout.LabelField("Asaki UI Dev Tools", EditorStyles.boldLabel);

            // 2. 核心功能：直接在 Inspector 触发 Scaffolder
            GUI.backgroundColor = Color.green;
            if (GUILayout.Button("♻️ Sync & Re-Scaffold UI", GUILayout.Height(30)))
            {
                // 调用现有的逻辑 (需要把 ProcessScaffolding 改为 public 或通过反射调用)
                // 这里我们假设把它改为了 public static
                AsakiUIScaffolder.ScaffoldFromTarget((AsakiUIWindow)target);
            }
            GUI.backgroundColor = Color.white;

            // 3. 可视化绑定状态 (Dashboard)
            _showBindings = EditorGUILayout.Foldout(_showBindings, "Bindings Status");
            if (_showBindings)
            {
                DrawBindingStatus();
            }
        }

        private void DrawBindingStatus()
        {
            var targetScript = (MonoBehaviour)target;
            var fields = targetScript.GetType()
                .GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                .Where(f => f.GetCustomAttribute<AsakiUIBuilderAttribute>() != null);

            EditorGUI.indentLevel++;
            foreach (var field in fields)
            {
                var attr = field.GetCustomAttribute<AsakiUIBuilderAttribute>();
                var value = field.GetValue(targetScript) as Object;

                EditorGUILayout.BeginHorizontal();
                
                // 状态图标
                if (value != null) 
                    GUILayout.Label("✅", GUILayout.Width(20));
                else 
                    GUILayout.Label("❌", GUILayout.Width(20));

                // 字段名 + 预期类型
                EditorGUILayout.LabelField($"{field.Name} ({attr.Type})", EditorStyles.miniLabel);
                
                // 当前引用对象 (只读显示)
                EditorGUILayout.ObjectField(value, typeof(Object), true);

                EditorGUILayout.EndHorizontal();
            }
            EditorGUI.indentLevel--;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Extensions/AsakiUIExtensions.cs -->
<!-- GUID: c692c59a9b3c444f9976ea59dbb642cf -->
<!-- Size: 2982 bytes -->
<!-- Modified: 2025-12-22 16:40:40 -->
```csharp
using UnityEngine.UIElements;

namespace Asaki.Editor.Utilities.Extensions
{
    public static class AsakiUIExtensions
    {
        // =========================================================
        // Padding 拓展
        // =========================================================
        
        /// <summary>
        /// 一键设置所有方向的 Padding
        /// </summary>
        public static void SetPadding(this IStyle style, float value)
        {
            style.paddingLeft = value;
            style.paddingRight = value;
            style.paddingTop = value;
            style.paddingBottom = value;
        }

        /// <summary>
        /// 分别设置水平和垂直 Padding
        /// </summary>
        public static void SetPadding(this IStyle style, float horizontal, float vertical)
        {
            style.paddingLeft = horizontal;
            style.paddingRight = horizontal;
            style.paddingTop = vertical;
            style.paddingBottom = vertical;
        }

        // =========================================================
        // Margin 拓展
        // =========================================================

        /// <summary>
        /// 一键设置所有方向的 Margin
        /// </summary>
        public static void SetMargin(this IStyle style, float value)
        {
            style.marginLeft = value;
            style.marginRight = value;
            style.marginTop = value;
            style.marginBottom = value;
        }
        
        /// <summary>
        /// 分别设置水平和垂直 Margin
        /// </summary>
        public static void SetMargin(this IStyle style, float horizontal, float vertical)
        {
            style.marginLeft = horizontal;
            style.marginRight = horizontal;
            style.marginTop = vertical;
            style.marginBottom = vertical;
        }

        // =========================================================
        // Border Radius 拓展
        // =========================================================
        
        /// <summary>
        /// 一键设置圆角
        /// </summary>
        public static void SetRadius(this IStyle style, float value)
        {
            style.borderTopLeftRadius = value;
            style.borderTopRightRadius = value;
            style.borderBottomLeftRadius = value;
            style.borderBottomRightRadius = value;
        }

        // =========================================================
        // Border Width 拓展
        // =========================================================
        
        public static void SetBorderWidth(this IStyle style, float value)
        {
            style.borderLeftWidth = value;
            style.borderRightWidth = value;
            style.borderTopWidth = value;
            style.borderBottomWidth = value;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Extensions/GUILayoutExtensions.cs -->
<!-- GUID: 369035e525d7497e83b08027cd403ff1 -->
<!-- Size: 3986 bytes -->
<!-- Modified: 2025-12-22 16:40:38 -->
```csharp
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Extensions
{
    public static class GUILayoutExtensions
    {
        private static readonly Color SplitterColor = new Color(0.3f, 0.3f, 0.3f, 1f);
        private const float SplitterWidth = 3f;
        private static bool _isDragging;

        /// <summary>
        /// 可拖拽的分隔条，支持精确的min/max限制
        /// </summary>
        /// <param name="value">被控制的宽度值</param>
        /// <param name="minWidth">最小宽度</param>
        /// <param name="maxWidth">最大宽度</param>
        /// <param name="reverseDirection">是否反转拖拽方向（用于右侧分割条）</param>
        /// <param name="onDrag">拖拽回调</param>
        public static void Splitter(ref float value, float minWidth, float maxWidth, 
            bool reverseDirection = false, System.Action onDrag = null)
        {
            // 创建一个可视化的Box元素，正确参与自动布局流程
            GUILayout.Box(GUIContent.none, GUIStyle.none, 
                GUILayout.Width(SplitterWidth), 
                GUILayout.ExpandHeight(true));
            
            // 获取该元素实际占用的矩形区域（在绘制后立即获取，位置准确）
            Rect splitterRect = GUILayoutUtility.GetLastRect();

            // 绘制视觉分隔线
            EditorGUI.DrawRect(splitterRect, SplitterColor);

            // 扩展拖拽区域，使鼠标更容易捕捉（左右各扩展2像素）
            Rect dragRect = new Rect(
                splitterRect.x - 2f,
                splitterRect.y,
                splitterRect.width + 4f,
                splitterRect.height
            );

            // 设置鼠标悬停时的光标样式
            EditorGUIUtility.AddCursorRect(dragRect, MouseCursor.ResizeHorizontal);

            // 获取控件ID，用于事件处理
            int controlID = GUIUtility.GetControlID(FocusType.Passive);
            Event currentEvent = Event.current;

            // 处理鼠标事件
            switch (currentEvent.type)
            {
                case EventType.MouseDown:
                    if (dragRect.Contains(currentEvent.mousePosition) && currentEvent.button == 0)
                    {
                        _isDragging = true;
                        GUIUtility.hotControl = controlID;
                        currentEvent.Use();
                    }
                    break;

                case EventType.MouseUp:
                    if (_isDragging && GUIUtility.hotControl == controlID)
                    {
                        _isDragging = false;
                        GUIUtility.hotControl = 0;
                        currentEvent.Use();
                    }
                    break;

                case EventType.MouseDrag:
                    if (_isDragging && GUIUtility.hotControl == controlID)
                    {
                        float deltaX = currentEvent.delta.x;
                        
                        // [修复] 对右侧分割条反转方向
                        if (reverseDirection)
                        {
                            deltaX = -deltaX;
                        }
                        
                        float newWidth = value + deltaX;

                        // 限制在最小/最大宽度范围内
                        newWidth = Mathf.Clamp(newWidth, minWidth, maxWidth);

                        // 只有当变化足够大时才更新，避免抖动
                        if (Mathf.Abs(newWidth - value) > 0.1f)
                        {
                            value = newWidth;
                            onDrag?.Invoke();
                        }

                        currentEvent.Use();
                    }
                    break;
            }
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Extensions/PrefabUtilityExtensions.cs -->
<!-- GUID: c4877e85d8824080b5cdcf61ea837836 -->
<!-- Size: 2555 bytes -->
<!-- Modified: 2025-12-24 23:22:39 -->
```csharp
// Assets/Editor/AssetReplacementTool/Utils/PrefabUtilityExtensions.cs

using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Extensions
{
    public static class PrefabUtilityExtensions
    {
        /// <summary>
        /// 安全地获取Prefab实例的Override列表
        /// </summary>
        public static PropertyModification[] GetSafePropertyModifications(GameObject instance)
        {
            if (instance == null) return null;
            
            try
            {
                return PrefabUtility.GetPropertyModifications(instance);
            }
            catch
            {
                // 某些情况下会抛出异常
                return null;
            }
        }

        /// <summary>
        /// 检查是否是Prefab实例（包括嵌套）
        /// </summary>
        public static bool IsPrefabInstance(this GameObject go)
        {
            return PrefabUtility.IsPartOfPrefabInstance(go);
        }

        /// <summary>
        /// 获取Prefab的核心源（跳过变体链）
        /// </summary>
        public static GameObject GetRootSourcePrefab(GameObject prefab)
        {
            if (!PrefabUtility.IsPartOfVariantPrefab(prefab)) return prefab;
            
            var basePrefab = PrefabUtility.GetCorrespondingObjectFromSource(prefab);
            return GetRootSourcePrefab(basePrefab as GameObject);
        }

        /// <summary>
        /// 复制组件的完整状态（包括私有字段）
        /// </summary>
        public static void CopyComponentState(Component source, Component target)
        {
            var sourceType = source.GetType();
            var targetType = target.GetType();
            
            if (sourceType != targetType) return;

            // 使用序列化方式复制
            var sourceSerialized = new SerializedObject(source);
            var targetSerialized = new SerializedObject(target);
            
            var prop = sourceSerialized.GetIterator();
            while (prop.Next(true))
            {
                if (prop.propertyPath == "m_Script") continue;
                
                var targetProp = targetSerialized.FindProperty(prop.propertyPath);
                if (targetProp != null)
                {
                    targetSerialized.CopyFromSerializedProperty(prop);
                }
            }
            
            targetSerialized.ApplyModifiedProperties();
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AsakiAudioGenerator.cs -->
<!-- GUID: 90029c746bf74a4d993eb95a60e2f4c5 -->
<!-- Size: 20301 bytes -->
<!-- Modified: 2025-12-25 15:36:47 -->
```csharp
using Asaki.Unity.Configuration;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools
{
    public class AsakiAudioDashboard : EditorWindow
    {
        // === 路径配置 ===
        private const string CONFIG_PATH = "Assets/Resources/Asaki/Configuration/AsakiAudioConfig.asset";
        private const string CODE_GEN_PATH = "Assets/Asaki/Generated/AudioID.cs";

        private AsakiAudioConfig _config;
        private Vector2 _scrollPos;
        private string _searchFilter = "";
        
        // === 播放器状态 ===
        private AudioSource _previewSource;
        private AudioItem _currentPlayingItem; // 当前正在操作的 Item
        private bool _isPaused;                // 当前是否处于暂停状态

        [MenuItem("Asaki/Audio/Audio Dashboard")]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiAudioDashboard>("Audio Dashboard");
            wnd.minSize = new Vector2(850, 600); // 稍微加宽一点以容纳 Slider
            wnd.Show();
        }

        private void OnEnable()
        {
            LoadConfig();
            InitAudioSource();
        }

        private void OnDisable()
        {
            StopPreview();
            if (_previewSource != null)
                DestroyImmediate(_previewSource.gameObject);
        }

        private void InitAudioSource()
        {
            if (_previewSource == null)
            {
                var go = EditorUtility.CreateGameObjectWithHideFlags("AsakiAudioPreview", HideFlags.HideAndDontSave, typeof(AudioSource));
                _previewSource = go.GetComponent<AudioSource>();
            }
        }

        private void OnGUI()
        {
            DrawHeader();
            
            if (_config == null)
            {
                DrawEmptyState();
                return;
            }

            DrawToolbar();
            DrawDropArea();
            DrawList();
            DrawFooter();
        }

        // ... (Header 和 EmptyState 保持不变，省略以节省篇幅，逻辑同上个版本) ...
        
        private void DrawHeader()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            GUILayout.Label("Asaki Audio Dashboard V5.1", EditorStyles.boldLabel);
            GUILayout.FlexibleSpace();
            if (GUILayout.Button("Force Refresh", EditorStyles.toolbarButton)) LoadConfig();
            EditorGUILayout.EndHorizontal();
        }

        private void DrawEmptyState()
        {
            EditorGUILayout.HelpBox($"Config not found at: {CONFIG_PATH}", MessageType.Error);
            if (GUILayout.Button("Create Config Asset")) CreateConfigAsset();
        }

        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            
            // 搜索
            GUILayout.Label("Search:", EditorStyles.miniLabel, GUILayout.Width(45));
            _searchFilter = EditorGUILayout.TextField(_searchFilter, EditorStyles.toolbarSearchField, GUILayout.Width(200));
            if (GUILayout.Button("X", EditorStyles.toolbarButton, GUILayout.Width(20))) _searchFilter = "";
            
            GUILayout.FlexibleSpace();
            
            // 排序
            if (GUILayout.Button("Sort by Name", EditorStyles.toolbarButton))
            {
                Undo.RecordObject(_config, "Sort Audio Items");
                _config.Items = _config.Items.OrderBy(x => x.Key).ToList();
                EditorUtility.SetDirty(_config);
            }
            
            // 停止所有 (紧急按钮)
            if (GUILayout.Button("■ Stop All", EditorStyles.toolbarButton))
            {
                StopPreview();
            }
            
            EditorGUILayout.EndHorizontal();
        }

        private void DrawDropArea()
        {
            Event evt = Event.current;
            Rect dropArea = GUILayoutUtility.GetRect(0.0f, 40.0f, GUILayout.ExpandWidth(true));
            GUI.Box(dropArea, "Drag AudioClips Here (Batch Add)", EditorStyles.helpBox);

            if (evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform)
            {
                if (!dropArea.Contains(evt.mousePosition)) return;

                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;

                if (evt.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();
                    Undo.RecordObject(_config, "Add Audio Clips");
                    foreach (Object draggedObj in DragAndDrop.objectReferences)
                    {
                        if (draggedObj is AudioClip clip) RegisterOrUpdateClip(clip);
                    }
                    EditorUtility.SetDirty(_config);
                }
                Event.current.Use();
            }
        }

        private void DrawList()
        {
            if (_config.Items == null) return;

            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            
            for (int i = 0; i < _config.Items.Count; i++)
            {
                var item = _config.Items[i];
                if (!string.IsNullOrEmpty(_searchFilter) && !item.Key.ToLower().Contains(_searchFilter.ToLower())) continue;

                DrawAudioItem(item, i);
            }

            EditorGUILayout.EndScrollView();
        }

        // =========================================================
        // 核心绘制逻辑 (优化版)
        // =========================================================
        private void DrawAudioItem(AudioItem item, int index)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            // === Top Row: Transport | Key | Clip | Group | Delete ===
            EditorGUILayout.BeginHorizontal();
            
            // [优化点 1] 播放控制区
            DrawTransportControls(item);

            // Key Name
            Color defaultColor = GUI.color;
            if (string.IsNullOrEmpty(item.Key)) GUI.color = Color.red;
            
            EditorGUI.BeginChangeCheck();
            string newKey = EditorGUILayout.TextField(item.Key, GUILayout.Width(180));
            if (EditorGUI.EndChangeCheck()) { Undo.RecordObject(_config, "Rename Key"); item.Key = newKey; }
            GUI.color = defaultColor;

            // Clip Reference
            EditorGUI.BeginChangeCheck();
            var newClip = (AudioClip)EditorGUILayout.ObjectField(item.Clip, typeof(AudioClip), false);
            if (EditorGUI.EndChangeCheck())
            {
                Undo.RecordObject(_config, "Change Clip");
                item.Clip = newClip;
                if(newClip != null) item.AssetPath = GetLoadPath(newClip);
            }

            // Group
            EditorGUI.BeginChangeCheck();
            var newGroup = (AsakiAudioGroup)EditorGUILayout.EnumPopup(item.Group, GUILayout.Width(60));
            if (EditorGUI.EndChangeCheck()) { Undo.RecordObject(_config, "Change Group"); item.Group = newGroup; }

            // [优化点 3] 时长显示
            string durationStr = item.Clip ? FormatDuration(item.Clip.length) : "--:--";
            GUILayout.Label(durationStr, EditorStyles.miniLabel, GUILayout.Width(35));

            // Expand
            item._editorExpanded = EditorGUILayout.Foldout(item._editorExpanded, "Edit", true);

            // Delete
            if (GUILayout.Button("X", GUILayout.Width(20)))
            {
                StopPreview(); // 删除前停止播放防止报错
                Undo.RecordObject(_config, "Remove Item");
                _config.Items.RemoveAt(index);
                EditorUtility.SetDirty(_config);
                EditorGUILayout.EndHorizontal();
                EditorGUILayout.EndVertical();
                return;
            }
            
            EditorGUILayout.EndHorizontal();

            // === Detail Row: Sliders & Flags ===
            if (item._editorExpanded)
            {
                DrawDetailRow(item);
            }

            EditorGUILayout.EndVertical();
        }

        private void DrawTransportControls(AudioItem item)
        {
            // 逻辑：
            // 如果这个 Item 是当前正在播放的：
            //    - 如果 Source 在播放 -> 显示 [暂停] [停止]
            //    - 如果 Source 暂停中 -> 显示 [恢复] [停止]
            // 如果不是当前播放的 -> 显示 [播放]

            bool isCurrent = _currentPlayingItem == item;
            bool isSourcePlaying = _previewSource != null && _previewSource.isPlaying;

            if (isCurrent)
            {
                if (isSourcePlaying)
                {
                    // 正在播放 -> 显示暂停
                    if (GUILayout.Button(EditorGUIUtility.IconContent("PauseButton"), GUILayout.Width(25), GUILayout.Height(20)))
                    {
                        PausePreview();
                    }
                }
                else if (_isPaused)
                {
                    // 暂停中 -> 显示恢复
                    if (GUILayout.Button(EditorGUIUtility.IconContent("PlayButton"), GUILayout.Width(25), GUILayout.Height(20)))
                    {
                        ResumePreview();
                    }
                }
                else
                {
                    // 异常状态 (停止了但标记还在)，重置为播放
                    if (GUILayout.Button(EditorGUIUtility.IconContent("PlayButton"), GUILayout.Width(25), GUILayout.Height(20)))
                    {
                        PlayPreview(item);
                    }
                }

                // 停止按钮 (总是显示)
                if (GUILayout.Button(EditorGUIUtility.IconContent("PreMatQuad"), GUILayout.Width(25), GUILayout.Height(20)))
                {
                    StopPreview();
                }
            }
            else
            {
                // 未播放状态 -> 只有播放按钮
                if (GUILayout.Button(EditorGUIUtility.IconContent("PlayButton"), GUILayout.Width(25), GUILayout.Height(20)))
                {
                    PlayPreview(item);
                }
                // 占位符保持对齐
                GUILayout.Space(29); 
            }
        }

        private void DrawDetailRow(AudioItem item)
        {
            EditorGUI.indentLevel++;
            EditorGUILayout.BeginHorizontal();
            
            // [优化点 2] 使用 Slider
            
            // Volume Slider
            GUILayout.Label("Vol", GUILayout.Width(25));
            float newVol = EditorGUILayout.Slider(item.Volume, 0f, 1f, GUILayout.Width(120));
            if (newVol != item.Volume)
            {
                Undo.RecordObject(_config, "Change Volume");
                item.Volume = newVol;
                // 实时更新正在播放的音量
                if (_currentPlayingItem == item && _previewSource != null) _previewSource.volume = newVol;
            }
            
            GUILayout.Space(10);

            // Pitch Slider
            GUILayout.Label("Pitch", GUILayout.Width(35));
            float newPitch = EditorGUILayout.Slider(item.Pitch, 0.1f, 3f, GUILayout.Width(120));
            if (newPitch != item.Pitch)
            {
                Undo.RecordObject(_config, "Change Pitch");
                item.Pitch = newPitch;
                // 实时更新正在播放的音高
                if (_currentPlayingItem == item && _previewSource != null) _previewSource.pitch = newPitch;
            }

            GUILayout.Space(10);

            // Flags
            bool newLoop = EditorGUILayout.ToggleLeft("Loop", item.Loop, GUILayout.Width(50));
            if (newLoop != item.Loop) { Undo.RecordObject(_config, "Change Loop"); item.Loop = newLoop; }

            bool newRnd = EditorGUILayout.ToggleLeft("Rnd Pitch", item.RandomPitch, GUILayout.Width(80));
            if (newRnd != item.RandomPitch) { Undo.RecordObject(_config, "Change RndPitch"); item.RandomPitch = newRnd; }

            EditorGUILayout.EndHorizontal();
            
            // 显示路径 (灰色)
            EditorGUILayout.BeginHorizontal();
            GUI.enabled = false;
            EditorGUILayout.LabelField("Asset Path:", GUILayout.Width(70));
            EditorGUILayout.TextField(item.AssetPath);
            GUI.enabled = true;
            EditorGUILayout.EndHorizontal();

            EditorGUI.indentLevel--;
        }

        private void DrawFooter()
        {
            GUILayout.Space(10);
            GUI.backgroundColor = new Color(0.2f, 0.7f, 0.3f);
            if (GUILayout.Button("Sync & Generate Code", GUILayout.Height(40)))
            {
                SyncAndGenerate();
            }
            GUI.backgroundColor = Color.white;
        }

        // =========================================================
        // 逻辑处理
        // =========================================================

        private void LoadConfig()
        {
            _config = AssetDatabase.LoadAssetAtPath<AsakiAudioConfig>(CONFIG_PATH);
        }

        private void CreateConfigAsset()
        {
            string dir = Path.GetDirectoryName(CONFIG_PATH);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);

            _config = CreateInstance<AsakiAudioConfig>();
            AssetDatabase.CreateAsset(_config, CONFIG_PATH);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        private void RegisterOrUpdateClip(AudioClip clip)
        {
            if (_config.Items.Any(x => x.Clip == clip)) return;
            string key = SanitizeName(clip.name);
            var existing = _config.Items.FirstOrDefault(x => x.Key == key);
            
            if (existing != null)
            {
                existing.Clip = clip;
                existing.AssetPath = GetLoadPath(clip);
                return;
            }

            var newItem = new AudioItem
            {
                Clip = clip,
                Key = key,
                Volume = 1.0f,
                Pitch = 1.0f,
                Group = AsakiAudioGroup.SFX,
                AssetPath = GetLoadPath(clip)
            };
            
            string lowerName = newItem.Key.ToLower();
            if (lowerName.Contains("bgm") || lowerName.Contains("music"))
            {
                newItem.Group = AsakiAudioGroup.BGM;
                newItem.Loop = true;
            }
            else if (lowerName.Contains("ui") || lowerName.Contains("click"))
            {
                newItem.Group = AsakiAudioGroup.UI;
            }

            _config.Items.Add(newItem);
        }

        // =========================================================
        // 播放控制逻辑 (核心修改)
        // =========================================================

        private void PlayPreview(AudioItem item)
        {
            if (item.Clip == null) return;
            InitAudioSource(); // 确保 Source 存在

            _previewSource.Stop();
            _previewSource.clip = item.Clip;
            _previewSource.volume = item.Volume;
            _previewSource.pitch = item.Pitch;
            // 预览时不应用 Random Pitch，方便听原声
            
            _previewSource.Play();
            
            _currentPlayingItem = item;
            _isPaused = false;
        }

        private void PausePreview()
        {
            if (_previewSource != null && _previewSource.isPlaying)
            {
                _previewSource.Pause();
                _isPaused = true;
            }
        }

        private void ResumePreview()
        {
            if (_previewSource != null && _isPaused)
            {
                _previewSource.UnPause();
                _isPaused = false;
            }
        }

        private void StopPreview()
        {
            if (_previewSource != null)
            {
                _previewSource.Stop();
                _previewSource.clip = null;
            }
            _currentPlayingItem = null;
            _isPaused = false;
        }

        // =========================================================
        // 辅助工具
        // =========================================================

        private string FormatDuration(float seconds)
        {
            System.TimeSpan ts = System.TimeSpan.FromSeconds(seconds);
            return $"{ts.Minutes:D1}:{ts.Seconds:D2}";
        }

        private string GetLoadPath(AudioClip clip)
        {
            string rawPath = AssetDatabase.GetAssetPath(clip);
            if (rawPath.Contains("/Resources/"))
            {
                string ext = Path.GetExtension(rawPath);
                int resIndex = rawPath.IndexOf("/Resources/") + 11;
                return rawPath.Substring(resIndex).Replace(ext, "");
            }
            return rawPath;
        }

        private string SanitizeName(string rawName)
        {
            string name = rawName.Replace(" ", "_").Replace("-", "_").Replace(".", "_");
            char[] arr = name.ToCharArray();
            for(int i=0; i<arr.Length; i++)
            {
                if (!char.IsLetterOrDigit(arr[i]) && arr[i] != '_') arr[i] = '_';
            }
            name = new string(arr);
            if (char.IsDigit(name[0])) name = "Snd_" + name;
            return name;
        }

        private void SyncAndGenerate()
        {
            if (_config == null) return;
            foreach (var item in _config.Items)
            {
                if (string.IsNullOrEmpty(item.Key)) item.Key = "Unnamed_" + System.Guid.NewGuid().ToString().Substring(0, 4);
                item.ID = Animator.StringToHash(item.Key);
                if (item.Clip != null) item.AssetPath = GetLoadPath(item.Clip);
            }
            EditorUtility.SetDirty(_config);
            AssetDatabase.SaveAssets();

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by AsakiAudioDashboard.");
            sb.AppendLine("using Asaki.Core;");
            sb.AppendLine("using Asaki.Core.Audio;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine();
            sb.AppendLine("namespace Asaki.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public enum AudioID");
            sb.AppendLine("    {");
            sb.AppendLine("        None = 0,");
            foreach (var item in _config.Items.OrderBy(x => x.Key))
            {
                sb.AppendLine($"        {item.Key} = {item.ID},");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    public static class AudioExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        public static AsakiAudioHandle Play(this IAsakiAudioService service, AudioID id, AsakiAudioParams p = default, CancellationToken token = default)");
            sb.AppendLine("        {");
            sb.AppendLine("            return service.Play((int)id, p, token);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            string dir = Path.GetDirectoryName(CODE_GEN_PATH);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            File.WriteAllText(CODE_GEN_PATH, sb.ToString(), Encoding.UTF8);

            AssetDatabase.Refresh();
            Debug.Log($"[AsakiAudio] Synced {_config.Items.Count} clips.");
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AsakiFileTreeGenerator.cs -->
<!-- GUID: f56f8393e6c143b5b28b08588616d30e -->
<!-- Size: 10481 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools
{
    public class AsakiFileTreeGenerator : EditorWindow
    {
        // 配置项键名（用于保存设置）
        private const string PREF_ROOT_PATH = "Asaki_Tree_RootPath";
        private const string PREF_OUTPUT_PATH = "Asaki_Tree_OutputPath";
        private const string PREF_EXTENSIONS = "Asaki_Tree_Extensions";
        private const string PREF_IGNORE_META = "Asaki_Tree_IgnoreMeta";
        private const string PREF_MAX_DEPTH = "Asaki_Tree_MaxDepth";
        private const string PREF_SHOW_SIZE = "Asaki_Tree_ShowSize";

        // 运行时变量
        private string _rootPath;
        private string _outputPath;
        private string _extensions = ".cs,.asmdef,.txt,.shader,.json,.xml"; // 默认白名单
        private bool _ignoreMeta = true;
        private int _maxDepth = 10;
        private bool _showSize = false;

        // 统计数据
        private int _statsDirCount;
        private int _statsFileCount;
        private long _statsTotalSize;

        [MenuItem("Asaki/Tools/File Tree Generator")]
        public static void ShowWindow()
        {
            var window = GetWindow<AsakiFileTreeGenerator>("File Tree Gen");
            window.minSize = new Vector2(400, 400);
            window.Show();
        }

        private void OnEnable()
        {
            // 加载配置
            _rootPath = EditorPrefs.GetString(PREF_ROOT_PATH, Application.dataPath + "/Asaki");
            _outputPath = EditorPrefs.GetString(PREF_OUTPUT_PATH, Application.dataPath + "/Asaki/file_tree.txt");
            _extensions = EditorPrefs.GetString(PREF_EXTENSIONS, _extensions);
            _ignoreMeta = EditorPrefs.GetBool(PREF_IGNORE_META, true);
            _maxDepth = EditorPrefs.GetInt(PREF_MAX_DEPTH, 10);
            _showSize = EditorPrefs.GetBool(PREF_SHOW_SIZE, false);
        }

        private void OnDisable()
        {
            // 保存配置
            EditorPrefs.SetString(PREF_ROOT_PATH, _rootPath);
            EditorPrefs.SetString(PREF_OUTPUT_PATH, _outputPath);
            EditorPrefs.SetString(PREF_EXTENSIONS, _extensions);
            EditorPrefs.SetBool(PREF_IGNORE_META, _ignoreMeta);
            EditorPrefs.SetInt(PREF_MAX_DEPTH, _maxDepth);
            EditorPrefs.SetBool(PREF_SHOW_SIZE, _showSize);
        }

        private void OnGUI()
        {
            GUILayout.Space(10);
            GUILayout.Label("Asaki Project Structure Scanner", EditorStyles.boldLabel);
            GUILayout.Space(5);

            // 1. 扫描路径设置
            EditorGUILayout.LabelField("Scan Settings", EditorStyles.boldLabel);
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    _rootPath = EditorGUILayout.TextField("Root Path", _rootPath);
                    if (GUILayout.Button("Browse", GUILayout.Width(60)))
                    {
                        string path = EditorUtility.OpenFolderPanel("Select Root Folder", _rootPath, "");
                        if (!string.IsNullOrEmpty(path)) _rootPath = path;
                    }
                }

                using (new EditorGUILayout.HorizontalScope())
                {
                    _outputPath = EditorGUILayout.TextField("Output File", _outputPath);
                    if (GUILayout.Button("Browse", GUILayout.Width(60)))
                    {
                        string path = EditorUtility.SaveFilePanel("Save Tree To", Path.GetDirectoryName(_outputPath), "file_tree", "txt");
                        if (!string.IsNullOrEmpty(path)) _outputPath = path;
                    }
                }
            }

            GUILayout.Space(5);

            // 2. 过滤设置
            EditorGUILayout.LabelField("Filters", EditorStyles.boldLabel);
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                _ignoreMeta = EditorGUILayout.Toggle("Ignore .meta Files", _ignoreMeta);
                _showSize = EditorGUILayout.Toggle("Show File Size", _showSize);
                _maxDepth = EditorGUILayout.IntSlider("Max Depth", _maxDepth, 1, 20);
                
                GUILayout.Space(2);
                EditorGUILayout.LabelField("Include Extensions (comma separated, empty for all):");
                _extensions = EditorGUILayout.TextField(_extensions);
            }

            GUILayout.Space(15);

            // 3. 生成按钮
            GUI.backgroundColor = new Color(0.4f, 0.8f, 0.4f);
            if (GUILayout.Button("Generate File Tree", GUILayout.Height(40)))
            {
                GenerateTree();
            }
            GUI.backgroundColor = Color.white;
            
            // 4. 打开文件按钮
            if (File.Exists(_outputPath))
            {
                GUILayout.Space(5);
                if (GUILayout.Button("Open Generated File"))
                {
                    Application.OpenURL("file://" + _outputPath);
                }
            }
        }

        private void GenerateTree()
        {
            if (!Directory.Exists(_rootPath))
            {
                EditorUtility.DisplayDialog("Error", $"Directory not found:\n{_rootPath}", "OK");
                return;
            }

            _statsDirCount = 0;
            _statsFileCount = 0;
            _statsTotalSize = 0;

            StringBuilder sb = new StringBuilder();
            
            // 头部信息
            sb.AppendLine(new string('=', 60));
            sb.AppendLine($"Directory Tree: {_rootPath}");
            sb.AppendLine($"Generated Time: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine(new string('=', 60));
            sb.AppendLine();
            sb.AppendLine($"{Path.GetFileName(_rootPath)}/");

            // 递归生成
            List<string> validExtensions = _extensions.Split(',')
                .Select(e => e.Trim().ToLower())
                .Where(e => !string.IsNullOrEmpty(e))
                .ToList();

            Traverse(new DirectoryInfo(_rootPath), "", true, 0, sb, validExtensions);

            // 统计信息
            sb.AppendLine();
            sb.AppendLine(new string('=', 60));
            sb.AppendLine($"Stats: {_statsDirCount} directories, {_statsFileCount} files");
            sb.AppendLine($"Total Size: {EditorUtility.FormatBytes(_statsTotalSize)}");
            if (_ignoreMeta) sb.AppendLine("Ignored: .meta files");
            if (validExtensions.Count > 0) sb.AppendLine($"Whitelist: {string.Join(", ", validExtensions)}");
            sb.AppendLine(new string('=', 60));

            try
            {
                // 确保输出目录存在
                string outDir = Path.GetDirectoryName(_outputPath);
                if (!Directory.Exists(outDir)) Directory.CreateDirectory(outDir);

                File.WriteAllText(_outputPath, sb.ToString(), Encoding.UTF8);
                Debug.Log($"<color=#44FFaa>[Asaki]</color> File tree generated at: {_outputPath}");
                AssetDatabase.Refresh(); // 刷新资源，如果文件在Assets目录下
            }
            catch (System.Exception e)
            {
                Debug.LogError($"[Asaki] Failed to write file tree: {e.Message}");
            }
        }

        private void Traverse(DirectoryInfo dir, string prefix, bool isLast, int currentDepth, StringBuilder sb, List<string> validExtensions)
        {
            if (currentDepth >= _maxDepth) return;

            try
            {
                // 获取所有子目录和文件
                var dirs = dir.GetDirectories();
                var files = dir.GetFiles();

                // 过滤隐藏文件夹
                dirs = dirs.Where(d => !d.Name.StartsWith(".")).ToArray();

                // 过滤文件
                files = files.Where(f => !f.Name.StartsWith(".") && ShouldIncludeFile(f, validExtensions)).ToArray();

                // 排序：文件夹优先，然后按名称排序 (复刻 Python 逻辑)
                var allItems = new List<FileSystemInfo>();
                allItems.AddRange(dirs.OrderBy(d => d.Name));
                allItems.AddRange(files.OrderBy(f => f.Name));

                int count = allItems.Count;
                for (int i = 0; i < count; i++)
                {
                    var item = allItems[i];
                    bool isLastItem = (i == count - 1);

                    // 构建前缀
                    string connector = isLastItem ? "└── " : "├── ";
                    string childPrefix = prefix + (isLastItem ? "    " : "│   ");

                    if (item is DirectoryInfo dInfo)
                    {
                        _statsDirCount++;
                        sb.AppendLine($"{prefix}{connector}{dInfo.Name}/");
                        Traverse(dInfo, childPrefix, isLastItem, currentDepth + 1, sb, validExtensions);
                    }
                    else if (item is FileInfo fInfo)
                    {
                        _statsFileCount++;
                        _statsTotalSize += fInfo.Length;
                        
                        string sizeStr = _showSize ? $" ({EditorUtility.FormatBytes(fInfo.Length)})" : "";
                        sb.AppendLine($"{prefix}{connector}{fInfo.Name}{sizeStr}");
                    }
                }
            }
            catch (System.UnauthorizedAccessException)
            {
                sb.AppendLine($"{prefix}└── [ACCESS DENIED]");
            }
        }

        private bool ShouldIncludeFile(FileInfo file, List<string> validExtensions)
        {
            if (_ignoreMeta && file.Extension.ToLower() == ".meta") return false;

            // 如果没有设置白名单，则包含所有（除了被忽略的）
            if (validExtensions == null || validExtensions.Count == 0) return true;

            // 检查白名单
            return validExtensions.Contains(file.Extension.ToLower());
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AsakiScriptAggregation.cs -->
<!-- GUID: 64b04888b6434160bc8a6fa71cc2b7a3 -->
<!-- Size: 29740 bytes -->
<!-- Modified: 2025-12-25 15:16:24 -->
```csharp
// ================================================
// Unity Script Aggregator for AI Collaboration
// Version: 1.0
// Author: Unity Architecture Master
// ================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools
{
    // ============================================================================
    // 数据模型层
    // ============================================================================
    [Serializable]
    public class ScriptInfo
    {
        public string assetPath;        // Assets/Scripts/Player.cs
        public string projectPath;      // Project/Scripts/Player.cs (相对Assets)
        public long fileSize;           // 字节数
        public DateTime modifiedTime;
        public string guid;             // Unity GUID
        public bool isSelected;         // UI选择状态
        
        public string FileName => Path.GetFileName(assetPath);
        public string Extension => Path.GetExtension(assetPath);
        public string ContentPreview { get; set; }
    }

    // ============================================================================
    // 配置管理（ScriptableObject）
    // ============================================================================
    public class ExportConfig : ScriptableObject
    {
        public string outputPath = "Assets/AI_Code.txt";
        public TemplateType templateType = TemplateType.Markdown;
        public bool includeGuid = true;
        public bool includeFileSize = true;
        public bool includeModifiedTime = true;
        public bool openAfterExport = true;
        public bool useRelativePath = true;
        public string[] excludedFolders = { "Library", "Temp", "Logs", "obj", "bin" };
        public string fileFilterPattern = "*.cs";

        public enum TemplateType
        {
            Markdown = 0,
            Xml = 1,
            Raw = 2
        }

        private static ExportConfig _instance;
        public static ExportConfig Instance
        {
            get
            {
                if (_instance != null) return _instance;
                
                var path = "Assets/Editor/ScriptAggregatorConfig.asset";
                _instance = AssetDatabase.LoadAssetAtPath<ExportConfig>(path);
                if (_instance == null)
                {
                    _instance = CreateInstance<ExportConfig>();
                    Directory.CreateDirectory("Assets/Editor");
                    AssetDatabase.CreateAsset(_instance, path);
                    AssetDatabase.SaveAssets();
                }
                return _instance;
            }
        }

        public void Save()
        {
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
        }
    }

    // ============================================================================
    // 模板策略（策略模式）
    // ============================================================================
    public interface IExportTemplate
    {
        string Header(ScriptInfo info);
        string Content(string content);
        string Separator();
        string Footer();
        string FileExtension();
    }

    public class MarkdownTemplate : IExportTemplate
    {
        public string Header(ScriptInfo info)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"<!-- File: {info.projectPath} -->");
            if (ExportConfig.Instance.includeGuid) sb.AppendLine($"<!-- GUID: {info.guid} -->");
            if (ExportConfig.Instance.includeFileSize) sb.AppendLine($"<!-- Size: {info.fileSize} bytes -->");
            if (ExportConfig.Instance.includeModifiedTime) sb.AppendLine($"<!-- Modified: {info.modifiedTime:yyyy-MM-dd HH:mm:ss} -->");
            sb.AppendLine("```csharp");
            return sb.ToString();
        }

        public string Content(string content) => content;
        public string Separator() => "```\n\n";
        public string Footer() => "```\n";
        public string FileExtension() => ".md";
    }

    public class XmlTemplate : IExportTemplate
    {
        public string Header(ScriptInfo info)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"<File Path=\"{SecurityElement.Escape(info.projectPath)}\" " +
                         $"GUID=\"{info.guid}\" " +
                         $"Size=\"{info.fileSize}\">");
            sb.AppendLine("<Content><![CDATA[");
            return sb.ToString();
        }

        public string Content(string content) => content;
        public string Separator() => "]]></Content></File>\n";
        public string Footer() => "";
        public string FileExtension() => ".xml";
    }

    public class RawTemplate : IExportTemplate
    {
        public string Header(ScriptInfo info)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"/{'*'} {info.projectPath} {'*'}/");
            return sb.ToString();
        }

        public string Content(string content) => content;
        public string Separator() => "\n\n";
        public string Footer() => "";
        public string FileExtension() => ".txt";
    }

    // ============================================================================
    // 核心服务层（纯业务逻辑，无UI依赖）
    // ============================================================================
    public class ScriptAggregationService
    {
        private readonly ExportConfig _config;
        private readonly Dictionary<ExportConfig.TemplateType, IExportTemplate> _templates;

        public ScriptAggregationService(ExportConfig config)
        {
            _config = config;
            _templates = new Dictionary<ExportConfig.TemplateType, IExportTemplate>
            {
                { ExportConfig.TemplateType.Markdown, new MarkdownTemplate() },
                { ExportConfig.TemplateType.Xml, new XmlTemplate() },
                { ExportConfig.TemplateType.Raw, new RawTemplate() }
            };
        }

        // 扫描项目中的所有脚本
        public List<ScriptInfo> ScanAllScripts(string rootPath = null)
        {
            var scripts = new List<ScriptInfo>();
            var root = string.IsNullOrEmpty(rootPath) ? Application.dataPath : Path.GetFullPath(rootPath);
            
            try
            {
                var csFiles = Directory.EnumerateFiles(root, "*.cs", SearchOption.AllDirectories)
                    .Where(path => !IsPathExcluded(path))
                    .Where(path => !Path.GetFileName(path).StartsWith("."));

                foreach (var filePath in csFiles)
                {
                    var assetPath = "Assets" + filePath.Substring(Application.dataPath.Length).Replace("\\", "/");
                    var info = CreateScriptInfo(assetPath);
                    if (info != null) scripts.Add(info);
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ScriptAggregator] 扫描失败: {ex.Message}");
            }

            return scripts.OrderBy(s => s.projectPath).ToList();
        }

        private bool IsPathExcluded(string path)
        {
            return _config.excludedFolders.Any(excluded => 
                path.Contains($"/{excluded}/") || path.Contains($"\\{excluded}\\"));
        }

        private ScriptInfo CreateScriptInfo(string assetPath)
        {
            try
            {
                var fileInfo = new FileInfo(assetPath);
                return new ScriptInfo
                {
                    assetPath = assetPath,
                    projectPath = _config.useRelativePath ? 
                        assetPath.Substring("Assets/".Length) : assetPath,
                    fileSize = fileInfo.Length,
                    modifiedTime = fileInfo.LastWriteTime,
                    guid = AssetDatabase.AssetPathToGUID(assetPath),
                    isSelected = false,
                    ContentPreview = ""
                };
            }
            catch
            {
                return null;
            }
        }

        // 导出核心方法（支持进度回调）
        public async System.Threading.Tasks.Task<bool> ExportAsync(
            List<ScriptInfo> selectedScripts, 
            Action<float> onProgress = null,
            CancellationToken cancellationToken = default)
        {
            if (selectedScripts.Count == 0)
            {
                Debug.LogWarning("[ScriptAggregator] 未选择任何文件");
                return false;
            }

            var template = _templates[_config.templateType];
            var tempPath = _config.outputPath + ".tmp";
            var totalSize = selectedScripts.Sum(s => s.fileSize);
            var processedSize = 0L;

            try
            {
                using (var writer = new StreamWriter(tempPath, false, new UTF8Encoding(true)))
                {
                    // 写入头部
                    await writer.WriteLineAsync($"# Unity Scripts Aggregation");
                    await writer.WriteLineAsync($"# Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                    await writer.WriteLineAsync($"# Total Files: {selectedScripts.Count}");
                    await writer.WriteLineAsync($"# Total Size: {totalSize} bytes");
                    await writer.WriteLineAsync();

                    // 写入每个文件
                    for (int i = 0; i < selectedScripts.Count; i++)
                    {
                        if (cancellationToken.IsCancellationRequested)
                        {
                            writer.Close();
                            File.Delete(tempPath);
                            return false;
                        }

                        var script = selectedScripts[i];
                        await writer.WriteAsync(template.Header(script));
                        
                        // 读取文件内容
                        var content = await File.ReadAllTextAsync(script.assetPath);
                        await writer.WriteAsync(template.Content(content));
                        await writer.WriteAsync(template.Separator());

                        processedSize += script.fileSize;
                        onProgress?.Invoke((float)i / selectedScripts.Count);
                    }

                    await writer.WriteAsync(template.Footer());
                }

                // 原子替换
                File.Delete(_config.outputPath);
                File.Move(tempPath, _config.outputPath);
                
                AssetDatabase.Refresh();
                Debug.Log($"[ScriptAggregator] 导出成功: {_config.outputPath}");
                return true;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ScriptAggregator] 导出失败: {ex.Message}");
                if (File.Exists(tempPath)) File.Delete(tempPath);
                return false;
            }
        }
    }

    // ============================================================================
    // UI层（EditorWindow）
    // ============================================================================
    public class ScriptAggregatorWindow : EditorWindow
    {
        private const string WINDOW_TITLE = "Script Aggregator";
        private const string PREFS_KEY = "ScriptAggregator_v1";
        private const string MENU_PATH = "Asaki/Tools/AI Collaboration/Script Aggregator";

        private Vector2 _leftScrollPos;
        private Vector2 _rightScrollPos;
        private List<ScriptInfo> _allScripts;
        private List<ScriptInfo> _filteredScripts;
        private string _searchText = "";
        private bool _isExporting = false;
        private float _exportProgress = 0f;
        private CancellationTokenSource _cancellationTokenSource;

        // 配置
        private ExportConfig _config;
        private ScriptAggregationService _service;

        // UI状态
        private GUIStyle _selectedStyle;
        private GUIStyle _normalStyle;
        private GUIStyle _searchFieldStyle;
        private bool _showConfig = true;
        
        // 选择统计
        private int _selectedCount = 0;
        private long _selectedSize = 0;

        [MenuItem(MENU_PATH, false, 1000)]
        public static void ShowWindow()
        {
            var window = GetWindow<ScriptAggregatorWindow>(WINDOW_TITLE);
            window.minSize = new Vector2(900f, 500f);
            window.Show();
        }

        [MenuItem(MENU_PATH + " (Export)", true)]
        private static bool ValidateQuickExport() => !Application.isPlaying;

        [MenuItem(MENU_PATH + " (Export)", false, 1001)]
        public static async void QuickExport()
        {
            var window = GetWindow<ScriptAggregatorWindow>(WINDOW_TITLE);
            if (window._config == null) window.Initialize();
            
            // 全选所有脚本
            window.SelectAll();
            
            // 执行导出
            await window.ExportAsync();
        }

        private void OnEnable()
        {
            Initialize();
            LoadSelectionState();
            EditorApplication.update += OnEditorUpdate;
        }

        private void OnDisable()
        {
            SaveSelectionState();
            EditorApplication.update -= OnEditorUpdate;
            _cancellationTokenSource?.Cancel();
        }

        private void Initialize()
        {
            _config = ExportConfig.Instance;
            _service = new ScriptAggregationService(_config);
            _allScripts = _service.ScanAllScripts();
            _filteredScripts = new List<ScriptInfo>(_allScripts);
            
            CalculateSelectionStats();
        }

        private void OnEditorUpdate()
        {
            Repaint();
        }

        private void OnGUI()
        {
            InitializeStyles();
            
            // 顶部工具栏
            DrawToolbar();
            
            // 主布局
            EditorGUILayout.BeginHorizontal();
            {
                // 左侧面板：文件列表
                DrawFileListPanel();
                
                // 右侧配置面板
                DrawConfigPanel();
            }
            EditorGUILayout.EndHorizontal();
            
            // 底部状态栏
            DrawStatusBar();
            
            // 进度条
            if (_isExporting)
            {
                DrawProgressBar();
            }
            
            // 快捷键处理
            HandleKeyboardEvents();
        }

        private void InitializeStyles()
        {
            if (_selectedStyle != null) return;
            
            _selectedStyle = new GUIStyle(EditorStyles.label)
            {
                normal = { background = CreateColorTexture(new Color(0.2f, 0.4f, 0.8f, 0.3f)) },
                padding = new RectOffset(4, 4, 2, 2)
            };
            
            _normalStyle = new GUIStyle(EditorStyles.label)
            {
                padding = new RectOffset(4, 4, 2, 2)
            };
            
            _searchFieldStyle = new GUIStyle("SearchTextField");
        }

        private Texture2D CreateColorTexture(Color color)
        {
            var texture = new Texture2D(1, 1);
            texture.SetPixel(0, 0, color);
            texture.Apply();
            return texture;
        }

        private async void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            {
                if (GUILayout.Button("刷新", EditorStyles.toolbarButton, GUILayout.Width(60)))
                {
                    Initialize();
                }
                
                if (GUILayout.Button("全选", EditorStyles.toolbarButton, GUILayout.Width(60)))
                {
                    SelectAll();
                }
                
                if (GUILayout.Button("反选", EditorStyles.toolbarButton, GUILayout.Width(60)))
                {
                    InvertSelection();
                }
                
                if (GUILayout.Button("清空", EditorStyles.toolbarButton, GUILayout.Width(60)))
                {
                    ClearSelection();
                }
                
                GUILayout.FlexibleSpace();
                
                if (GUILayout.Button("导出", EditorStyles.toolbarButton, GUILayout.Width(80)))
                {
                    await ExportAsync();
                }
            }
            EditorGUILayout.EndHorizontal();
        }

        private void DrawFileListPanel()
        {
            EditorGUILayout.BeginVertical(GUI.skin.box, GUILayout.Width(position.width * 0.6f));
            {
                // 搜索框
                EditorGUI.BeginChangeCheck();
                _searchText = EditorGUILayout.TextField(_searchText, _searchFieldStyle);
                if (EditorGUI.EndChangeCheck())
                {
                    FilterScripts();
                }
                
                // 文件列表
                _leftScrollPos = EditorGUILayout.BeginScrollView(_leftScrollPos);
                {
                    foreach (var script in _filteredScripts)
                    {
                        DrawScriptItem(script);
                    }
                }
                EditorGUILayout.EndScrollView();
            }
            EditorGUILayout.EndVertical();
        }

        private void DrawScriptItem(ScriptInfo script)
        {
            EditorGUILayout.BeginHorizontal();
            {
                var rect = EditorGUILayout.GetControlRect();
                var content = new GUIContent($" {script.FileName}", 
                    $"路径: {script.projectPath}\n大小: {script.fileSize} bytes\n修改: {script.modifiedTime}");
                
                var wasSelected = script.isSelected;
                var isSelected = GUI.Toggle(rect, wasSelected, content, wasSelected ? _selectedStyle : _normalStyle);
                
                if (isSelected != wasSelected)
                {
                    script.isSelected = isSelected;
                    CalculateSelectionStats();
                }
                
                GUILayout.FlexibleSpace();
                
                // 文件大小标签
                var sizeLabel = $"{script.fileSize / 1024.0f:F1}KB";
                var sizeRect = GUILayoutUtility.GetRect(new GUIContent(sizeLabel), EditorStyles.label, GUILayout.Width(60));
                EditorGUI.LabelField(sizeRect, sizeLabel, EditorStyles.miniLabel);
            }
            EditorGUILayout.EndHorizontal();
        }

        private void DrawConfigPanel()
        {
            _rightScrollPos = EditorGUILayout.BeginScrollView(_rightScrollPos, GUI.skin.box, 
                GUILayout.Width(position.width * 0.4f));
            {
                EditorGUILayout.LabelField("导出配置", EditorStyles.boldLabel);
                EditorGUILayout.Space();
                
                // 输出路径
                EditorGUILayout.LabelField("输出路径:");
                EditorGUILayout.BeginHorizontal();
                {
                    _config.outputPath = EditorGUILayout.TextField(_config.outputPath);
                    if (GUILayout.Button("...", GUILayout.Width(30)))
                    {
                        var path = EditorUtility.SaveFilePanel("选择输出文件", "Assets/", "AI_Code", "txt");
                        if (!string.IsNullOrEmpty(path))
                        {
                            _config.outputPath = "Assets" + path.Substring(Application.dataPath.Length);
                        }
                    }
                }
                EditorGUILayout.EndHorizontal();
                
                EditorGUILayout.Space();
                
                // 模板类型
                _config.templateType = (ExportConfig.TemplateType)EditorGUILayout.EnumPopup("文件格式", _config.templateType);
                
                EditorGUILayout.Space();
                
                // 选项
                _config.includeGuid = EditorGUILayout.Toggle("包含GUID", _config.includeGuid);
                _config.includeFileSize = EditorGUILayout.Toggle("包含文件大小", _config.includeFileSize);
                _config.includeModifiedTime = EditorGUILayout.Toggle("包含修改时间", _config.includeModifiedTime);
                _config.useRelativePath = EditorGUILayout.Toggle("使用相对路径", _config.useRelativePath);
                _config.openAfterExport = EditorGUILayout.Toggle("导出后打开", _config.openAfterExport);
                
                EditorGUILayout.Space();
                
                // 排除文件夹
                EditorGUILayout.LabelField("排除文件夹 (逗号分隔):");
                var excluded = EditorGUILayout.TextArea(string.Join(", ", _config.excludedFolders));
                _config.excludedFolders = excluded.Split(',').Select(s => s.Trim()).ToArray();
                
                EditorGUILayout.Space();
                
                // 预览
                if (GUILayout.Button(_showConfig ? "▼ 隐藏预览" : "▶ 显示预览"))
                    _showConfig = !_showConfig;
                
                if (_showConfig && _selectedCount > 0)
                {
                    DrawPreview();
                }
            }
            EditorGUILayout.EndScrollView();
        }

        private void DrawPreview()
        {
            var previewScript = _allScripts.FirstOrDefault(s => s.isSelected);
            if (previewScript == null) return;
            
            EditorGUILayout.LabelField("预览:", EditorStyles.boldLabel);
            var preview = File.ReadAllText(previewScript.assetPath, Encoding.UTF8);
            var previewText = preview.Length > 500 ? preview.Substring(0, 500) + "..." : preview;
            EditorGUILayout.HelpBox(previewText, MessageType.None);
        }

        private void DrawStatusBar()
        {
            EditorGUILayout.BeginVertical(GUI.skin.box, GUILayout.Height(30));
            {
                EditorGUILayout.BeginHorizontal();
                {
                    var status = _isExporting 
                        ? $"正在导出... {_exportProgress:P0}" 
                        : $"已选择 {_selectedCount} 文件 | 总计 {_selectedSize / 1024.0f:F1}KB";
                    EditorGUILayout.LabelField(status, EditorStyles.boldLabel);
                    
                    GUILayout.FlexibleSpace();
                    
                    if (_isExporting && GUILayout.Button("取消", GUILayout.Width(60)))
                    {
                        _cancellationTokenSource?.Cancel();
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndVertical();
        }

        private void DrawProgressBar()
        {
            var rect = EditorGUILayout.GetControlRect();
            EditorGUI.ProgressBar(rect, _exportProgress, $"导出中... {_exportProgress:P0}");
        }

        private async void HandleKeyboardEvents()
        {
            var evt = Event.current;
            if (evt.type == EventType.KeyDown)
            {
                switch (evt.keyCode)
                {
                    case KeyCode.E when evt.control:
                        await ExportAsync();
                        evt.Use();
                        break;
                    case KeyCode.A when evt.control:
                        SelectAll();
                        evt.Use();
                        break;
                    case KeyCode.Escape:
                        _cancellationTokenSource?.Cancel();
                        evt.Use();
                        break;
                }
            }
        }

        private void FilterScripts()
        {
            if (string.IsNullOrEmpty(_searchText))
            {
                _filteredScripts = new List<ScriptInfo>(_allScripts);
            }
            else
            {
                _filteredScripts = _allScripts.Where(s => 
                    s.FileName.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0 ||
                    s.projectPath.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0
                ).ToList();
            }
        }

        private void SelectAll()
        {
            foreach (var script in _allScripts) script.isSelected = true;
            CalculateSelectionStats();
        }

        private void InvertSelection()
        {
            foreach (var script in _allScripts) script.isSelected = !script.isSelected;
            CalculateSelectionStats();
        }

        private void ClearSelection()
        {
            foreach (var script in _allScripts) script.isSelected = false;
            CalculateSelectionStats();
        }

        private void CalculateSelectionStats()
        {
            _selectedCount = _allScripts.Count(s => s.isSelected);
            _selectedSize = _allScripts.Where(s => s.isSelected).Sum(s => s.fileSize);
        }

        private async Task ExportAsync()
        {
            if (_isExporting) return;
            
            var selectedScripts = _allScripts.Where(s => s.isSelected).ToList();
            if (selectedScripts.Count == 0)
            {
                EditorUtility.DisplayDialog("提示", "请先选择要导出的脚本文件", "确定");
                return;
            }

            _isExporting = true;
            _exportProgress = 0f;
            _cancellationTokenSource = new CancellationTokenSource();
            
            try
            {
                var success = await _service.ExportAsync(
                    selectedScripts,
                    progress => _exportProgress = progress,
                    _cancellationTokenSource.Token
                );

                if (success && _config.openAfterExport)
                {
                    Application.OpenURL(Path.GetFullPath(_config.outputPath));
                }
            }
            catch (OperationCanceledException)
            {
                Debug.LogWarning("[ScriptAggregator] 导出已取消");
            }
            finally
            {
                _isExporting = false;
                _exportProgress = 0f;
            }
        }

        private void SaveSelectionState()
        {
            var selectedPaths = _allScripts.Where(s => s.isSelected).Select(s => s.assetPath).ToArray();
            EditorPrefs.SetString($"{PREFS_KEY}_Selected", string.Join(";", selectedPaths));
        }

        private void LoadSelectionState()
        {
            var saved = EditorPrefs.GetString($"{PREFS_KEY}_Selected", "");
            if (string.IsNullOrEmpty(saved)) return;
            
            var selectedPaths = new HashSet<string>(saved.Split(';'));
            foreach (var script in _allScripts)
            {
                script.isSelected = selectedPaths.Contains(script.assetPath);
            }
            CalculateSelectionStats();
        }
    }

    // ============================================================================
    // 命令行模式（支持CI/CD）
    // ============================================================================
    public static class ScriptAggregatorCLI
    {
        public static void ExportFromCommandLine()
        {
            var args = System.Environment.GetCommandLineArgs();
            var outputPath = GetArgValue(args, "-output", "Assets/AI_Code.txt");
            var filter = GetArgValue(args, "-filter", "*.cs");
            
            var config = ExportConfig.Instance;
            config.outputPath = outputPath;
            config.fileFilterPattern = filter;
            
            var service = new ScriptAggregationService(config);
            var allScripts = service.ScanAllScripts();
            
            Debug.Log($"[ScriptAggregatorCLI] 找到 {allScripts.Count} 个脚本文件");
            
            var task = service.ExportAsync(allScripts);
            task.Wait();
            
            Debug.Log($"[ScriptAggregatorCLI] 导出完成: {outputPath}");
            EditorApplication.Exit(task.Result ? 0 : 1);
        }

        private static string GetArgValue(string[] args, string key, string defaultValue)
        {
            for (int i = 0; i < args.Length - 1; i++)
            {
                if (args[i] == key) return args[i + 1];
            }
            return defaultValue;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AssetReplacer/AsakiAssetReplacerLogic.cs -->
<!-- GUID: 3032b9070b3d457585ecb8aa69d1c162 -->
<!-- Size: 5542 bytes -->
<!-- Modified: 2025-12-25 14:36:48 -->
```csharp
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.AssetReplacer
{
    /// <summary>
    /// 资产替换核心逻辑 - 遵循 Asaki 实用主义
    /// 利用 SerializedProperty 进行通用替换，不依赖具体组件类型
    /// </summary>
    public static class AsakiAssetReplacerLogic
    {
        public class ReplaceEntry
        {
            public Object TargetObject;      // 被修改的组件或ScriptableObject
            public string PropertyPath;      // 属性路径
            public SerializedObject SerializedObj; 
            public bool IsSelected = true;   // UI上是否勾选
        }

        /// <summary>
        /// 扫描引用
        /// </summary>
        public static List<ReplaceEntry> FindReferences(Object sourceAsset, Object targetAsset, bool searchProject)
        {
            var results = new List<ReplaceEntry>();

            if (sourceAsset == null) return results;
            if (targetAsset != null && sourceAsset.GetType() != targetAsset.GetType())
            {
                Debug.LogError($"[Asaki Replacer] 类型不匹配: 源是 {sourceAsset.GetType()}, 目标是 {targetAsset.GetType()}");
                return results;
            }

            // 1. 确定搜索范围
            var objectsToScan = new List<Object>();

            if (searchProject)
            {
                // 搜索项目中的 Prefab 和 ScriptableObject
                string[] guids = AssetDatabase.FindAssets("t:Prefab t:ScriptableObject");
                foreach (var guid in guids)
                {
                    string path = AssetDatabase.GUIDToAssetPath(guid);
                    objectsToScan.Add(AssetDatabase.LoadAssetAtPath<Object>(path));
                }
            }
            else
            {
                // 搜索当前场景
                var rootObjects = UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects();
                foreach (var root in rootObjects)
                {
                    // 获取所有 Component
                    objectsToScan.AddRange(root.GetComponentsInChildren<Component>(true));
                }
            }

            // 2. 遍历属性
            foreach (var obj in objectsToScan)
            {
                if (obj == null) continue;

                var so = new SerializedObject(obj);
                var sp = so.GetIterator();

                while (sp.NextVisible(true)) // 遍历所有可见属性
                {
                    if (sp.propertyType == SerializedPropertyType.ObjectReference)
                    {
                        // 核心判断：属性引用的对象是否等于源对象
                        if (sp.objectReferenceValue == sourceAsset)
                        {
                            // 排除自身（防止循环引用或误操作）
                            if (sp.objectReferenceValue == obj) continue;

                            results.Add(new ReplaceEntry
                            {
                                TargetObject = obj,
                                PropertyPath = sp.propertyPath,
                                SerializedObj = so // 缓存 SO 以便后续写入
                            });
                        }
                    }
                }
            }

            return results;
        }

        /// <summary>
        /// 执行替换
        /// </summary>
        public static void ExecuteReplace(List<ReplaceEntry> entries, Object targetAsset)
        {
            int count = 0;
            
            // 开启撤销组
            Undo.IncrementCurrentGroup();
            int undoGroup = Undo.GetCurrentGroup();
            Undo.SetCurrentGroupName("Asaki Asset Replace");

            foreach (var entry in entries)
            {
                if (!entry.IsSelected) continue;
                if (entry.TargetObject == null) continue;

                // 更新 SerializedObject
                entry.SerializedObj.Update();
                var sp = entry.SerializedObj.FindProperty(entry.PropertyPath);

                if (sp != null)
                {
                    // 核心操作：替换引用
                    sp.objectReferenceValue = targetAsset;
                    entry.SerializedObj.ApplyModifiedProperties(); // 应用修改
                    
                    // 标记脏数据 (如果是场景对象，Unity会自动处理；如果是Prefab，需要手动)
                    if (AssetDatabase.Contains(entry.TargetObject))
                    {
                        EditorUtility.SetDirty(entry.TargetObject);
                    }
                    else
                    {
                         // 场景对象
                         if (entry.TargetObject is Component comp)
                         {
                             EditorSceneManager.MarkSceneDirty(comp.gameObject.scene);
                         }
                    }

                    count++;
                }
            }
            
            Undo.CollapseUndoOperations(undoGroup);
            AssetDatabase.SaveAssets(); // 保存项目资源
            
            Debug.Log($"<color=#4CAF50>[Asaki Replacer]</color> 成功替换 {count} 处引用。");
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AssetReplacer/AsakiAssetReplacerWindow.cs -->
<!-- GUID: c8af91acf64341068e5f78317a8bacbe -->
<!-- Size: 4803 bytes -->
<!-- Modified: 2025-12-25 14:37:06 -->
```csharp
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.AssetReplacer
{
    public class AsakiAssetReplacerWindow : EditorWindow
    {
        private Object _sourceAsset;
        private Object _targetAsset;
        private bool _searchProject; // 默认只搜场景，搜Project比较慢
        
        private List<AsakiAssetReplacerLogic.ReplaceEntry> _entries;
        private Vector2 _scrollPos;

        [MenuItem("Asaki/Tools/Asset Replacer")]
        public static void Open()
        {
            GetWindow<AsakiAssetReplacerWindow>("Asset Replacer").Show();
        }

        private void OnGUI()
        {
            DrawHeader();
            EditorGUILayout.Space();
            DrawSettings();
            EditorGUILayout.Space();
            DrawPreview();
            DrawFooter();
        }

        private void DrawHeader()
        {
            EditorGUILayout.LabelField("Asaki Asset Replacer", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("通用资产替换工具：将 Source 资产的所有引用替换为 Target 资产。\n支持场景对象与 Prefab。", MessageType.Info);
        }

        private void DrawSettings()
        {
            GUILayout.Label("Configuration", EditorStyles.boldLabel);
            
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                _sourceAsset = EditorGUILayout.ObjectField("Source (Old)", _sourceAsset, typeof(Object), false);
                _targetAsset = EditorGUILayout.ObjectField("Target (New)", _targetAsset, typeof(Object), false);

                // 类型检查警告
                if (_sourceAsset != null && _targetAsset != null)
                {
                    if (_sourceAsset.GetType() != _targetAsset.GetType())
                    {
                        EditorGUILayout.HelpBox($"类型不匹配! Source: {_sourceAsset.GetType().Name}, Target: {_targetAsset.GetType().Name}", MessageType.Error);
                    }
                }

                _searchProject = EditorGUILayout.Toggle("Include Project Assets", _searchProject);
                
                EditorGUILayout.Space();
                
                if (GUILayout.Button("1. Analyze References", GUILayout.Height(30)))
                {
                    PerformScan();
                }
            }
        }

        private void DrawPreview()
        {
            if (_entries == null) return;

            GUILayout.Label($"Found References: {_entries.Count}", EditorStyles.boldLabel);

            using (var scroll = new EditorGUILayout.ScrollViewScope(_scrollPos))
            {
                _scrollPos = scroll.scrollPosition;

                for (int i = 0; i < _entries.Count; i++)
                {
                    var entry = _entries[i];
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        entry.IsSelected = EditorGUILayout.Toggle(entry.IsSelected, GUILayout.Width(20));
                        
                        // 显示对象名称和组件类型
                        GUI.enabled = false;
                        EditorGUILayout.ObjectField(entry.TargetObject, typeof(Object), true);
                        GUI.enabled = true;

                        GUILayout.Label($"-> {entry.PropertyPath}", EditorStyles.miniLabel);
                    }
                }
            }
        }

        private void DrawFooter()
        {
            if (_entries == null || _entries.Count == 0) return;

            EditorGUILayout.Space();
            GUI.backgroundColor = Color.green;
            if (GUILayout.Button("2. Execute Replace", GUILayout.Height(40)))
            {
                if (EditorUtility.DisplayDialog("Confirm", $"Replace {_entries.Count} references? This allows Undo.", "Yes", "Cancel"))
                {
                    AsakiAssetReplacerLogic.ExecuteReplace(_entries, _targetAsset);
                    _entries.Clear(); // 清空结果防止重复操作
                }
            }
            GUI.backgroundColor = Color.white;
        }

        private void PerformScan()
        {
            if (_sourceAsset == null)
            {
                EditorUtility.DisplayDialog("Error", "Please assign a Source Asset.", "OK");
                return;
            }

            _entries = AsakiAssetReplacerLogic.FindReferences(_sourceAsset, _targetAsset, _searchProject);
            
            if (_entries.Count == 0)
            {
                Debug.Log("[Asaki Replacer] No references found.");
            }
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/AssetCategory.cs -->
<!-- GUID: 24bf51a0e7094b118def1b3d09e5fe4b -->
<!-- Size: 320 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
	/// <summary>
	/// 资产分类枚举
	/// </summary>
	public enum AssetCategory
	{
		All,
		Textures,
		Materials,
		Models,
		Prefabs,
		Scenes,
		Scripts,
		Audio,
		Animations,
		Shaders,
		Fonts,
		Videos,
		Documents,
		Others
	}
}
```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/AssetExplorerWindow.cs -->
<!-- GUID: fa74726addbc44b3a99dce433a00a6a5 -->
<!-- Size: 31136 bytes -->
<!-- Modified: 2025-12-25 15:16:17 -->
```csharp
// ============================================================================
// 主命名空间：Unity编辑器工具集
// ============================================================================

using Asaki.Editor.Utilities.Extensions;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
    public class AssetExplorerWindow : EditorWindow
    {
        private const string WINDOW_TITLE = "Asset Explorer Pro";
        private const string PREFS_FAVORITES = "AssetExplorer_Favorites";

        // 核心组件
        private AssetScanner _scanner;
        private SearchEngine _searchEngine;

        // UI状态
        private Vector2 _categoryScrollPos;
        private Vector2 _assetScrollPos;
        private string _searchText = "";
        private AssetCategory _selectedCategory = AssetCategory.All;
        private AssetInfo _selectedAsset;
        private readonly List<AssetInfo> _filteredAssets = new();
        private readonly Dictionary<AssetCategory, int> _categoryCounts = new();

        // 新增：资源缓冲队列，避免实时处理导致卡顿
        private readonly ConcurrentQueue<AssetInfo> _pendingAssets = new();
        private readonly HashSet<string> _processedGuids = new();

        // 布局
        private float _categoryPanelWidth = 200f;
        private float _detailPanelWidth = 300f;
        private readonly SplitterState _categorySplitter = new SplitterState(150f, 100f, 350f);
        private readonly SplitterState _detailSplitter = new SplitterState(250f, 150f, 500f);

        // 状态栏
        private string _statusText = "就绪";
        private double _scanTime;
        private bool _isDirty;

        // 收藏
        private readonly HashSet<string> _favorites = new();

        // 设置窗口
        private SettingsWindow _settingsWindow;

        // 新增：预览图标加载队列和节流控制
        private readonly Queue<AssetInfo> _previewLoadQueue = new();
        private float _lastPreviewLoadTime;
        private const float PREVIEW_LOAD_INTERVAL = 0.1f; // 每0.1秒加载一个预览

        // 新增：分类计数缓存，限制更新频率
        private Dictionary<AssetCategory, int> _cachedCategoryCounts;
        private float _lastCategoryCountUpdate;

        [MenuItem("Asaki/Tools/Asset Explorer Pro %&a")]
        public static void ShowWindow()
        {
            var window = GetWindow<AssetExplorerWindow>(WINDOW_TITLE);
            window.minSize = new Vector2(800, 500);
            window.Show();
        }

        private void OnEnable()
        {
            titleContent = new GUIContent(WINDOW_TITLE, EditorGUIUtility.IconContent("UnityLogo").image);

            _scanner = new AssetScanner();
            _searchEngine = new SearchEngine();

            // 事件订阅
            _scanner.OnAssetFound += OnAssetFound;
            _scanner.OnScanComplete += OnScanComplete;
            _scanner.OnError += OnScanError;

            LoadFavorites();
            _cachedCategoryCounts = new Dictionary<AssetCategory, int>();

            // 自动启动扫描
            EditorApplication.delayCall += () => StartScan();
        }

        private void OnDisable()
        {
            SaveFavorites();

            if (_scanner != null)
            {
                _scanner.CancelScan();
                _scanner.OnAssetFound -= OnAssetFound;
                _scanner.OnScanComplete -= OnScanComplete;
                _scanner.OnError -= OnScanError;
            }
        }

        private void OnGUI()
        {
            DrawToolbar();
            DrawMainContent();
            DrawStatusbar();
            HandleKeyboardShortcuts();
        }

        // 新增：在Update中异步处理预览加载，避免在OnGUI中阻塞
        private void Update()
        {
            // 处理预览图标加载队列
            if (_previewLoadQueue.Count > 0 && Time.realtimeSinceStartup - _lastPreviewLoadTime > PREVIEW_LOAD_INTERVAL)
            {
                var asset = _previewLoadQueue.Dequeue();
                LoadPreviewIcon(asset);
                _lastPreviewLoadTime = Time.realtimeSinceStartup;
                Repaint(); // 仅在有预览加载时刷新
            }

            // 扫描完成后处理待处理资源
            if (!_scanner.IsScanning && _pendingAssets.Count > 0)
            {
                ProcessPendingAssets();
            }
        }

        #region 工具栏

        private void DrawToolbar()
        {
            try
            {
                EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

                // 搜索框
                GUI.SetNextControlName("SearchField");
                var searchStyle = GUI.skin.FindStyle("ToolbarSearchTextField") ?? EditorStyles.toolbarTextField;
                if (searchStyle == null) searchStyle = EditorStyles.textField; // 最终保险

                var newSearchText = EditorGUILayout.TextField(_searchText, searchStyle,
                    GUILayout.MinWidth(200), GUILayout.ExpandWidth(true));

                if (newSearchText != _searchText)
                {
                    _searchText = newSearchText;
                    ApplySearch();
                }

                // 搜索模式
                var searchMode = (SearchEngine.SearchMode)EditorGUILayout.EnumPopup(_searchEngine._mode,
                    GUILayout.Width(100));
                if (searchMode != _searchEngine._mode)
                {
                    _searchEngine._mode = searchMode;
                    ApplySearch();
                }

                // 快速搜索保存按钮
                var cancelStyle = GUI.skin.FindStyle("ToolbarSearchCancelButtonEmpty") ?? EditorStyles.toolbarButton;
                if (GUILayout.Button("", cancelStyle, GUILayout.Width(20)))
                {
                    _searchEngine.SaveCurrentSearch();
                }

                GUILayout.Space(10);

                // 分类筛选
                var categoryNames = Enum.GetNames(typeof(AssetCategory));
                var categoryIndex = (int)_selectedCategory;
                var newIndex = EditorGUILayout.Popup(categoryIndex, categoryNames, GUILayout.Width(120));
                if (newIndex != categoryIndex)
                {
                    _selectedCategory = (AssetCategory)newIndex;
                    ApplySearch();
                }

                GUILayout.FlexibleSpace();

                // 刷新按钮
                if (GUILayout.Button(EditorGUIUtility.IconContent("Refresh"), EditorStyles.toolbarButton, GUILayout.Width(30)))
                {
                    StartScan(true);
                }

                // 设置按钮
                if (GUILayout.Button(EditorGUIUtility.IconContent("Settings"), EditorStyles.toolbarButton, GUILayout.Width(30)))
                {
                    ShowSettings();
                }

                EditorGUILayout.EndHorizontal();
            }
            catch (Exception e)
            {
                Debug.LogError($"[AssetExplorer] Toolbar 绘制失败: {e.Message}\n{e.StackTrace}");
                EditorGUILayout.EndHorizontal(); // 确保关闭布局组
            }
        }

        #endregion

        #region 主内容区

        private void DrawMainContent()
        {
            EditorGUILayout.BeginHorizontal();

            // 分类面板
            DrawCategoryPanel();

            // 可拖拽分隔条
            GUILayoutExtensions.Splitter(
                ref _categoryPanelWidth, 100f, 350f, false);

            // 资产列表
            DrawAssetList();

            // 详情面板
            GUILayoutExtensions.Splitter(
                ref _detailPanelWidth, 150f, 500f, true);

            DrawDetailPanel();

            EditorGUILayout.EndHorizontal();
        }

        private void DrawCategoryPanel()
        {
            GUILayout.BeginVertical(GUILayout.Width(_categoryPanelWidth));

            // 面板标题
            EditorGUILayout.LabelField("资源分类", EditorStyles.boldLabel);
            EditorGUILayout.Space(5);

            // 滚动区域
            _categoryScrollPos = EditorGUILayout.BeginScrollView(_categoryScrollPos);

            // 全部
            DrawCategoryItem("全部", AssetCategory.All,
                _filteredAssets.Count, _selectedCategory == AssetCategory.All);

            // 各分类
            foreach (AssetCategory category in Enum.GetValues(typeof(AssetCategory)))
            {
                if (category == AssetCategory.All) continue;

                var count = _categoryCounts.ContainsKey(category) ? _categoryCounts[category] : 0;
                DrawCategoryItem(category.ToString(), category, count, _selectedCategory == category);
            }

            EditorGUILayout.EndScrollView();

            GUILayout.EndVertical();
        }

        // 优化：使用精确的布局和点击检测，样式改为更可靠的自定义绘制
        private void DrawCategoryItem(string name, AssetCategory category, int count, bool selected)
        {
            // 获取固定高度的布局矩形
            var rect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.label, GUILayout.Height(24), GUILayout.ExpandWidth(true));
            
            // 背景绘制
            if (selected)
            {
                EditorGUI.DrawRect(rect, new Color(0.3f, 0.5f, 1f, 0.3f));
            }
            else if (Event.current.type == EventType.Repaint)
            {
                // 悬停效果
                if (rect.Contains(Event.current.mousePosition))
                {
                    EditorGUI.DrawRect(rect, new Color(1, 1, 1, 0.08f));
                }
            }

            // 内容区域定义
            Rect iconRect = new Rect(rect.x + 5, rect.y + 4, 16, 16);
            Rect textRect = new Rect(rect.x + 25, rect.y, rect.width - 70, rect.height);
            Rect countRect = new Rect(rect.x + rect.width - 45, rect.y, 40, rect.height);

            // 绘制图标、名称和计数
            var icon = GetCategoryIcon(category);
            if (icon != null)
                GUI.DrawTexture(iconRect, icon, ScaleMode.ScaleToFit);
            
            GUI.Label(textRect, name, EditorStyles.label);
            GUI.Label(countRect, count.ToString(), EditorStyles.miniLabel);

            // 精确的事件检测：仅在鼠标左键点击时响应
            if (Event.current.type == EventType.MouseDown && Event.current.button == 0 && rect.Contains(Event.current.mousePosition))
            {
                _selectedCategory = category;
                ApplySearch();
                Event.current.Use();
                Repaint();
            }
        }

        private void DrawAssetList()
        {
            GUILayout.BeginVertical();

            // 标题栏
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            EditorGUILayout.LabelField($"资产列表 ({_filteredAssets.Count})",
                EditorStyles.boldLabel, GUILayout.Width(150));

            GUILayout.FlexibleSpace();

            if (GUILayout.Button("导出列表", EditorStyles.toolbarButton, GUILayout.Width(80)))
            {
                ExportAssetList();
            }

            EditorGUILayout.EndHorizontal();

            // 滚动区域 - 使用固定样式确保正确测量
            _assetScrollPos = EditorGUILayout.BeginScrollView(_assetScrollPos,
                GUIStyle.none, GUI.skin.verticalScrollbar);

            // 确保内容在ScrollView内部绘制
            if (_scanner.IsScanning && _filteredAssets.Count == 0)
            {
                EditorGUILayout.LabelField("扫描中...", EditorStyles.centeredGreyMiniLabel);
            }
            else if (_filteredAssets.Count == 0)
            {
                EditorGUILayout.LabelField("未找到匹配的资源", EditorStyles.centeredGreyMiniLabel);
            }
            else
            {
                DrawAssetRows();
            }

            // 必须结束ScrollView
            EditorGUILayout.EndScrollView();

            GUILayout.EndVertical();
        }

        private void DrawAssetRows()
        {
            var eventType = Event.current.type;

            for (int i = 0; i < _filteredAssets.Count; i++)
            {
                var asset = _filteredAssets[i];

                // FIX: Always start horizontal layout first
                EditorGUILayout.BeginHorizontal(GUILayout.Height(20));

                // Draw content first (this establishes the layout)
                EditorGUI.BeginDisabledGroup(asset.category == AssetCategory.Others);

                // Icon
                var icon = GetAssetPreviewIcon(asset);
                GUILayout.Label(new GUIContent(icon), GUILayout.Width(16), GUILayout.Height(16));

                // Name
                var displayName = asset.isFavorite ? "⭐ " + asset.name : asset.name;
                GUILayout.Label(displayName, GUILayout.MinWidth(200), GUILayout.ExpandWidth(true));

                // Size
                GUILayout.Label(asset.GetFormattedSize(), EditorStyles.miniLabel, GUILayout.Width(80));

                // Type
                GUILayout.Label(asset.category.ToString(), EditorStyles.miniLabel, GUILayout.Width(60));

                // Date
                GUILayout.Label(asset.lastModified.ToString("MM-dd"), EditorStyles.miniLabel, GUILayout.Width(60));

                EditorGUI.EndDisabledGroup();

                // CLOSE the horizontal group BEFORE event handling
                EditorGUILayout.EndHorizontal();

                // FIX: Get rect AFTER layout is established
                var rect = GUILayoutUtility.GetLastRect();

                // FIX: Apply backgrounds using expanded rect
                if (i % 2 == 0)
                {
                    var bgRect = rect;
                    bgRect.x = 0;
                    bgRect.width = position.width;
                    EditorGUI.DrawRect(bgRect, new Color(0, 0, 0, 0.05f));
                }

                if (asset == _selectedAsset)
                {
                    var selRect = rect;
                    selRect.x = 0;
                    selRect.width = position.width;
                    EditorGUI.DrawRect(selRect, new Color(0.3f, 0.5f, 1f, 0.3f));
                }

                // Event handling
                if (eventType == EventType.MouseDown && rect.Contains(Event.current.mousePosition))
                {
                    if (Event.current.button == 0)
                    {
                        _selectedAsset = asset;
                        if (Event.current.clickCount == 2)
                            PingAsset(asset);
                        Event.current.Use();
                        Repaint();
                    }
                    else if (Event.current.button == 1)
                    {
                        ShowAssetContextMenu(asset);
                        Event.current.Use();
                    }
                }
            }
        }

        private void DrawDetailPanel()
        {
            GUILayout.BeginVertical(GUILayout.Width(_detailPanelWidth));

            if (_selectedAsset == null)
            {
                EditorGUILayout.LabelField("选择一个资产查看详情", EditorStyles.centeredGreyMiniLabel);
            }
            else
            {
                DrawAssetDetails(_selectedAsset);
            }

            GUILayout.EndVertical();
        }

        private void DrawAssetDetails(AssetInfo asset)
        {
            // [修复] 使用固定高度而非宽高比，防止垂直方向被撑大
            const float previewHeight = 200f;
    
            // 创建固定高度的预览区域
            GUILayout.Label("", GUILayout.Height(previewHeight), GUILayout.ExpandWidth(true));
            Rect previewRect = GUILayoutUtility.GetLastRect();
    
            var preview = AssetPreview.GetAssetPreview(asset.GetAssetObject());
            if (preview != null)
            {
                GUI.DrawTexture(previewRect, preview, ScaleMode.ScaleToFit);
            }
            else
            {
                EditorGUI.DrawRect(previewRect, Color.gray * 0.3f);
                EditorGUI.LabelField(previewRect, "无预览", EditorStyles.centeredGreyMiniLabel);
            }

            EditorGUILayout.Space(10);

            // 信息
            EditorGUILayout.LabelField("基本信息", EditorStyles.boldLabel);
            EditorGUILayout.LabelField("名称:", asset.name);
            EditorGUILayout.LabelField("路径:", asset.path, EditorStyles.wordWrappedLabel);
            EditorGUILayout.LabelField("大小:", asset.GetFormattedSize());
            EditorGUILayout.LabelField("类型:", asset.category.ToString());
            EditorGUILayout.LabelField("修改时间:", asset.lastModified.ToString("yyyy-MM-dd HH:mm:ss"));

            EditorGUILayout.Space(10);

            // 操作按钮
            if (GUILayout.Button("Ping", GUILayout.Height(25)))
            {
                PingAsset(asset);
            }

            if (GUILayout.Button("在资源管理器中显示", GUILayout.Height(25)))
            {
                ShowInExplorer(asset);
            }

            if (GUILayout.Button("复制路径", GUILayout.Height(25)))
            {
                CopyPath(asset);
            }

            if (GUILayout.Button("打开", GUILayout.Height(25)))
            {
                OpenAsset(asset);
            }

            // 收藏
            var favoriteLabel = asset.isFavorite ? "取消收藏" : "收藏";
            if (GUILayout.Button(favoriteLabel, GUILayout.Height(25)))
            {
                ToggleFavorite(asset);
            }
        }
        #endregion

        #region 状态栏

        private void DrawStatusbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

            // 状态信息
            EditorGUILayout.LabelField(_statusText, GUILayout.Width(300));

            GUILayout.FlexibleSpace();

            // 统计
            var totalCount = _scanner.CachedAssets.Count;
            EditorGUILayout.LabelField($"总计: {totalCount}", GUILayout.Width(80));
            EditorGUILayout.LabelField($"显示: {_filteredAssets.Count}", GUILayout.Width(80));
            EditorGUILayout.LabelField($"扫描: {_scanTime:F1}s", GUILayout.Width(80));

            EditorGUILayout.EndHorizontal();
        }

        #endregion

        #region 交互逻辑

        private void HandleKeyboardShortcuts()
        {
            var evt = Event.current;
            if (evt.type == EventType.KeyDown)
            {
                switch (evt.keyCode)
                {
                    case KeyCode.F5:
                        StartScan(true);
                        evt.Use();
                        break;
                    case KeyCode.Escape:
                        _searchText = "";
                        ApplySearch();
                        evt.Use();
                        break;
                    case KeyCode.F:
                        // 修复3：正确处理Ctrl+F组合键
                        if (evt.control)
                        {
                            GUI.FocusControl("SearchField");
                            evt.Use();
                        }
                        break;
                }
            }
        }

        private void ShowAssetContextMenu(AssetInfo asset)
        {
            var menu = new GenericMenu();

            menu.AddItem(new GUIContent("Ping"), false, () => PingAsset(asset));
            menu.AddItem(new GUIContent("在资源管理器中显示"), false, () => ShowInExplorer(asset));
            menu.AddItem(new GUIContent("复制路径"), false, () => CopyPath(asset));
            menu.AddItem(new GUIContent("复制GUID"), false, () => CopyGUID(asset));
            menu.AddItem(new GUIContent("打开"), false, () => OpenAsset(asset));

            menu.AddSeparator("");

            var favoriteLabel = asset.isFavorite ? "取消收藏" : "收藏";
            menu.AddItem(new GUIContent(favoriteLabel), false, () => ToggleFavorite(asset));

            menu.ShowAsContext();
        }

        #endregion

        #region 扫描管理

        private void StartScan(bool forceFull = false)
        {
            // 清空处理记录
            _pendingAssets.Clear();
            _processedGuids.Clear();
            _previewLoadQueue.Clear();
            
            _statusText = forceFull ? "正在完整扫描..." : "正在扫描变更...";
            _scanTime = EditorApplication.timeSinceStartup;
            Repaint();

            _ = _scanner.StartScanAsync(forceFull ? false : true);
        }

        // 优化：扫描期间仅缓冲资源，大幅降低Repaint频率
        private void OnAssetFound(AssetInfo asset)
        {
            _isDirty = true;
    
            // 更新分类计数
            _categoryCounts.TryGetValue(asset.category, out var count);
            _categoryCounts[asset.category] = count + 1;

            // 添加到待处理队列，不立即过滤
            _pendingAssets.Enqueue(asset);

            // 大幅降低刷新频率：每200个资源刷新一次
            if (_pendingAssets.Count % 200 == 0)
            {
                Repaint();
            }
        }

        // 新增：扫描完成后批量处理待处理资源
        private void ProcessPendingAssets()
        {
            int processed = 0;
            const int BATCH_SIZE = 100; // 每帧最多处理100个

            while (_pendingAssets.TryDequeue(out var asset) && processed < BATCH_SIZE)
            {
                if (_processedGuids.Contains(asset.guid))
                    continue;

                // 执行搜索匹配
                if (_searchEngine.Matches(asset))
                {
                    _filteredAssets.Add(asset);
                }
                
                _processedGuids.Add(asset.guid);
                processed++;
            }

            if (_pendingAssets.Count == 0)
            {
                // 全部处理完成
                UpdateCategoryCounts();
                _isDirty = false;
            }

            Repaint();
        }

        private void OnScanComplete()
        {
            _scanTime = EditorApplication.timeSinceStartup - _scanTime;
            _statusText = $"扫描完成 ({_scanTime:F1}s)";
            
            // 标记需要处理待处理资源
            _isDirty = true;
            
            Repaint();
        }

        private void OnScanError(string error)
        {
            Debug.LogError(error);
            _statusText = $"扫描错误: {error}";
            _isDirty = false;
        }

        private void UpdateCategoryCounts()
        {
            _categoryCounts.Clear();
            // 基于所有已扫描的资源统计
            foreach (var asset in _scanner.CachedAssets.Values)
            {
                _categoryCounts.TryGetValue(asset.category, out var count);
                _categoryCounts[asset.category] = count + 1;
            }
        }

        #endregion

        #region 搜索过滤

        private void ApplySearch()
        {
            _searchEngine.SetSearchQuery(_searchText);
            _searchEngine.SetCategoryFilter(_selectedCategory);

            _filteredAssets.Clear();
            _processedGuids.Clear();

            // 批量处理所有资源
            foreach (var asset in _scanner.CachedAssets.Values)
            {
                if (_searchEngine.Matches(asset))
                {
                    _filteredAssets.Add(asset);
                }
            }

            UpdateCategoryCounts();
            Repaint();
        }

        #endregion

        #region 资产操作

        private void PingAsset(AssetInfo asset)
        {
            var obj = asset.GetAssetObject();
            if (obj != null)
            {
                EditorGUIUtility.PingObject(obj);
                Selection.activeObject = obj;
            }
        }

        private void ShowInExplorer(AssetInfo asset)
        {
            EditorUtility.RevealInFinder(asset.path);
        }

        private void CopyPath(AssetInfo asset)
        {
            EditorGUIUtility.systemCopyBuffer = asset.path;
            _statusText = "路径已复制到剪贴板";
        }

        private void CopyGUID(AssetInfo asset)
        {
            EditorGUIUtility.systemCopyBuffer = asset.guid;
            _statusText = "GUID已复制到剪贴板";
        }

        private void OpenAsset(AssetInfo asset)
        {
            var obj = asset.GetAssetObject();
            if (obj != null)
            {
                AssetDatabase.OpenAsset(obj);
            }
        }

        private void ToggleFavorite(AssetInfo asset)
        {
            asset.isFavorite = !asset.isFavorite;
            if (asset.isFavorite)
            {
                _favorites.Add(asset.path);
            }
            else
            {
                _favorites.Remove(asset.path);
            }
            SaveFavorites();
            Repaint();
        }

        #endregion

        #region 收藏管理

        private void LoadFavorites()
        {
            try
            {
                var saved = EditorPrefs.GetString(PREFS_FAVORITES, "");
                if (!string.IsNullOrEmpty(saved))
                {
                    _favorites.Clear();
                    _favorites.UnionWith(saved.Split('|'));
                }
            }
            catch
            { /* 忽略错误 */
            }
        }

        private void SaveFavorites()
        {
            try
            {
                EditorPrefs.SetString(PREFS_FAVORITES, string.Join("|", _favorites));
            }
            catch
            { /* 忽略错误 */
            }
        }

        #endregion

        #region 导出与设置

        private void ExportAssetList()
        {
            var path = EditorUtility.SaveFilePanel("导出资产列表", "", "asset_list", "csv");
            if (string.IsNullOrEmpty(path)) return;

            try
            {
                using (var writer = new StreamWriter(path))
                {
                    writer.WriteLine("名称,路径,分类,大小,修改时间,GUID");

                    foreach (var asset in _filteredAssets)
                    {
                        writer.WriteLine($"\"{asset.name}\",\"{asset.path}\",{asset.category}," +
                                         $"\"{asset.GetFormattedSize()}\",\"{asset.lastModified:yyyy-MM-dd HH:mm:ss}\"," +
                                         $"\"{asset.guid}\"");
                    }
                }

                _statusText = $"已导出到: {path}";
                EditorUtility.RevealInFinder(path);
            }
            catch (Exception ex)
            {
                Debug.LogError($"导出失败: {ex.Message}");
                _statusText = "导出失败";
            }
        }

        private void ShowSettings()
        {
            if (_settingsWindow == null)
            {
                _settingsWindow = new SettingsWindow(_scanner);
            }
            _settingsWindow.Show();
        }

        #endregion

        #region 工具方法

        private Texture2D GetCategoryIcon(AssetCategory category)
        {
            return category switch
                   {
                       AssetCategory.Textures => EditorGUIUtility.IconContent("Texture Icon").image as Texture2D,
                       AssetCategory.Materials => EditorGUIUtility.IconContent("Material Icon").image as Texture2D,
                       AssetCategory.Models => EditorGUIUtility.IconContent("Mesh Icon").image as Texture2D,
                       AssetCategory.Prefabs => EditorGUIUtility.IconContent("Prefab Icon").image as Texture2D,
                       AssetCategory.Scenes => EditorGUIUtility.IconContent("SceneAsset Icon").image as Texture2D,
                       AssetCategory.Scripts => EditorGUIUtility.IconContent("cs Script Icon").image as Texture2D,
                       AssetCategory.Audio => EditorGUIUtility.IconContent("AudioClip Icon").image as Texture2D,
                       AssetCategory.Animations => EditorGUIUtility.IconContent("AnimationClip Icon").image as Texture2D,
                       _ => EditorGUIUtility.IconContent("DefaultAsset Icon").image as Texture2D
                   };
        }

        // 优化：使用队列异步加载预览图标，避免阻塞UI线程
        private Texture2D GetAssetPreviewIcon(AssetInfo asset)
        {
            if (asset.previewIcon == null)
            {
                // 如果尚未在加载队列中，加入队列
                if (!_previewLoadQueue.Contains(asset))
                {
                    _previewLoadQueue.Enqueue(asset);
                }
                // 返回默认占位图标
                return EditorGUIUtility.IconContent("DefaultAsset Icon").image as Texture2D;
            }
            return asset.previewIcon;
        }

        // 新增：在Update中调用，异步加载预览图标
        private void LoadPreviewIcon(AssetInfo asset)
        {
            if (asset == null) return;
            
            var obj = asset.GetAssetObject();
            if (obj != null)
            {
                asset.previewIcon = AssetPreview.GetMiniThumbnail(obj) ??
                                   (EditorGUIUtility.IconContent("DefaultAsset Icon").image as Texture2D);
            }
        }

        #endregion
    }
    
    public class SplitterState
    {
        public float Value { get; set; }
        public float Min { get; set; }
        public float Max { get; set; }

        public SplitterState(float initial, float min, float max)
        {
            Value = initial;
            Min = min;
            Max = max;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/AssetInfo.cs -->
<!-- GUID: c9535f75d1bf458194b33b5f793857a8 -->
<!-- Size: 1650 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
	/// <summary>
	/// 资产数据模型 - 存储单个资源的元数据
	/// </summary>
	[Serializable]
	public class AssetInfo
	{
		public string guid;            // Unity GUID
		public string name;            // 文件名
		public string path;            // 项目相对路径
		public string extension;       // 扩展名
		public long fileSize;          // 文件大小(字节)
		public DateTime lastModified;  // 最后修改时间
		public AssetCategory category; // 资产分类
		public Object cachedObject;    // 缓存的Unity对象引用
		public bool isFavorite;        // 是否收藏
		public Texture2D previewIcon;  // 预览图标

		// 性能优化：延迟加载
		private bool _objectLoaded = false;

		public Object GetAssetObject()
		{
			if (!_objectLoaded && !string.IsNullOrEmpty(guid))
			{
				string assetPath = AssetDatabase.GUIDToAssetPath(guid);
				if (!string.IsNullOrEmpty(assetPath))
				{
					cachedObject = AssetDatabase.LoadAssetAtPath<Object>(assetPath);
				}
				_objectLoaded = true;
			}
			return cachedObject;
		}

		// 获取格式化的大小字符串
		public string GetFormattedSize()
		{
			const long kb = 1024;
			const long mb = kb * 1024;
			const long gb = mb * 1024;

			if (fileSize >= gb) return $"{fileSize / (float)gb:F2} GB";
			if (fileSize >= mb) return $"{fileSize / (float)mb:F2} MB";
			if (fileSize >= kb) return $"{fileSize / (float)kb:F2} KB";
			return $"{fileSize} B";
		}
	}
}
```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/AssetScanner.cs -->
<!-- GUID: aa20e0fe0da249afa35ffd9c5c7cc60b -->
<!-- Size: 14205 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
    /// <summary>
    /// 异步资源扫描器 - 支持多线程、取消、进度报告和智能缓存
    /// </summary>
    public class AssetScanner
    {
        // ========== 公共属性与事件 ==========
        
        public bool IsScanning { get; private set; }
        public float Progress { get; private set; }
        public string CurrentScanningPath { get; private set; }
        public IReadOnlyDictionary<string, AssetInfo> CachedAssets => _cachedAssets;
        
        public event Action<AssetInfo> OnAssetFound;
        public event Action OnScanComplete;
        public event Action<string> OnError;

        // ========== 私有字段 ==========
        
        private CancellationTokenSource _cancellationTokenSource;
        private readonly HashSet<string> _excludedFolders;
        private readonly List<string> _scanPaths;
        
        // 线程安全的数据结构
        private readonly ConcurrentBag<AssetInfo> _scanResults = new();
        private readonly SemaphoreSlim _maxConcurrencySemaphore;
        
        // 缓存机制
        private Dictionary<string, AssetInfo> _cachedAssets = new();
        private readonly string _cacheFilePath;
        private DateTime _lastFullScanTime;
        private const double CACHE_VALID_HOURS = 24.0; // 缓存有效期24小时

        // ========== 构造函数 ==========
        
        public AssetScanner()
        {
            _excludedFolders = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "Library", "Temp", "obj", "bin", "Logs", "Packages",
                "Assets/ThirdParty", "Assets/Plugins", "Assets/Editor"
            };

            _scanPaths = new List<string> { "Assets" };
            _cacheFilePath = Path.Combine(Application.temporaryCachePath, "AssetExplorerCache_v2.json");
            
            // 根据CPU核心数限制并发数，保留1个核心给主线程
            int maxThreads = Mathf.Max(1, SystemInfo.processorCount - 1);
            _maxConcurrencySemaphore = new SemaphoreSlim(maxThreads, maxThreads);

            LoadCache();
        }

        // ========== 公共方法 ==========
        
        public void SetExcludedFolders(IEnumerable<string> folders)
        {
            _excludedFolders.Clear();
            foreach (var folder in folders)
            {
                _excludedFolders.Add(folder.Replace("\\", "/").TrimEnd('/'));
            }
        }

        /// <summary>
        /// 排除文件夹集合（供外部访问）
        /// </summary>
        public IReadOnlyCollection<string> ExcludedFolders => _excludedFolders;

        /// <summary>
        /// 检查缓存是否有效
        /// </summary>
        public bool IsCacheValid()
        {
            if (!File.Exists(_cacheFilePath)) return false;
            if (_cachedAssets.Count == 0) return false;
            
            var cacheAge = DateTime.UtcNow - _lastFullScanTime;
            return cacheAge.TotalHours < CACHE_VALID_HOURS;
        }

        /// <summary>
        /// 智能启动扫描（仅在需要时）
        /// </summary>
        public async Task StartScanIfNeededAsync()
        {
            if (IsCacheValid())
            {
                Debug.Log("[AssetExplorer] 使用有效缓存，跳过扫描");
                OnScanComplete?.Invoke();
                return;
            }
            
            await StartScanAsync(incremental: false);
        }

        /// <summary>
        /// 主扫描方法 - 多线程优化
        /// </summary>
        public async Task StartScanAsync(bool incremental = false)
        {
            if (IsScanning) return;

            IsScanning = true;
            Progress = 0f;
            _scanResults.Clear();

            _cancellationTokenSource = new CancellationTokenSource();
            var token = _cancellationTokenSource.Token;

            try
            {
                var allFiles = new List<string>();

                // 第一阶段：收集文件路径（单线程快速收集）
                await Task.Run(() =>
                {
                    foreach (var scanPath in _scanPaths)
                    {
                        if (Directory.Exists(scanPath))
                        {
                            CollectFiles(scanPath, allFiles, token);
                        }
                    }
                }, token);

                // 第二阶段：按类型分组并行处理
                int totalCount = allFiles.Count;
                int processedCount = 0;
                var newCache = new Dictionary<string, AssetInfo>();

                // 按扩展名分组，避免线程竞争
                var filesByExtension = allFiles
                    .GroupBy(f => Path.GetExtension(f).ToLowerInvariant())
                    .ToDictionary(g => g.Key, g => g.ToList());

                // 创建处理任务
                var processingTasks = filesByExtension.Select(async kvp =>
                {
                    var files = kvp.Value;
                    
                    await Task.WhenAll(files.Select(async filePath =>
                    {
                        if (token.IsCancellationRequested) return;

                        // 限制并发数
                        await _maxConcurrencySemaphore.WaitAsync(token);
                        
                        try
                        {
                            // 增量更新检查
                            if (incremental && _cachedAssets.TryGetValue(filePath, out var cachedInfo))
                            {
                                var lastWriteTime = File.GetLastWriteTimeUtc(filePath);
                                if (lastWriteTime == cachedInfo.lastModified)
                                {
                                    lock (newCache)
                                    {
                                        newCache[filePath] = cachedInfo;
                                    }
                                    // 优化：降低回调频率，减少UI刷新
                                    lock (this)
                                    {
                                        OnAssetFound?.Invoke(cachedInfo);
                                    }
                                    return;
                                }
                            }

                            var assetInfo = await ProcessFileAsync(filePath);
                            if (assetInfo != null)
                            {
                                lock (newCache)
                                {
                                    newCache[filePath] = assetInfo;
                                }
                                // 优化：降低回调频率
                                lock (this)
                                {
                                    OnAssetFound?.Invoke(assetInfo);
                                }
                            }
                        }
                        finally
                        {
                            _maxConcurrencySemaphore.Release();
                            
                            // 原子操作更新进度
                            var currentCount = Interlocked.Increment(ref processedCount);
                            Progress = (float)currentCount / totalCount;
                            CurrentScanningPath = Path.GetFileName(filePath);
                        }
                    }));
                });

                await Task.WhenAll(processingTasks);

                _cachedAssets = newCache;
                _lastFullScanTime = DateTime.UtcNow;
                SaveCache();

                Progress = 1f;
                OnScanComplete?.Invoke();
            }
            catch (OperationCanceledException)
            {
                Debug.Log("[AssetExplorer] 扫描已取消");
            }
            catch (Exception ex)
            {
                OnError?.Invoke($"扫描失败: {ex.Message}\n{ex.StackTrace}");
            }
            finally
            {
                IsScanning = false;
                CurrentScanningPath = "";
            }
        }

        public void CancelScan()
        {
            _cancellationTokenSource?.Cancel();
        }

        // ========== 私有方法 ==========
        
        /// <summary>
        /// 递归收集文件（支持取消）
        /// </summary>
        private void CollectFiles(string directory, List<string> files, CancellationToken token)
        {
            try
            {
                // 检查取消
                if (token.IsCancellationRequested) return;

                var relativePath = GetRelativePath(directory);
                if (_excludedFolders.Any(excluded =>
                    relativePath.StartsWith(excluded, StringComparison.OrdinalIgnoreCase)))
                    return;

                // 获取文件
                foreach (var file in Directory.GetFiles(directory))
                {
                    if (token.IsCancellationRequested) return;

                    var ext = Path.GetExtension(file);
                    if (IsValidAssetFile(ext) && !file.EndsWith(".meta"))
                    {
                        files.Add(file);
                    }
                }

                // 递归子目录
                foreach (var subDir in Directory.GetDirectories(directory))
                {
                    CollectFiles(subDir, files, token);
                }
            }
            catch (Exception ex)
            {
                OnError?.Invoke($"访问目录失败: {directory}\n{ex.Message}");
            }
        }

        private async Task<AssetInfo> ProcessFileAsync(string filePath)
        {
            await Task.Yield(); // 确保异步

            try
            {
                var fileInfo = new FileInfo(filePath);
                var relativePath = GetRelativePath(filePath);
                var guid = AssetDatabase.AssetPathToGUID(relativePath);

                if (string.IsNullOrEmpty(guid))
                {
                    AssetDatabase.ImportAsset(relativePath, ImportAssetOptions.ForceSynchronousImport);
                    guid = AssetDatabase.AssetPathToGUID(relativePath);
                }

                if (string.IsNullOrEmpty(guid))
                    return null;

                return new AssetInfo
                {
                    guid = guid,
                    name = Path.GetFileNameWithoutExtension(filePath),
                    path = relativePath,
                    extension = Path.GetExtension(filePath).ToLower(),
                    fileSize = fileInfo.Length,
                    lastModified = fileInfo.LastWriteTimeUtc,
                    category = CategoryManager.GetCategory(Path.GetExtension(filePath))
                };
            }
            catch
            {
                return null;
            }
        }

        private bool IsValidAssetFile(string extension)
        {
            if (string.IsNullOrEmpty(extension)) return false;
            var invalidExtensions = new[] { ".meta", ".tmp", ".temp", ".log", ".pid" };
            return !invalidExtensions.Contains(extension, StringComparer.OrdinalIgnoreCase);
        }

        private string GetRelativePath(string fullPath)
        {
            string projectPath = Directory.GetParent(Application.dataPath).FullName;
            return fullPath.Replace(projectPath + Path.DirectorySeparatorChar, "")
                          .Replace('\\', '/');
        }

        // ========== 缓存持久化 ==========
        
        #region 缓存持久化

        private void LoadCache()
        {
            if (!File.Exists(_cacheFilePath)) return;

            try
            {
                var json = File.ReadAllText(_cacheFilePath);
                var wrapper = JsonUtility.FromJson<CacheWrapper>(json);
                if (wrapper?.assets != null && wrapper.timestamp > 0)
                {
                    _cachedAssets = wrapper.assets.ToDictionary(a => a.path);
                    _lastFullScanTime = DateTime.FromFileTimeUtc(wrapper.timestamp);
                    Debug.Log($"[AssetExplorer] 已加载 {wrapper.assets.Length} 条缓存记录");
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[AssetExplorer] 加载缓存失败: {ex.Message}");
                _cachedAssets.Clear();
            }
        }

        private void SaveCache()
        {
            try
            {
                var wrapper = new CacheWrapper
                {
                    assets = _cachedAssets.Values.ToArray(),
                    timestamp = DateTime.UtcNow.ToFileTimeUtc()
                };
                
                var json = JsonUtility.ToJson(wrapper, true);
                Directory.CreateDirectory(Path.GetDirectoryName(_cacheFilePath));
                File.WriteAllText(_cacheFilePath, json);
                
                Debug.Log($"[AssetExplorer] 已保存 {wrapper.assets.Length} 条缓存记录");
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[AssetExplorer] 保存缓存失败: {ex.Message}");
            }
        }

        [Serializable]
        private class CacheWrapper
        {
            public AssetInfo[] assets;
            public long timestamp;
        }

        #endregion
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/CategoryManager.cs -->
<!-- GUID: f1e9fcaafdba4d82afc26ae9f60abbef -->
<!-- Size: 2500 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System.Collections.Generic;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
	/// <summary>
	/// 分类管理器 - 扩展性强的插件式架构
	/// </summary>
	public class CategoryManager
	{
		private static readonly Dictionary<string, AssetCategory> _extensionMap = new()
		{
			// 纹理
			{ ".png", AssetCategory.Textures }, { ".jpg", AssetCategory.Textures },
			{ ".jpeg", AssetCategory.Textures }, { ".tga", AssetCategory.Textures },
			{ ".tif", AssetCategory.Textures }, { ".bmp", AssetCategory.Textures },
			{ ".psd", AssetCategory.Textures }, { ".exr", AssetCategory.Textures },
			{ ".hdr", AssetCategory.Textures },

			// 材质
			{ ".mat", AssetCategory.Materials },

			// 模型
			{ ".fbx", AssetCategory.Models }, { ".obj", AssetCategory.Models },
			{ ".blend", AssetCategory.Models }, { ".max", AssetCategory.Models },
			{ ".ma", AssetCategory.Models }, { ".mb", AssetCategory.Models },

			// 预制件
			{ ".prefab", AssetCategory.Prefabs },

			// 场景
			{ ".unity", AssetCategory.Scenes },

			// 脚本
			{ ".cs", AssetCategory.Scripts }, { ".shader", AssetCategory.Shaders },
			{ ".hlsl", AssetCategory.Shaders }, { ".cginc", AssetCategory.Shaders },

			// 音频
			{ ".mp3", AssetCategory.Audio }, { ".wav", AssetCategory.Audio },
			{ ".ogg", AssetCategory.Audio }, { ".aif", AssetCategory.Audio },
			{ ".aiff", AssetCategory.Audio },

			// 动画
			{ ".anim", AssetCategory.Animations }, { ".controller", AssetCategory.Animations },

			// 字体
			{ ".ttf", AssetCategory.Fonts }, { ".otf", AssetCategory.Fonts },

			// 视频
			{ ".mp4", AssetCategory.Videos }, { ".mov", AssetCategory.Videos },
			{ ".avi", AssetCategory.Videos }, { ".webm", AssetCategory.Videos },

			// 文档
			{ ".txt", AssetCategory.Documents }, { ".json", AssetCategory.Documents },
			{ ".xml", AssetCategory.Documents }, { ".md", AssetCategory.Documents },
			{ ".pdf", AssetCategory.Documents }
		};

		public static AssetCategory GetCategory(string extension)
		{
			if (string.IsNullOrEmpty(extension))
				return AssetCategory.Others;

			extension = extension.ToLowerInvariant();
			return _extensionMap.TryGetValue(extension, out var category) ? category : AssetCategory.Others;
		}

		// 支持动态添加分类规则
		public static void RegisterExtension(string extension, AssetCategory category)
		{
			_extensionMap[extension.ToLowerInvariant()] = category;
		}
	}
}
```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/SearchEngine.cs -->
<!-- GUID: be31f7ebff5f4de39897804570fc8b50 -->
<!-- Size: 3480 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEditor;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
	public class SearchEngine
	{
		public enum SearchMode
		{
			Fuzzy, // 模糊搜索
			Exact, // 精确匹配
			Regex, // 正则表达式
			Path   // 路径搜索
		}

		// 修复3：使字段可访问
		public SearchMode _mode = SearchMode.Fuzzy;
		private string _searchQuery = "";
		private AssetCategory _categoryFilter = AssetCategory.All;

		// 保存的搜索条件
		private readonly List<string> _savedSearches = new();
		private const string PREFS_KEY = "AssetExplorer_SavedSearches";

		public SearchEngine()
		{
			LoadSavedSearches();
		}

		public void SetSearchQuery(string query, SearchMode mode = SearchMode.Fuzzy)
		{
			_searchQuery = query?.ToLowerInvariant() ?? "";
			_mode = mode;
		}

		public void SetCategoryFilter(AssetCategory category)
		{
			_categoryFilter = category;
		}

		public bool Matches(AssetInfo asset)
		{
			if (asset == null) return false;

			// 分类过滤
			if (_categoryFilter != AssetCategory.All && asset.category != _categoryFilter)
				return false;

			// 空搜索词返回全部
			if (string.IsNullOrEmpty(_searchQuery))
				return true;

			return _mode switch
			       {
				       SearchMode.Fuzzy => FuzzyMatch(asset),
				       SearchMode.Exact => ExactMatch(asset),
				       SearchMode.Regex => RegexMatch(asset),
				       SearchMode.Path => PathMatch(asset),
				       _ => false
			       };
		}

		private bool FuzzyMatch(AssetInfo asset)
		{
			var searchParts = _searchQuery.Split(' ', StringSplitOptions.RemoveEmptyEntries);
			var targetText = $"{asset.name} {asset.extension} {asset.path}".ToLowerInvariant();

			return searchParts.All(part => targetText.Contains((string)part));
		}

		private bool ExactMatch(AssetInfo asset)
		{
			return asset.name.Equals(_searchQuery, StringComparison.OrdinalIgnoreCase) ||
			       asset.extension.Equals(_searchQuery, StringComparison.OrdinalIgnoreCase);
		}

		private bool RegexMatch(AssetInfo asset)
		{
			try
			{
				return Regex.IsMatch(asset.name, _searchQuery, RegexOptions.IgnoreCase) ||
				       Regex.IsMatch(asset.path, _searchQuery, RegexOptions.IgnoreCase);
			}
			catch
			{
				return false; // 无效正则
			}
		}

		private bool PathMatch(AssetInfo asset)
		{
			return asset.path.ToLowerInvariant().Contains(_searchQuery);
		}

		#region 保存搜索

		public void SaveCurrentSearch()
		{
			if (!string.IsNullOrWhiteSpace(_searchQuery) && !_savedSearches.Contains(_searchQuery))
			{
				_savedSearches.Add(_searchQuery);
				if (_savedSearches.Count > 10) // 限制数量
					_savedSearches.RemoveAt(0);

				SaveSavedSearches();
			}
		}

		public IReadOnlyList<string> GetSavedSearches() => _savedSearches;

		private void LoadSavedSearches()
		{
			try
			{
				var saved = EditorPrefs.GetString(PREFS_KEY, "");
				if (!string.IsNullOrEmpty(saved))
				{
					_savedSearches.AddRange(saved.Split('|', StringSplitOptions.RemoveEmptyEntries));
				}
			}
			catch
			{ /* 忽略加载错误 */
			}
		}

		private void SaveSavedSearches()
		{
			try
			{
				EditorPrefs.SetString(PREFS_KEY, string.Join("|", _savedSearches));
			}
			catch
			{ /* 忽略保存错误 */
			}
		}

		#endregion
	}
}
```

<!-- File: Asaki/Editor/Utilities/Tools/AssetsExplore/SettingsWindow.cs -->
<!-- GUID: c4ccce50ef50417caac583a056df97a6 -->
<!-- Size: 2410 bytes -->
<!-- Modified: 2025-12-22 16:41:31 -->
```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.AssetsExplore
{
    public class SettingsWindow : EditorWindow
    {
        private AssetScanner _scanner;
        private Vector2 _scrollPos;
        private string _newExcludedFolder = "";
        private List<string> _excludedFolders;

        public SettingsWindow(AssetScanner scanner)
        {
            _scanner = scanner ?? throw new System.ArgumentNullException(nameof(scanner));
            // 安全转换：从 IReadOnlyCollection 转为 List
            _excludedFolders = scanner.ExcludedFolders?.ToList() ?? new List<string>();
        }

        private void OnGUI()
        {
            titleContent = new GUIContent("扫描设置");

            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);

            EditorGUILayout.LabelField("排除文件夹", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("这些文件夹将被忽略，不扫描其中的资源", MessageType.Info);

            // 显示现有排除项
            for (int i = 0; i < _excludedFolders.Count; i++)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(_excludedFolders[i]);
                if (GUILayout.Button("移除", GUILayout.Width(50)))
                {
                    _excludedFolders.RemoveAt(i);
                    i--;
                }
                EditorGUILayout.EndHorizontal();
            }

            // 添加新排除项
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            _newExcludedFolder = EditorGUILayout.TextField("新文件夹:", _newExcludedFolder);
            if (GUILayout.Button("添加", GUILayout.Width(50)))
            {
                if (!string.IsNullOrWhiteSpace(_newExcludedFolder))
                {
                    _excludedFolders.Add(_newExcludedFolder.TrimEnd('/', '\\'));
                    _newExcludedFolder = "";
                }
            }
            EditorGUILayout.EndHorizontal();

            if (GUILayout.Button("保存设置"))
            {
                _scanner.SetExcludedFolders(_excludedFolders);
                Close();
            }

            EditorGUILayout.EndScrollView();
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/BatchRename/BatchRenameEditorWindow.cs -->
<!-- GUID: b1e78b729d934a09aedebdcff7eb0661 -->
<!-- Size: 10543 bytes -->
<!-- Modified: 2025-12-24 23:02:18 -->
```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.BatchRename
{
    /// <summary>
    /// 场景对象批量重命名工具（IMGUI优化版）
    /// 架构特点：零依赖、高性能、Undo安全、生产级健壮性
    /// 快捷键：Alt + F2
    /// </summary>
    public class BatchRenameEditorWindow : EditorWindow
    {
        // 序列化状态：窗口关闭后保留输入
        [SerializeField] private string _prefix = "";
        [SerializeField] private string _suffix = "";
        [SerializeField] private bool _showPreview = true;
        [SerializeField] private Vector2 _scrollPos;

        // 业务数据
        private RenameOperation[] _previewOps = new RenameOperation[0];
        private Dictionary<int, string> _conflicts = new Dictionary<int, string>();
        
        // 服务层（纯逻辑，可单元测试）
        private readonly BatchRenameService _service = new();
        
        // GUIStyle缓存：避免每帧创建，消除GC
        private GUIStyle _conflictStyle;
        private GUIStyle _normalStyle;
        private GUIStyle _infoBoxStyle;
        private bool _stylesInitialized;

        // 常量配置：集中管理，便于维护
        private const string WINDOW_TITLE = "批量重命名";
        private const string PREVIEW_FOLDOUT_FORMAT = "预览 ({0} 对象)";
        private const string NO_SELECTION_TIP = "请先选中至少一个GameObject";
        private const string CONFLICT_TIP_FORMAT = "检测到 {0} 个命名冲突，请调整规则";
        private const string UNDO_GROUP_NAME_FORMAT = "批量重命名 {0} 个对象";

        [MenuItem("Asaki/Tools/Batch Rename &F2")]
        public static void ShowWindow()
        {
            var window = GetWindow<BatchRenameEditorWindow>();
            window.titleContent = new GUIContent(WINDOW_TITLE);
            window.minSize = new Vector2(450, 300);
            window.Show();
        }

        private void OnEnable()
        {
            // 立即刷新，确保窗口打开时显示当前选择
            RefreshPreview();
        }

        private void OnGUI()
        {
            // 懒初始化GUIStyle：只在首次OnGUI时创建
            if (!_stylesInitialized)
            {
                InitializeStyles();
                _stylesInitialized = true;
            }

            // 主布局：垂直分组
            EditorGUILayout.BeginVertical(Styles.MainContainer);
            
            DrawInputSection();
            DrawPreviewSection();
            DrawActionButtons();
            
            EditorGUILayout.EndVertical();
        }

        #region 输入区域

        private void DrawInputSection()
        {
            EditorGUILayout.LabelField("命名规则", Styles.SectionTitle);
            
            EditorGUI.BeginChangeCheck();
            _prefix = EditorGUILayout.TextField("前缀", _prefix);
            _suffix = EditorGUILayout.TextField("后缀", _suffix);
            
            if (EditorGUI.EndChangeCheck())
            {
                RefreshPreview(); // 实时刷新，防抖由IMGUI自动处理
            }
        }

        #endregion

        #region 预览区域

        private void DrawPreviewSection()
        {
            EditorGUILayout.Space(4f);
            
            var previewHeader = string.Format(PREVIEW_FOLDOUT_FORMAT, _previewOps.Length);
            _showPreview = EditorGUILayout.Foldout(_showPreview, previewHeader, true);
            
            if (!_showPreview) return;

            if (_previewOps.Length == 0)
            {
                EditorGUILayout.HelpBox(NO_SELECTION_TIP, MessageType.Info);
                return;
            }

            // 滚动视图：支持大量对象
            using var scrollScope = new EditorGUILayout.ScrollViewScope(_scrollPos, Styles.PreviewScroll);
            _scrollPos = scrollScope.scrollPosition;

            // 使用Box容器提升视觉层次
            EditorGUILayout.BeginVertical(Styles.PreviewBox);
            
            for (int i = 0; i < _previewOps.Length; i++)
            {
                DrawPreviewItem(_previewOps[i], i);
                // 分隔线：提升可读性
                if (i < _previewOps.Length - 1)
                    GUILayout.Box("", GUILayout.ExpandWidth(true), GUILayout.Height(1f));
            }
            
            EditorGUILayout.EndVertical();
            
            // 冲突提示：独立区域，红色警示
            DrawConflictWarning();
        }

        private void DrawPreviewItem(RenameOperation op, int index)
        {
            var hasConflict = _conflicts.ContainsKey(op.InstanceId);
            var style = hasConflict ? _conflictStyle : _normalStyle;

            EditorGUILayout.BeginHorizontal(Styles.PreviewItem);
            
            // 索引：灰色小字体
            EditorGUILayout.LabelField($"#{index + 1}", Styles.IndexLabel, GUILayout.Width(30f));
            
            // 图标：固定宽度
            EditorGUILayout.LabelField(EditorGUIUtility.IconContent("GameObject Icon"), 
                GUILayout.Width(20f), GUILayout.Height(20f));

            // 原始名称：受限宽度，过长截断
            EditorGUILayout.LabelField(op.OriginalName, style, GUILayout.Width(150f));

            // 箭头：居中
            EditorGUILayout.LabelField("→", Styles.ArrowLabel, GUILayout.Width(20f));

            // 新名称：弹性宽度
            var newNameLabel = hasConflict ? $"{op.NewName} (冲突!)" : op.NewName;
            EditorGUILayout.LabelField(newNameLabel, style, GUILayout.ExpandWidth(true));

            EditorGUILayout.EndHorizontal();
        }

        private void DrawConflictWarning()
        {
            if (_conflicts.Count == 0) return;
            
            EditorGUILayout.Space(4f);
            var message = string.Format(CONFLICT_TIP_FORMAT, _conflicts.Count);
            EditorGUILayout.HelpBox(message, MessageType.Error);
        }

        #endregion

        #region 操作按钮

        private void DrawActionButtons()
        {
            EditorGUILayout.Space(8f);
            
            EditorGUILayout.BeginHorizontal();
            
            // 应用按钮：冲突时禁用
            var canApply = _conflicts.Count == 0 && _previewOps.Length > 0;
            using (new EditorGUI.DisabledScope(!canApply))
            {
                if (GUILayout.Button("应用", Styles.ApplyButton, GUILayout.Height(28f)))
                {
                    OnApply();
                }
            }

            if (GUILayout.Button("取消", Styles.CancelButton, GUILayout.Height(28f)))
            {
                Close();
            }

            EditorGUILayout.EndHorizontal();
        }

        #endregion

        #region 业务逻辑

        private void RefreshPreview()
        {
            var selected = Selection.GetFiltered<GameObject>(SelectionMode.TopLevel);
            _previewOps = _service.GeneratePreview(selected, _prefix, _suffix);
            _conflicts = _service.DetectConflicts(_previewOps);
        }

        private void OnApply()
        {
            if (_previewOps.Length == 0) return;

            var undoName = string.Format(UNDO_GROUP_NAME_FORMAT, _previewOps.Length);
            using var undoScope = new UndoScope(undoName);

            foreach (var op in _previewOps)
            {
                if (!op.TryGetGameObject(out var go)) continue;

                Undo.RegisterCompleteObjectUndo(go, "Rename GameObject");
                op.Apply();
            }

            Close();
        }

        private void OnSelectionChange()
        {
            RefreshPreview();
            Repaint(); // 强制重绘，更新预览
        }

        #endregion

        #region 样式初始化

        private void InitializeStyles()
        {
            _normalStyle = new GUIStyle(EditorStyles.label)
            {
                richText = false
            };

            _conflictStyle = new GUIStyle(EditorStyles.label)
            {
                normal = { textColor = Color.red },
                fontStyle = FontStyle.Bold
            };

            _infoBoxStyle = new GUIStyle(EditorStyles.helpBox)
            {
                margin = new RectOffset(4, 4, 4, 4)
            };
        }

        // 静态样式类：便于复用和主题切换
        private static class Styles
        {
            public static readonly GUIStyle MainContainer = new GUIStyle
            {
                padding = new RectOffset(8, 8, 8, 8)
            };

            public static readonly GUIStyle SectionTitle = new GUIStyle(EditorStyles.boldLabel)
            {
                fontSize = 14,
                margin = new RectOffset(0, 0, 8, 8)
            };

            public static readonly GUIStyle PreviewScroll = new GUIStyle
            {
                padding = new RectOffset(2, 2, 2, 2)
            };

            public static readonly GUIStyle PreviewBox = new GUIStyle(EditorStyles.helpBox)
            {
                padding = new RectOffset(4, 4, 4, 4)
            };

            public static readonly GUIStyle PreviewItem = new GUIStyle
            {
                margin = new RectOffset(0, 0, 2, 2)
            };

            public static readonly GUIStyle IndexLabel = new GUIStyle(EditorStyles.miniLabel)
            {
                alignment = TextAnchor.MiddleRight,
                normal = { textColor = Color.gray }
            };

            public static readonly GUIStyle ArrowLabel = new GUIStyle(EditorStyles.label)
            {
                alignment = TextAnchor.MiddleCenter,
                normal = { textColor = new Color(0.5f, 0.5f, 0.5f, 1f) }
            };

            public static readonly GUIStyle ApplyButton = new GUIStyle(GUI.skin.button)
            {
                fontSize = 13,
                fontStyle = FontStyle.Bold
            };

            public static readonly GUIStyle CancelButton = new GUIStyle(GUI.skin.button)
            {
                fontSize = 13
            };
        }

        #endregion
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/BatchRename/BatchRenameService.cs -->
<!-- GUID: ebfa56ecbcec404c80bf565003b62d57 -->
<!-- Size: 5834 bytes -->
<!-- Modified: 2025-12-24 22:43:45 -->
```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.BatchRename
{
    /// <summary>
    /// 批量重命名业务服务
    /// 设计原则：纯逻辑层，零GUI依赖，便于单元测试和复用
    /// </summary>
    public class BatchRenameService
    {
        /// <summary>
        /// 命名策略接口：预留扩展点（序号、查找替换等）
        /// </summary>
        public interface INamingStrategy
        {
            /// <summary>
            /// 生成新名称
            /// </summary>
            /// <param name="original">原始名称</param>
            /// <param name="prefix">用户输入的前缀</param>
            /// <param name="suffix">用户输入的后缀</param>
            string GenerateName(string original, string prefix, string suffix);
        }

        /// <summary>
        /// 默认策略：简单前缀+后缀拼接
        /// </summary>
        public class DefaultNamingStrategy : INamingStrategy
        {
            public string GenerateName(string original, string prefix, string suffix)
            {
                // 防御性处理：空字符串不添加分隔符
                return $"{prefix}{original}{suffix}";
            }
        }

        /// <summary>
        /// 序号策略：为每个对象添加递增序号
        /// 示例：Cube → Prefix_Cube_001_Suffix
        /// </summary>
        public class SerialNamingStrategy : INamingStrategy
        {
            private int _startIndex;
            private int _padding;

            public SerialNamingStrategy(int startIndex = 1, int padding = 3)
            {
                _startIndex = startIndex;
                _padding = padding;
            }

            public string GenerateName(string original, string prefix, string suffix)
            {
                var serial = (_startIndex++).ToString().PadLeft(_padding, '0');
                return $"{prefix}{original}_{serial}{suffix}";
            }
        }

        /// <summary>
        /// 生成预览操作列表
        /// 性能：O(n)时间复杂度，单次遍历
        /// 过滤：自动移除null和已销毁对象
        /// </summary>
        /// <param name="targets">选中的GameObject数组</param>
        /// <param name="prefix">前缀</param>
        /// <param name="suffix">后缀</param>
        /// <param name="strategy">命名策略（可选）</param>
        public RenameOperation[] GeneratePreview(
            GameObject[] targets,
            string prefix,
            string suffix,
            INamingStrategy strategy = null)
        {
            strategy ??= new DefaultNamingStrategy();
            
            // 防御性编程：处理targets为null的情况
            if (targets == null || targets.Length == 0)
                return new RenameOperation[0];

            // 性能优化：预分配数组，避免Linq迭代器GC压力
            var operations = new List<RenameOperation>(targets.Length);
            foreach (var go in targets)
            {
                if (go == null) continue; // 过滤已销毁对象
                
                var newName = strategy.GenerateName(go.name, prefix, suffix);
                operations.Add(RenameOperation.CreateFrom(go, newName));
            }

            return operations.ToArray();
        }

        /// <summary>
        /// 检测命名冲突
        /// 算法：GroupBy分组，筛选count>1的组，O(n log n)复杂度
        /// 返回：冲突对象的InstanceID → 冲突名称映射表
        /// </summary>
        public Dictionary<int, string> DetectConflicts(RenameOperation[] operations)
        {
            var conflicts = new Dictionary<int, string>();
            
            if (operations == null || operations.Length == 0)
                return conflicts;

            // 使用GroupBy检测重复名称
            var duplicateGroups = operations
                .GroupBy(op => op.NewName)
                .Where(g => g.Count() > 1);

            // 将冲突项加入字典
            foreach (var group in duplicateGroups)
            {
                foreach (var op in group)
                {
                    conflicts[op.InstanceId] = op.NewName;
                }
            }

            return conflicts;
        }

        /// <summary>
        /// 验证操作的有效性
        /// 检查：对象是否存在、名称是否未变更、是否有冲突
        /// </summary>
        public ValidationResult ValidateOperation(RenameOperation op, Dictionary<int, string> conflictMap)
        {
            if (op == null)
                return ValidationResult.Invalid("操作对象为空");

            if (!op.TryGetGameObject(out _))
                return ValidationResult.Invalid("目标对象已销毁或不存在");

            if (op.OriginalName == op.NewName)
                return ValidationResult.Invalid("名称未变更");

            if (conflictMap?.ContainsKey(op.InstanceId) ?? false)
                return ValidationResult.Invalid($"命名冲突: {op.NewName}");

            return ValidationResult.Valid;
        }

        /// <summary>
        /// 验证结果结构体
        /// </summary>
        public struct ValidationResult
        {
            public bool IsValid;
            public string ErrorMessage;

            public static ValidationResult Valid => new() { IsValid = true };
            public static ValidationResult Invalid(string message) => new() 
            { 
                IsValid = false, 
                ErrorMessage = message 
            };
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/BatchRename/RenameOperation.cs -->
<!-- GUID: 42fcea50e9844553b71cb3c1ee36d0f1 -->
<!-- Size: 2894 bytes -->
<!-- Modified: 2025-12-24 22:42:59 -->
```csharp
using System;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.BatchRename
{
    /// <summary>
    /// 不可变的重命名操作记录，用于Undo/Redo系统
    /// 关键设计：使用InstanceID而非直接引用，解决场景重加载后的引用丢失问题
    /// </summary>
    [Serializable]
    public class RenameOperation
    {
        [SerializeField] private string _originalName;
        [SerializeField] private string _newName;
        [SerializeField] private int _instanceId;

        /// <summary>
        /// 原始名称（用于回滚）
        /// </summary>
        public string OriginalName => _originalName;

        /// <summary>
        /// 新名称（用于应用）
        /// </summary>
        public string NewName => _newName;

        /// <summary>
        /// 目标GameObject的InstanceID（唯一标识）
        /// </summary>
        public int InstanceId => _instanceId;

        /// <summary>
        /// 尝试获取目标GameObject
        /// 安全性：处理场景卸载、对象销毁等边界情况
        /// </summary>
        public bool TryGetGameObject(out GameObject go)
        {
            // EditorUtility.InstanceIDToObject能处理跨Undo重加载的场景
            go = EditorUtility.InstanceIDToObject(_instanceId) as GameObject;
            return go != null;
        }

        /// <summary>
        /// 应用重命名操作
        /// 自动标记对象为Dirty，确保变更可被序列化保存
        /// </summary>
        public void Apply()
        {
            if (TryGetGameObject(out var go) && go.name != _newName)
            {
                go.name = _newName;
                EditorUtility.SetDirty(go); // 关键：必须标记，否则Undo无法捕获状态
            }
        }

        /// <summary>
        /// 回滚重命名操作
        /// 安全性：仅当当前名称匹配_newName时才回滚，防止意外覆盖
        /// </summary>
        public void Revert()
        {
            if (TryGetGameObject(out var go) && go.name == _newName)
            {
                go.name = _originalName;
                EditorUtility.SetDirty(go);
            }
        }

        /// <summary>
        /// 工厂方法：从GameObject创建操作记录
        /// 封装正确性：确保InstanceID和名称快照的准确性
        /// </summary>
        public static RenameOperation CreateFrom(GameObject target, string newName)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));

            return new RenameOperation
            {
                _originalName = target.name,
                _newName = newName,
                _instanceId = target.GetInstanceID()
            };
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/BatchRename/UndoScope.cs -->
<!-- GUID: a61f20d179a3493abaa1f4d94237bfb6 -->
<!-- Size: 1256 bytes -->
<!-- Modified: 2025-12-24 22:44:04 -->
```csharp
using UnityEditor;

namespace Asaki.Editor.Utilities.Tools.BatchRename
{
	/// <summary>
	/// Undo作用域封装，确保批量操作的原子性
	/// 使用IDisposable模式，支持using语法糖
	/// 关键：与Selection和Inspector的Undo系统无缝集成
	/// </summary>
	public struct UndoScope : System.IDisposable
	{
		private string _groupName;
		private bool _disposed;
		private int _undoGroupIndex;

		/// <summary>
		/// 开启一个新的Undo组
		/// </summary>
		/// <param name="groupName">在Undo历史列表中显示的名称</param>
		public UndoScope(string groupName)
		{
			_groupName = groupName;
			_disposed = false;
			_undoGroupIndex = Undo.GetCurrentGroup();
            
			Undo.IncrementCurrentGroup(); // 创建新组，后续操作归入此组
		}

		/// <summary>
		/// 设置Undo组名称并完成作用域
		/// </summary>
		public void Dispose()
		{
			if (!_disposed)
			{
				// 设置组名称，用户可通过Ctrl/Cmd+Z一次性撤销整个操作
				Undo.SetCurrentGroupName(_groupName);
                
				// 可选：合并操作，减少Undo历史条目
				Undo.CollapseUndoOperations(_undoGroupIndex);
                
				_disposed = true;
			}
		}
	}
}
```

<!-- File: Asaki/Editor/Utilities/Tools/DuplicateFinder/AsakiDuplicateFinderWindow.cs -->
<!-- GUID: 201d70318e4842d78e313c365780e885 -->
<!-- Size: 5884 bytes -->
<!-- Modified: 2025-12-25 14:54:19 -->
```csharp
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.DuplicateFinder
{
    public class AsakiDuplicateFinderWindow : EditorWindow
    {
        private float _tolerance = 0.05f;
        private List<DuplicateGroup> _groups;
        private Vector2 _scrollPos;

        // 样式配置
        private static readonly Color HighlightColor = new Color(1f, 0.2f, 0.2f, 1f); // 红色高亮
        private static readonly Color FillColor = new Color(1f, 0.2f, 0.2f, 0.1f);

        [MenuItem("Asaki/Tools/Duplicate Finder")]
        public static void Open()
        {
            var win = GetWindow<AsakiDuplicateFinderWindow>("Duplicate Finder");
            win.Show();
        }

        private void OnEnable()
        {
            // 订阅场景重绘事件，实现 SceneView 高亮
            SceneView.duringSceneGui += OnSceneGUI;
        }

        private void OnDisable()
        {
            SceneView.duringSceneGui -= OnSceneGUI;
        }

        private void OnGUI()
        {
            DrawHeader();
            DrawSettings();
            DrawResults();
        }

        private void DrawHeader()
        {
            EditorGUILayout.LabelField("Asaki Duplicate Finder", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("检测场景中位置重叠且外观相同的物体。\n红色线框将在 Scene 视图中标记它们。", MessageType.Info);
        }

        private void DrawSettings()
        {
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                _tolerance = EditorGUILayout.Slider("Pos Tolerance", _tolerance, 0.001f, 1.0f);

                if (GUILayout.Button("Scan Scene", GUILayout.Height(30)))
                {
                    PerformScan();
                }
            }
        }

        private void DrawResults()
        {
            if (_groups == null) return;

            EditorGUILayout.Space();
            GUILayout.Label($"Found Groups: {_groups.Count}", EditorStyles.boldLabel);

            if (_groups.Count > 0)
            {
                GUI.backgroundColor = Color.red;
                if (GUILayout.Button("Select All Duplicates (For Deletion)", GUILayout.Height(30)))
                {
                    SelectAllDuplicates();
                }
                GUI.backgroundColor = Color.white;
            }

            using (var scroll = new EditorGUILayout.ScrollViewScope(_scrollPos))
            {
                _scrollPos = scroll.scrollPosition;
                foreach (var group in _groups)
                {
                    using (new EditorGUILayout.HorizontalScope(EditorStyles.helpBox))
                    {
                        if (group.Original == null) continue;

                        GUILayout.Label($"{group.Original.name}", EditorStyles.boldLabel, GUILayout.Width(150));
                        GUILayout.Label($"Contains {group.Duplicates.Count} Copies", EditorStyles.miniLabel);

                        if (GUILayout.Button("Select Group", GUILayout.Width(100)))
                        {
                            var all = new List<Object> { group.Original };
                            all.AddRange(group.Duplicates);
                            Selection.objects = all.ToArray();
                            SceneView.FrameLastActiveSceneView();
                        }
                    }
                }
            }
        }

        // 核心可视化逻辑：在 Scene 窗口绘制
        private void OnSceneGUI(SceneView sceneView)
        {
            if (_groups == null || _groups.Count == 0) return;

            Handles.color = HighlightColor;
            
            foreach (var group in _groups)
            {
                if (group.Original == null) continue;

                // 绘制线框
                Handles.DrawWireCube(group.WorldBounds.center, group.WorldBounds.size);
                
                // 绘制半透明填充（增强可见性）
                Handles.color = FillColor;
                Handles.DrawWireCube(group.WorldBounds.center, group.WorldBounds.size);
                Handles.color = HighlightColor;

                // 绘制文字标签
                Handles.Label(group.WorldBounds.center + Vector3.up * group.WorldBounds.extents.y, 
                    $"⚠ {group.Duplicates.Count} Duplicates");

                // 绘制连接线，指向所有重叠物体（如果稍微有点偏移的话能看出来）
                foreach (var dup in group.Duplicates)
                {
                    if(dup != null)
                        Handles.DrawLine(group.WorldBounds.center, dup.transform.position);
                }
            }

            // 强制刷新 SceneView，防止绘制卡顿或消失
            sceneView.Repaint();
        }

        private void PerformScan()
        {
            _groups = AsakiDuplicateFinderLogic.FindDuplicates(_tolerance);
            if (_groups.Count == 0)
            {
                EditorUtility.DisplayDialog("Result", "No duplicates found!", "OK");
            }
            SceneView.RepaintAll();
        }

        private void SelectAllDuplicates()
        {
            var selection = new List<Object>();
            foreach (var group in _groups)
            {
                // 只选中副本，不选中原件
                foreach (var dup in group.Duplicates)
                {
                    if (dup != null) selection.Add(dup);
                }
            }
            Selection.objects = selection.ToArray();
            Debug.Log($"[Asaki Finder] Selected {selection.Count} duplicates.");
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/DuplicateFinder/DuplicateGroup.cs -->
<!-- GUID: e4bfbafbd8f04ce7bf0a8556927b96c9 -->
<!-- Size: 3416 bytes -->
<!-- Modified: 2025-12-25 15:15:32 -->
```csharp
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.DuplicateFinder
{
    public class DuplicateGroup
    {
        public GameObject Original;
        public List<GameObject> Duplicates = new List<GameObject>();
        public Bounds WorldBounds; // 用于绘制高光
    }

    public static class AsakiDuplicateFinderLogic
    {
        /// <summary>
        /// 查找重复物体
        /// 判定标准：位置极度接近 且 使用相同的 Mesh/Sprite
        /// </summary>
        public static List<DuplicateGroup> FindDuplicates(float positionTolerance = 0.01f)
        {
            var results = new List<DuplicateGroup>();
            
            // 1. 获取场景中所有有效的渲染器 (Mesh 或 Sprite)
            var allRenderers = Object.FindObjectsByType<Renderer>(FindObjectsSortMode.None);
            var processed = new HashSet<Renderer>();

            for (int i = 0; i < allRenderers.Length; i++)
            {
                var rendererA = allRenderers[i];
                if (processed.Contains(rendererA)) continue;
                if (rendererA == null) continue;

                var currentGroup = new DuplicateGroup();
                currentGroup.Original = rendererA.gameObject;
                currentGroup.WorldBounds = rendererA.bounds;

                // 2. 内层循环寻找匹配项
                for (int j = i + 1; j < allRenderers.Length; j++)
                {
                    var rendererB = allRenderers[j];
                    if (processed.Contains(rendererB)) continue;

                    // 快速排斥：距离检查
                    if (Vector3.SqrMagnitude(rendererA.transform.position - rendererB.transform.position) > positionTolerance * positionTolerance)
                        continue;

                    // 深度检查：资源是否一致
                    if (IsSameAsset(rendererA, rendererB))
                    {
                        currentGroup.Duplicates.Add(rendererB.gameObject);
                        processed.Add(rendererB); // 标记已处理
                    }
                }

                // 如果找到了副本，记录该组
                if (currentGroup.Duplicates.Count > 0)
                {
                    results.Add(currentGroup);
                    processed.Add(rendererA);
                }
            }

            return results;
        }

        private static bool IsSameAsset(Renderer r1, Renderer r2)
        {
            // Case 1: MeshRenderer
            if (r1 is MeshRenderer && r2 is MeshRenderer)
            {
                var f1 = r1.GetComponent<MeshFilter>();
                var f2 = r2.GetComponent<MeshFilter>();
                if (f1 && f2 && f1.sharedMesh == f2.sharedMesh) return true;
            }
            // Case 2: SpriteRenderer
            else if (r1 is SpriteRenderer s1 && r2 is SpriteRenderer s2)
            {
                if (s1.sprite == s2.sprite) return true;
            }
            // Case 3: SkinnedMeshRenderer (忽略骨骼动画状态，仅看Mesh)
            else if (r1 is SkinnedMeshRenderer sk1 && r2 is SkinnedMeshRenderer sk2)
            {
                if (sk1.sharedMesh == sk2.sharedMesh) return true;
            }

            return false;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/GroundAligner/AsakiGroundAlignerLogic.cs -->
<!-- GUID: 68143bae1c804c2e8c9c3a651cacf6d1 -->
<!-- Size: 4419 bytes -->
<!-- Modified: 2025-12-25 14:44:35 -->
```csharp
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.GroundAligner
{
    public static class AsakiGroundAlignerLogic
    {
        public enum AlignMode { Pivot, Bottom }
        public enum Dimension { Mode3D, Mode2D }

        public static void AlignSelected(Dimension dimension, LayerMask groundLayer, AlignMode alignMode, float offset, float maxDistance = 100f)
        {
            var selectedObjects = Selection.gameObjects;
            if (selectedObjects.Length == 0) return;

            // 开启撤销组
            Undo.IncrementCurrentGroup();
            Undo.SetCurrentGroupName("Asaki Ground Align");
            int undoGroup = Undo.GetCurrentGroup();

            int successCount = 0;

            foreach (var obj in selectedObjects)
            {
                if (obj == null) continue;

                bool hitSuccess = false;
                Vector3 hitPoint = Vector3.zero;

                // 1. 射线检测
                if (dimension == Dimension.Mode3D)
                {
                    // 稍微向上抬一点起点，防止从地面以下开始检测
                    Vector3 startPos = obj.transform.position + Vector3.up * 1.0f; 
                    if (Physics.Raycast(startPos, Vector3.down, out RaycastHit hit, maxDistance, groundLayer))
                    {
                        hitSuccess = true;
                        hitPoint = hit.point;
                    }
                }
                else // 2D Mode
                {
                    Vector2 startPos = obj.transform.position + Vector3.up * 1.0f;
                    RaycastHit2D hit = Physics2D.Raycast(startPos, Vector2.down, maxDistance, groundLayer);
                    if (hit.collider != null)
                    {
                        // 避免检测到自己 (如果自己也在 Ground 层)
                        if (hit.collider.gameObject != obj)
                        {
                            hitSuccess = true;
                            hitPoint = hit.point;
                        }
                    }
                }

                // 2. 执行对齐
                if (hitSuccess)
                {
                    Undo.RecordObject(obj.transform, "Align Move");

                    float finalY = hitPoint.y + offset;

                    // 如果是底部对齐，需要计算 Pivot 到 Bottom 的距离
                    if (alignMode == AlignMode.Bottom)
                    {
                        float distPivotToBottom = GetPivotToBottomDistance(obj, dimension);
                        finalY += distPivotToBottom;
                    }

                    Vector3 newPos = obj.transform.position;
                    newPos.y = finalY;
                    obj.transform.position = newPos;

                    successCount++;
                }
            }

            Undo.CollapseUndoOperations(undoGroup);
            Debug.Log($"<color=#4CAF50>[Asaki Aligner]</color> 已对齐 {successCount}/{selectedObjects.Length} 个对象。");
        }

        /// <summary>
        /// 计算 Pivot 到包围盒底部的距离（正值）
        /// </summary>
        private static float GetPivotToBottomDistance(GameObject obj, Dimension dim)
        {
            Bounds bounds = new Bounds(obj.transform.position, Vector3.zero);
            bool hasBounds = false;

            if (dim == Dimension.Mode3D)
            {
                var renderer = obj.GetComponentInChildren<Renderer>();
                var collider = obj.GetComponentInChildren<Collider>();
                if (renderer != null) { bounds = renderer.bounds; hasBounds = true; }
                else if (collider != null) { bounds = collider.bounds; hasBounds = true; }
            }
            else
            {
                var renderer = obj.GetComponentInChildren<SpriteRenderer>();
                var collider = obj.GetComponentInChildren<Collider2D>();
                if (renderer != null) { bounds = renderer.bounds; hasBounds = true; }
                else if (collider != null) { bounds = collider.bounds; hasBounds = true; }
            }

            if (!hasBounds) return 0f;

            // Pivot Y - Bounds Bottom Y
            return obj.transform.position.y - bounds.min.y;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/GroundAligner/AsakiGroundAlignerWindow.cs -->
<!-- GUID: 18ee94ccb1cc4e3399fa912306b6f2b8 -->
<!-- Size: 3690 bytes -->
<!-- Modified: 2025-12-25 14:44:49 -->
```csharp
using UnityEditor;
using UnityEngine;

namespace Asaki.Editor.Utilities.Tools.GroundAligner
{
    public class AsakiGroundAlignerWindow : EditorWindow
    {
        private AsakiGroundAlignerLogic.Dimension _dimension = AsakiGroundAlignerLogic.Dimension.Mode3D;
        private AsakiGroundAlignerLogic.AlignMode _alignMode = AsakiGroundAlignerLogic.AlignMode.Bottom; // 默认底部对齐更常用
        
        // 默认检测所有层，但排除 Trigger 等 (根据实际项目调整)
        private LayerMask _groundLayer = -1; 
        private float _offset = 0f;
        private float _maxDistance = 100f;

        // 用于辅助序列化绘制 LayerMask
        private SerializedObject _serializedObject;
        private SerializedProperty _layerMaskProp;

        // 必须定义为 public 字段才能被 SerializedObject 找到
        public LayerMask GroundLayers = -1; 

        [MenuItem("Asaki/Tools/Ground Aligner")]
        public static void Open()
        {
            var win = GetWindow<AsakiGroundAlignerWindow>("Ground Aligner");
            win.Show();
        }

        private void OnEnable()
        {
            // 初始化 SerializedObject 以便使用 Unity 原生的 LayerMask 绘制器
            _serializedObject = new SerializedObject(this);
            _layerMaskProp = _serializedObject.FindProperty("GroundLayers");
        }

        private void OnSelectionChange()
        {
            Repaint(); // 选中物体变化时重绘 UI
        }

        private void OnGUI()
        {
            DrawHeader();
            DrawSettings();
            DrawActions();
        }

        private void DrawHeader()
        {
            EditorGUILayout.LabelField("Asaki Ground Aligner", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("一键将物体垂直吸附到下方地面。\n支持 3D Mesh 和 2D Sprite。", MessageType.Info);
        }

        private void DrawSettings()
        {
            GUILayout.Label("Configuration", EditorStyles.boldLabel);
            
            using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
            {
                _dimension = (AsakiGroundAlignerLogic.Dimension)EditorGUILayout.EnumPopup("Dimension", _dimension);
                _alignMode = (AsakiGroundAlignerLogic.AlignMode)EditorGUILayout.EnumPopup("Align Anchor", _alignMode);

                // 绘制 LayerMask
                _serializedObject.Update();
                EditorGUILayout.PropertyField(_layerMaskProp, new GUIContent("Ground Layer"));
                _serializedObject.ApplyModifiedProperties();
                _groundLayer = GroundLayers; // 同步回字段

                _maxDistance = EditorGUILayout.FloatField("Max Ray Dist", _maxDistance);
                _offset = EditorGUILayout.FloatField("Height Offset", _offset);
            }
        }

        private void DrawActions()
        {
            EditorGUILayout.Space();
            GUILayout.Label($"Selected Objects: {Selection.gameObjects.Length}", EditorStyles.boldLabel);

            GUI.enabled = Selection.gameObjects.Length > 0;
            
            Color defaultColor = GUI.backgroundColor;
            GUI.backgroundColor = new Color(0.2f, 0.7f, 1f); // Asaki 风格蓝
            
            if (GUILayout.Button("Align To Ground", GUILayout.Height(40)))
            {
                AsakiGroundAlignerLogic.AlignSelected(_dimension, _groundLayer, _alignMode, _offset, _maxDistance);
            }
            
            GUI.backgroundColor = defaultColor;
            GUI.enabled = true;
        }
    }
}```

<!-- File: Asaki/Editor/Utilities/Tools/MissingFinder/AsakiMissingFinderWindow.cs -->
<!-- GUID: 7b1ca82b79ba4fab96e76f7088f53399 -->
<!-- Size: 9177 bytes -->
<!-- Modified: 2025-12-25 16:43:54 -->
```csharp
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Asaki.Editor.Utilities.Tools.MissingFinder
{
    public class AsakiMissingFinderWindow : EditorWindow
    {
        // === 数据结构 ===
        private class MissingEntry
        {
            public Object ContextObject;    // 出问题的对象 (GameObject 或 SO)
            public Component Component;     // 出问题的组件 (如果是场景物体)
            public string PropertyPath;     // 属性路径 (如 "m_MyData.Array.data[0]")
            public string ErrorType;        // "Missing Script" 或 "Missing Reference"
        }

        private List<MissingEntry> _entries = new List<MissingEntry>();
        private Vector2 _scrollPos;
        [SerializeField]
        private bool _includeProject; // 是否扫描 Project (耗时操作)

        [MenuItem("Asaki/Tools/Missing References Finder")]
        public static void ShowWindow()
        {
            var wnd = GetWindow<AsakiMissingFinderWindow>("Missing Finder");
            wnd.minSize = new Vector2(600, 400);
            wnd.Show();
        }

        private void OnGUI()
        {
            DrawHeader();
            DrawToolbar();
            DrawList();
        }

        private void DrawHeader()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            GUILayout.Label("Asaki Missing Asset Scanner", EditorStyles.boldLabel);
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.HelpBox(
                "检测两种错误：\n" +
                "1. Missing Script: GameObject 上挂载的脚本文件被删除。\n" +
                "2. Missing Reference: 属性引用的资源被删除 (显示为 Type Mismatch 或 Missing)。", 
                MessageType.Info);
        }

        private void DrawToolbar()
        {
            EditorGUILayout.Space();
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("Scan Current Scene", GUILayout.Height(30)))
            {
                ScanScene();
            }

            if (GUILayout.Button("Scan Entire Project (Prefabs & SOs)", GUILayout.Height(30)))
            {
                ScanProject();
            }

            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space();
            GUILayout.Label($"Found Issues: {_entries.Count}", EditorStyles.boldLabel);
        }

        private void DrawList()
        {
            if (_entries.Count == 0) return;

            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            
            for (int i = 0; i < _entries.Count; i++)
            {
                var entry = _entries[i];
                DrawEntry(entry, i);
            }

            EditorGUILayout.EndScrollView();
        }

        private void DrawEntry(MissingEntry entry, int index)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.BeginHorizontal();
            
            // 1. 图标状态
            GUI.color = Color.red;
            GUILayout.Label(EditorGUIUtility.IconContent("console.erroricon"), GUILayout.Width(20), GUILayout.Height(20));
            GUI.color = Color.white;

            // 2. 对象引用 (点击可 Ping)
            EditorGUILayout.ObjectField(entry.ContextObject, typeof(Object), true, GUILayout.Width(200));

            // 3. 错误详情
            EditorGUILayout.BeginVertical();
            GUILayout.Label(entry.ErrorType, EditorStyles.boldLabel);
            
            if (entry.Component != null)
            {
                GUILayout.Label($"Component: {entry.Component.GetType().Name}", EditorStyles.miniLabel);
            }
            if (!string.IsNullOrEmpty(entry.PropertyPath))
            {
                GUI.color = new Color(1f, 0.6f, 0.6f);
                GUILayout.Label($"Property: {entry.PropertyPath}", EditorStyles.miniLabel);
                GUI.color = Color.white;
            }
            EditorGUILayout.EndVertical();

            // 4. 选择按钮
            if (GUILayout.Button("Select", GUILayout.Width(60), GUILayout.Height(30)))
            {
                Selection.activeObject = entry.ContextObject;
                EditorGUIUtility.PingObject(entry.ContextObject);
            }

            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
        }

        // =========================================================
        // 核心扫描逻辑
        // =========================================================

        private void ScanScene()
        {
            _entries.Clear();
            var rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();

            EditorUtility.DisplayProgressBar("Scanning Scene", "Iterating GameObjects...", 0f);
            
            try
            {
                foreach (var root in rootObjects)
                {
                    // 递归获取所有子物体
                    var allTransforms = root.GetComponentsInChildren<Transform>(true);
                    foreach (var t in allTransforms)
                    {
                        CheckGameObject(t.gameObject);
                    }
                }
            }
            finally
            {
                EditorUtility.ClearProgressBar();
            }
        }

        private void ScanProject()
        {
            _entries.Clear();
            string[] guids = AssetDatabase.FindAssets("t:Prefab t:ScriptableObject");
            
            int count = 0;
            try
            {
                foreach (var guid in guids)
                {
                    string path = AssetDatabase.GUIDToAssetPath(guid);
                    count++;
                    EditorUtility.DisplayProgressBar("Scanning Project", path, (float)count / guids.Length);

                    var obj = AssetDatabase.LoadAssetAtPath<Object>(path);
                    
                    if (obj is GameObject go)
                    {
                        // 这是一个 Prefab，需要检查它的所有组件
                        CheckGameObject(go);
                    }
                    else if (obj is ScriptableObject so)
                    {
                        // 这是一个 SO，检查它的序列化属性
                        CheckSerializedObject(obj, new SerializedObject(so), null);
                    }
                }
            }
            finally
            {
                EditorUtility.ClearProgressBar();
            }
        }

        private void CheckGameObject(GameObject go)
        {
            // 1. 检查 Missing Script (脚本文件丢失)
            int missingCount = GameObjectUtility.GetMonoBehavioursWithMissingScriptCount(go);
            if (missingCount > 0)
            {
                _entries.Add(new MissingEntry
                {
                    ContextObject = go,
                    ErrorType = $"Missing Script ({missingCount})",
                    PropertyPath = "Check Inspector (Yellow Warning)"
                });
            }

            // 2. 检查组件内的 Missing Reference
            var components = go.GetComponents<Component>();
            foreach (var comp in components)
            {
                if (comp == null) continue; // 已经被上面的 GetMonoBehavioursWithMissingScriptCount 捕获了
                
                // 跳过 Transform，通常没问题且浪费性能
                if (comp is Transform) continue;

                SerializedObject so = new SerializedObject(comp);
                CheckSerializedObject(go, so, comp);
            }
        }

        private void CheckSerializedObject(Object context, SerializedObject so, Component comp)
        {
            SerializedProperty sp = so.GetIterator();
            
            // NextVisible(true) 会进入子属性，遍历整个树
            while (sp.NextVisible(true))
            {
                if (sp.propertyType == SerializedPropertyType.ObjectReference)
                {
                    // === 核心黑科技判定 ===
                    // objectReferenceValue 为 null，但 InstanceID 不为 0
                    // 这意味着 Unity 知道这里“应该”有个东西，但找不到它了 (GUID 断裂)
                    if (sp.objectReferenceValue == null && sp.objectReferenceInstanceIDValue != 0)
                    {
                        _entries.Add(new MissingEntry
                        {
                            ContextObject = context,
                            Component = comp,
                            ErrorType = "Missing Reference",
                            PropertyPath = sp.propertyPath
                        });
                    }
                }
            }
        }
    }
}```

<!-- File: Asaki/Generated/AudioID.cs -->
<!-- GUID: 50ef4a0791b42f54ab5fcbc0c53c22a7 -->
<!-- Size: 589 bytes -->
<!-- Modified: 2025-12-22 16:31:58 -->
```csharp
// <auto-generated/>
// This file is generated by AsakiAudioGenerator.

using Asaki.Core;
using Asaki.Core.Audio;
using System.Threading;

namespace Asaki.Generated
{
    public enum AudioID
    {
        None = 0,
        Sihan,三Z_STUDIO,HOYO_MiX___DAMIDAMI = -1281957189,
    }

    public static class AudioExtensions
    {
        public static AsakiAudioHandle Play(this IAsakiAudioService service, AudioID id, AsakiAudioParams p = default, CancellationToken token = default)
        {
            return service.Play((int)id, p, token);
        }
    }
}
```

<!-- File: Asaki/Generated/UIID.cs -->
<!-- GUID: f908bd688df4dae4fa32252acd0af969 -->
<!-- Size: 309 bytes -->
<!-- Modified: 2025-12-15 18:06:20 -->
```csharp
// <auto-generated/>
// This file is generated by AsakiUIGeneratorWindow.

namespace Asaki.Generated
{
    public enum UIID
    {
        None = 0,
        NormalWindow = 1407592661,
        PopupWindow = -165354889,
        SystemWindow = 1250840597,
        WorldWindow = 25972143,
    }
}
```

<!-- File: Asaki/Unity/Bootstrapper/AsakiBootstrapper.cs -->
<!-- GUID: e4e79f2b1d674d4fb2a97e005abbcf32 -->
<!-- Size: 2791 bytes -->
<!-- Modified: 2025-12-23 20:21:48 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Simulation;
using Asaki.Unity.Bridge;
using Asaki.Unity.Configuration;
using System;
using System.Collections.Generic;
using UnityEngine;
using AsakiBroker = Asaki.Core.Broker.AsakiBroker;

namespace Asaki.Unity.Bootstrapper
{
    public struct FrameworkReadyEvent : IAsakiEvent { }

    [DefaultExecutionOrder(-9999)]
    public class AsakiBootstrapper : MonoBehaviour
    {
        [Header("Configuration")]
        [SerializeField] private AsakiConfig _config;
        
        [Header("Module Discovery")]
        [Tooltip("指定要扫描模块的程序集名称，为空则扫描所有")]
        [SerializeField] private List<string> _scanAssemblies = new List<string> 
        { 
            "Asaki.Unity", 
            "Game.Logic",
            "Game.View"
        };

        private static AsakiBootstrapper _instance;

        private void Awake()
        {
            if (_instance != null) { Destroy(gameObject); return; }
            _instance = this;
            DontDestroyOnLoad(gameObject);

            Debug.Log("== Asaki Framework Booting (DAG System) ==");

            AsakiContext.ClearAll();
            Application.targetFrameRate = _config ? _config.TickRate : 60;

            // 1. 注册全局配置 (第0号服务)
            if (_config != null) AsakiContext.Register(_config);
            else Debug.LogError("[Asaki] Configuration is null!");

            // 2. 初始化核心驱动 (Simulation & Driver)
            SetupCoreDriver();
        }

        private async void Start()
        {
            try
            {
                var discovery = new AsakiStaticModuleDiscovery();
                
                await AsakiModuleLoader.Startup(discovery);

                Debug.Log("[Asaki] Freezing Context...");
                AsakiContext.Freeze();

                AsakiBroker.Publish(new FrameworkReadyEvent());
            }
            catch (Exception ex)
            {
                Debug.LogError($"[Asaki] Boot Failed: {ex}");
            }
        }

        private void SetupCoreDriver()
        {
            var simManager = new AsakiSimulationManager();
            AsakiContext.Register(simManager);

            var driverGo = new GameObject("[Asaki.Driver]");
            DontDestroyOnLoad(driverGo);
            var driver = driverGo.AddComponent<AsakiMonoDriver>();
            driver.Initialize(simManager);
        }

        private void OnDestroy()
        {
            if (_instance == this)
            {
                AsakiContext.ClearAll(); // 会触发所有 Module 的 OnDispose
                _instance = null;
            }
        }
    }
}```

<!-- File: Asaki/Unity/Bootstrapper/AsakiModuleLoader.cs -->
<!-- GUID: 428072e8feae40498ca9881c18b14e91 -->
<!-- Size: 5583 bytes -->
<!-- Modified: 2025-12-22 16:42:55 -->
```csharp
using Asaki.Core;
using Asaki.Core.Context;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Bootstrapper
{
    public static class AsakiModuleLoader
    {
        /// <summary>
        /// 启动整个模块系统
        /// </summary>
        public static async Task Startup(IAsakiModuleDiscovery discovery)
        {
            // 1. 发现
            var allModuleTypes = discovery.GetModuleTypes().ToList();
            Debug.Log($"[Asaki] Discovered {allModuleTypes.Count} modules.");

            // 2. 排序 (DAG)
            var sortedTypes = TopologicalSort(allModuleTypes);

            // 3. 实例化与注册 (Phase 1: Sync Init)
            var activeModules = new List<IAsakiModule>();
            
            Debug.Log("== [Asaki] Phase 1: Registration & Sync Init ==");
            foreach (var type in sortedTypes)
            {
                // 强制无参构造
                if (Activator.CreateInstance(type) is not IAsakiModule module)
                    continue;

                // [关键设计] 托管注册：将具体类型注册进容器
                // 这样下游模块可以通过 AsakiContext.Get<ResKitModule>() 获取它
                AsakiContext.Register(type, module);
                
                // 执行同步初始化 (获取配置，注册子服务)
                module.OnInit();
                
                activeModules.Add(module);
                Debug.Log($" -> [OK] {type.Name}");
            }

            // 4. 异步初始化 (Phase 2: Async Init)
            Debug.Log("== [Asaki] Phase 2: Async Initialization ==");
            foreach (var module in activeModules)
            {
                await module.OnInitAsync();
            }
            
            Debug.Log("== [Asaki] Framework Ready ==");
        }

        /// <summary>
        /// 拓扑排序算法 (解决依赖顺序)
        /// </summary>
        private static List<Type> TopologicalSort(List<Type> nodes)
        {
            // 映射: 类型 -> (优先级, 依赖列表)
            var moduleInfo = new Dictionary<Type, (int Priority, Type[] Deps)>();
            
            // 构建查找表
            foreach (var node in nodes)
            {
                var attr = node.GetCustomAttribute<AsakiModuleAttribute>();
                moduleInfo[node] = (attr.Priority, attr.Dependencies);
            }

            // 构建图
            var edges = new Dictionary<Type, List<Type>>(); // Key依赖于Value -> 错误，应该是 Value 依赖 Key (Edge: Dependency -> Dependent)
            // 修正图方向：如果我们希望 A 在 B 之前初始化 (B 依赖 A)，则边应该是 A -> B。
            // 这样排序输出才是 A, B。
            
            var inDegree = new Dictionary<Type, int>();
            foreach (var node in nodes) inDegree[node] = 0;

            foreach (var dependent in nodes)
            {
                var dependencies = moduleInfo[dependent].Deps;
                foreach (var dependency in dependencies)
                {
                    // 确保依赖项在扫描列表中存在
                    if (!moduleInfo.ContainsKey(dependency))
                    {
                        throw new Exception($"[Asaki] Module '{dependent.Name}' depends on '{dependency.Name}', but it was not found in discovery.");
                    }

                    if (!edges.ContainsKey(dependency))
                        edges[dependency] = new List<Type>();

                    edges[dependency].Add(dependent); // 边：依赖项 -> 依赖者
                    inDegree[dependent]++;
                }
            }

            // 准备队列 (所有入度为0的节点，即没有任何依赖的模块)
            // 优先处理 Priority 值小的 (Sort by Priority first)
            var queue = new Queue<Type>(
                nodes.Where(n => inDegree[n] == 0)
                     .OrderBy(n => moduleInfo[n].Priority)
            );

            var result = new List<Type>();

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();
                result.Add(current);

                if (edges.TryGetValue(current, out var neighbors))
                {
                    // 那些依赖 current 的模块
                    // 这里的 neighbors 需要按优先级排序吗？
                    // 为了简单起见，这里不进行二次排序，但实际入队时如果能保持优先级更好。
                    // 优化：在此处对 neighbors 排序再处理能保证同一层级的优先级
                    
                    var sortedNeighbors = neighbors.OrderBy(n => moduleInfo[n].Priority);

                    foreach (var neighbor in sortedNeighbors)
                    {
                        inDegree[neighbor]--;
                        if (inDegree[neighbor] == 0)
                        {
                            queue.Enqueue(neighbor);
                        }
                    }
                }
            }

            if (result.Count != nodes.Count)
            {
                // 找到循环链以便调试
                throw new Exception("[Asaki] Circular dependency detected! Initialization aborted.");
            }

            return result;
        }
    }
}```

<!-- File: Asaki/Unity/Bootstrapper/AsakiStaticModuleDiscovery.cs -->
<!-- GUID: e3b7d7545b954c15920f93d092c7b1c3 -->
<!-- Size: 1140 bytes -->
<!-- Modified: 2025-12-23 20:21:27 -->
```csharp
using Asaki.Core.Context;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Unity.Bootstrapper
{
	/// <summary>
	/// [Asaki V5 Native] 静态模块发现服务
	/// <para>配合 Roslyn 生成器使用，实现"零反射"的模块注册。</para>
	/// <para>生成器会为每个模块生成注册代码，在游戏启动前自动调用 Register。</para>
	/// </summary>
	public class AsakiStaticModuleDiscovery : IAsakiModuleDiscovery
	{
		// 静态缓存，所有生成的代码都会往这里塞数据
		private static readonly HashSet<Type> _registry = new HashSet<Type>();

		/// <summary>
		/// 供 Roslyn 生成的代码调用
		/// </summary>
		public static void Register(Type moduleType)
		{
			if (moduleType != null && !_registry.Contains(moduleType))
			{
				_registry.Add(moduleType);
			}
		}

		public IEnumerable<Type> GetModuleTypes()
		{
			// 直接返回缓存，0 消耗
			return _registry;
		}

		/// <summary>
		/// 仅用于调试，清理静态状态
		/// </summary>
		public static void Reset()
		{
			_registry.Clear();
		}
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiAudioModule.cs -->
<!-- GUID: c9e17578c88b4c5b8bc1296a055b4114 -->
<!-- Size: 1209 bytes -->
<!-- Modified: 2025-12-23 19:31:04 -->
```csharp
using Asaki.Core;
using Asaki.Core.Audio;
using Asaki.Core.Context;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Unity.Configuration;
using Asaki.Unity.Services.Audio;
using System.Threading.Tasks;

namespace Asaki.Unity.Bootstrapper.Modules
{
	// 优先级 400，通常依赖 Resources 加载音频
	[AsakiModule(priority: 400,
		typeof(AsakiResKitModule),
		typeof(AsakiPoolModule),
		typeof(AsakiEventBusModule))]
	public class AsakiAudioModule : IAsakiModule
	{
		private IAsakiAudioService _audioService;

		public void OnInit()
		{
			var config = AsakiContext.Get<AsakiConfig>();
			var res = AsakiContext.Get<IAsakiResService>();
			var pool = AsakiContext.Get<IAsakiPoolService>();
			if (!config || !config.AsakiAudioConfig) return;

			_audioService = new AsakiAudioService(
				res,
				pool,
				config.AsakiAudioConfig,
				config.SoundAgentPrefabAssetKey,
				config.InitialAudioPoolSize
			);

			_audioService.OnInit();

			AsakiContext.Register(_audioService);
		}

		public async Task OnInitAsync()
		{
			await _audioService.OnInitAsync();
		}

		public void OnDispose()
		{
			_audioService.OnDispose();
		}
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiConfigModule.cs -->
<!-- GUID: 384b961c7c2d4fdd8a833ec72916faf6 -->
<!-- Size: 784 bytes -->
<!-- Modified: 2025-12-23 19:49:46 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Configuration;
using Asaki.Core.Context;
using Asaki.Unity.Services.Configuration;
using System.Threading.Tasks;

namespace Asaki.Unity.Bootstrapper.Modules
{
	[AsakiModule(priority: 150, typeof(AsakiEventBusModule))]
	public class AsakiConfigModule : IAsakiModule
	{
		private IAsakiConfigService _configService;
		public void OnInit()
		{
			var eventService = AsakiContext.Get<IAsakiEventService>();
			_configService = new AsakiConfigService(eventService);
			AsakiContext.Register(_configService);
			_configService.OnInit();
		}
		public async Task OnInitAsync()
		{
			await _configService.OnInitAsync();
		}
		public void OnDispose()
		{
			_configService.OnDispose();
		}
	}

	
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiEventBusModule.cs -->
<!-- GUID: 3a2e72add33345a384d33f4d2c9dc1b6 -->
<!-- Size: 1695 bytes -->
<!-- Modified: 2025-12-23 19:32:26 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Context;
using System.Threading.Tasks;
using UnityEngine; //用于打Log

namespace Asaki.Unity.Bootstrapper.Modules
{
	// 确保优先级较高，尽早接管总线
	[AsakiModule(75)]
	public class AsakiEventBusModule : IAsakiModule
	{
		private IAsakiEventService _eventService; // 改为接口引用更通用

		public void OnInit()
		{
			// 1. 检查是否已经被 Lazy Init 抢先注册了
			if (AsakiContext.TryGet<IAsakiEventService>(out var existingBus))
			{
				// [收编逻辑]
				// 既然已经有了，模块就直接持有它，将其纳入模块化管理版图
				_eventService = existingBus;
				Debug.Log("[AsakiEventBusModule] Detected existing EventBus (Lazy Init). Adopting it.");
			}
			else
			{
				// 2. [正规军逻辑]
				// 还没有总线，由模块负责创建并注册
				var newBus = new AsakiEventService();
				AsakiContext.Register<IAsakiEventService>(newBus);
				_eventService = newBus;
			}
		}

		public Task OnInitAsync()
		{
			return Task.CompletedTask;
		}

		public void OnDispose()
		{
			// 在 ClearAll 时：
			// 1. AsakiContext 会遍历所有 Service 调用 IDisposable.Dispose()
			// 2. AsakiContext 会调用 Module.OnDispose()
            
			// 为了防止双重释放 (Double Dispose)，虽然 AsakiEventService 的 Dispose 是安全的，
			// 但最好在这里不再手动调用，或者确保 Dispose 是幂等的。
			// 由于 _eventService 已经注册在 Context 里，Context.ClearAll 会负责 Dispose 它。
			// 这里我们置空引用即可。
            
			_eventService = null;
		}
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiPoolModule.cs -->
<!-- GUID: 4b1851b1aa024185b3888dfd659187a4 -->
<!-- Size: 1233 bytes -->
<!-- Modified: 2025-12-23 19:40:56 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Coroutines;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Unity.Services.Resources;
using System.Threading.Tasks;
using UnityEngine;

// 引用 Pooling 的命名空间

namespace Asaki.Unity.Bootstrapper.Modules
{
	// 优先级 150：必须在 Coroutines(100) 之后，但在 Resources(200) 之前
	// 因为 Resources 加载资源时可能需要从池中生成对象
	[AsakiModule(150,
		typeof(AsakiRoutineModule),
		typeof(AsakiResKitModule),
		typeof(AsakiEventBusModule))]
	public class AsakiPoolModule : IAsakiModule
	{
		private IAsakiPoolService _poolService;
		public void OnInit()
		{
			// 1. 获取依赖
			var routine = AsakiContext.Get<IAsakiRoutineService>();
			var res = AsakiContext.Get<IAsakiResService>();
			var eventService = AsakiContext.Get<IAsakiEventService>();
			_poolService = new AsakiPoolService(routine, res, eventService);

			AsakiContext.Register(_poolService);

			Debug.Log("[Asaki] Pooling Service initialized (Async-Native Mode).");
		}

		public Task OnInitAsync()
		{
			return Task.CompletedTask;
		}

		public void OnDispose() { }
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiResKitModule.cs -->
<!-- GUID: 999a04de6f104ef19a8006aeb1df9c58 -->
<!-- Size: 1265 bytes -->
<!-- Modified: 2025-12-23 19:49:20 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Coroutines;
using Asaki.Core.Resources;
using Asaki.Unity.Configuration;
using Asaki.Unity.Services.Resources;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Bootstrapper.Modules
{
	// 优先级 200，且显式依赖 RoutineModule
	[AsakiModule(125, 
		typeof(AsakiRoutineModule),
		typeof(AsakiEventBusModule))]
	public class AsakiResKitModule : IAsakiModule
	{
		private IAsakiResService _resService;

		public void OnInit()
		{
			var config = AsakiContext.Get<AsakiConfig>();
			var routine = AsakiContext.Get<IAsakiRoutineService>();
			var eventService = AsakiContext.Get<IAsakiEventService>();
			// 2. 创建工厂
			var mode = config ? config.AsakiResKitMode : AsakiResKitMode.Resources;
			_resService = AsakiResKitFactory.Create(mode, routine, eventService);
			// 3. 注册服务
			AsakiContext.Register(_resService);

			Debug.Log($"[Asaki] Resources initialized in {mode} mode.");
		}

		public async Task OnInitAsync()
		{
			// 4. 执行异步初始化 (加载 Manifest 等)
			if (_resService != null)
			{
				await _resService.OnInitAsync();
			}
		}

		public void OnDispose() { }
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiRoutineModule.cs -->
<!-- GUID: 026e3f271a424128868ab01aad8e6d66 -->
<!-- Size: 739 bytes -->
<!-- Modified: 2025-12-22 16:46:15 -->
```csharp
using Asaki.Core;
using Asaki.Core.Context;
using Asaki.Core.Coroutines;
using System.Threading.Tasks;

namespace Asaki.Unity.Bootstrapper.Modules
{
	[AsakiModule(100)]
	public class AsakiRoutineModule : IAsakiModule
	{
		private Services.Coroutines.AsakiRoutineProvider _provider;
		public void OnInit()
		{
			// 1. 创建具体服务实现
			_provider = new Services.Coroutines.AsakiRoutineProvider();

			// 2. 注册服务接口 (供其他模块通过 Get<IAsakiRoutineService> 获取)
			AsakiContext.Register<IAsakiRoutineService>(_provider);
		}
		public Task OnInitAsync()
		{
			// Coroutines 服务本身无需异步初始化
			return Task.CompletedTask;
		}

		public void OnDispose() { }
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiSaveModule.cs -->
<!-- GUID: f65b8e7032574a968af4d5976408d355 -->
<!-- Size: 813 bytes -->
<!-- Modified: 2025-12-23 19:40:56 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Serialization;
using Asaki.Unity.Services.Serialization;
using System.Threading.Tasks;

namespace Asaki.Unity.Bootstrapper.Modules
{
	[AsakiModule(priority: 175,
		typeof(AsakiEventBusModule))]
	public class AsakiSaveModule : IAsakiModule
	{
		private AsakiSaveService _asakiSaveService;
		public void OnInit()
		{
			var eventService = AsakiContext.Get<IAsakiEventService>();
			_asakiSaveService = new AsakiSaveService(eventService);
			_asakiSaveService.OnInit();
			AsakiContext.Register<IAsakiSaveService>(_asakiSaveService);
		}
		public async Task  OnInitAsync()
		{
			await _asakiSaveService.OnInitAsync();
		}
		public void OnDispose()
		{
			_asakiSaveService.OnDispose();
		}
	}
}
```

<!-- File: Asaki/Unity/Bootstrapper/Modules/AsakiUIModule.cs -->
<!-- GUID: b10a818f3fd948b6bcdfe6e81194bdc6 -->
<!-- Size: 1415 bytes -->
<!-- Modified: 2025-12-23 19:40:44 -->
```csharp
using Asaki.Core;
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Core.UI;
using Asaki.Unity.Configuration;
using Asaki.Unity.Services.UI;
using System.Threading.Tasks;

namespace Asaki.Unity.Bootstrapper.Modules
{
	// 优先级 300，依赖 Resources 加载预制体
	[AsakiModule(225, 
		typeof(AsakiResKitModule),
		typeof(AsakiPoolModule),
		typeof(AsakiEventBusModule))]
	public class AsakiUIModule : IAsakiModule
	{
		private AsakiUIManager _uiManager;

		public void OnInit()
		{
			var config = AsakiContext.Get<AsakiConfig>();
			var eventService = AsakiContext.Get<IAsakiEventService>();
			var resService = AsakiContext.Get<IAsakiResService>();
			var poolService = AsakiContext.Get<IAsakiPoolService>();
			// 如果没配置 UI，直接跳过
			if (!config || !config.UIConfig) return;

			_uiManager = new AsakiUIManager(
				config.UIConfig,
				config.ReferenceResolution,
				config.MatchWidthOrHeight,
				eventService,
				resService,
				poolService
			);

			// 内部 OnInit 会调用 Resources 接口，此时 Resources 已注册
			_uiManager.OnInit();

			AsakiContext.Register<IAsakiUIService>(_uiManager);
		}

		public async Task OnInitAsync()
		{
			if (_uiManager != null)
			{
				await _uiManager.OnInitAsync();
			}
		}

		public void OnDispose() { }
	}
}
```

<!-- File: Asaki/Unity/Bridge/AsakiLifecycleTracker.cs -->
<!-- GUID: c9cc767f7b2345d994343972eb3e8bdf -->
<!-- Size: 1070 bytes -->
<!-- Modified: 2025-12-22 16:43:48 -->
```csharp
#if !UNITY_2022_2_OR_NEWER
using System.Threading;
using UnityEngine;

namespace Asaki.Unity.Bridge
{
    /// <summary>
    /// [内部组件] 用于在 Unity 2021 及更早版本中模拟 destroyCancellationToken。
    /// <para>开发者不应手动添加此组件，它由 AsakiFlow 自动管理。</para>
    /// </summary>
    [DisallowMultipleComponent]
    public class AsakiLifecycleTracker : MonoBehaviour
    {
        private CancellationTokenSource _cts;
        private bool _isDisposed;

        public CancellationToken Token
        {
            get
            {
                if (_isDisposed) return CancellationToken.None;
                if (_cts == null) _cts = new CancellationTokenSource();
                return _cts.Token;
            }
        }

        private void OnDestroy()
        {
            if (_cts != null)
            {
                _cts.Cancel();
                _cts.Dispose();
                _cts = null;
            }
            _isDisposed = true;
        }
    }
}
#endif
```

<!-- File: Asaki/Unity/Bridge/AsakiMonoDriver.cs -->
<!-- GUID: b4c68e2b3e154a48ac9b55802a11e0be -->
<!-- Size: 694 bytes -->
<!-- Modified: 2025-12-22 16:43:25 -->
```csharp
using Asaki.Core.Simulation;
using UnityEngine;

namespace Asaki.Unity.Bridge
{
	public class AsakiMonoDriver : MonoBehaviour
	{
		private AsakiSimulationManager _simManager;

		public void Initialize(AsakiSimulationManager simManager)
		{
			_simManager = simManager;
		}

		private void Update()
		{
			if (_simManager == null) return;
            
			// [关键] 在这里获取 Unity 的时间，传给 Core
			// 这是整个框架唯一允许读取 Time.deltaTime 的地方
			_simManager.Tick(Time.deltaTime);
		}

		private void FixedUpdate()
		{
			if (_simManager == null) return;
            
			_simManager.FixedTick(Time.fixedDeltaTime);
		}
	}
}
```

<!-- File: Asaki/Unity/Configuration/AsakiAudioConfig.cs -->
<!-- GUID: 34fe6320e7994ca597c7bc71b0d191e8 -->
<!-- Size: 2484 bytes -->
<!-- Modified: 2025-12-25 15:11:05 -->
```csharp
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Unity.Configuration
{
    public enum AsakiAudioGroup
    {
        SFX = 0,    // 普通音效
        BGM = 1,    // 背景音乐
        UI = 2,     // UI 交互音
        Voice = 3   // 语音
    }

    [Serializable]
    public class AudioItem
    {
        public string Key;          // 代码引用的 Enum Key (如 "Player_Jump")
        public int ID;              // Hash ID
        
        [Tooltip("编辑器引用，用于预览和生成路径")]
        public AudioClip Clip;      
        
        [Tooltip("运行时加载路径 (自动生成)")]
        public string AssetPath;    
        
        [Range(0f, 1f)]
        public float Volume = 1f;   // 基础音量
        
        [Range(0.1f, 3f)]
        public float Pitch = 1f;    // 基础音高
        
        public bool Loop = false;   // 默认是否循环
        
        public AsakiAudioGroup Group = AsakiAudioGroup.SFX; // 分组

        [Tooltip("是否启用随机音高扰动 (丰富听感)")]
        public bool RandomPitch = false;

        // 编辑器折叠状态
        #if UNITY_EDITOR
        public bool _editorExpanded = false; 
        #endif
    }

    [CreateAssetMenu(fileName = "AsakiAudioConfig", menuName = "Asaki/Configuration/Audio Configuration")]
    public class AsakiAudioConfig : ScriptableObject
    {
        // 新的核心数据列表
        public List<AudioItem> Items = new List<AudioItem>();

        // 运行时查找缓存
        private Dictionary<int, AudioItem> _lookup;

        public void InitializeLookup()
        {
            if (_lookup != null) return;
            _lookup = new Dictionary<int, AudioItem>(Items.Count);
            foreach (var item in Items)
            {
                if (!_lookup.ContainsKey(item.ID))
                {
                    _lookup.Add(item.ID, item);
                }
            }
        }

        public bool TryGet(int id, out AudioItem item)
        {
            if (_lookup == null) InitializeLookup();
            return _lookup.TryGetValue(id, out item);
        }
        
        // 兼容旧接口，防止报错 (虽然逻辑变了，但先保留方法签名)
        public string GetPath(int id)
        {
            if (TryGet(id, out var item)) return item.AssetPath;
            return null;
        }
    }
}```

<!-- File: Asaki/Unity/Configuration/AsakiConfig.cs -->
<!-- GUID: 825e7577a77b4021b00a1bbbb0debaad -->
<!-- Size: 2375 bytes -->
<!-- Modified: 2025-12-23 18:37:13 -->
```csharp
using Asaki.Core.Context;
using Asaki.Unity.Services.Resources;
using UnityEngine;
// [新增] 引用 UI 命名空间

namespace Asaki.Unity.Configuration
{
    [CreateAssetMenu(fileName = "AsakiConfig", menuName = "Asaki/AsakiConfig")]
    public class AsakiConfig : ScriptableObject, IAsakiService
    {
        [Header("Simulation Settings")]
        [Tooltip("逻辑帧率 (次/秒)。工厂游戏建议 60，RTS 建议 30-60")]
        [Range(30, 120)]
        [SerializeField] private int tickRate = 60;
        public int TickRate => tickRate;

        [Header("Performance")]
        [Tooltip("启动时预分配的对象池大小")]
        [SerializeField] private int defaultPoolSize = 128;
        public int DefaultPoolSize => defaultPoolSize;

        [Header("Resources Strategies")]
        [SerializeField] private AsakiResKitMode asakiResKitMode = AsakiResKitMode.Resources;
        public AsakiResKitMode AsakiResKitMode => asakiResKitMode;

        [Header("Audio")]
        [SerializeField] private AsakiAudioConfig asakiAudioConfig;
        [SerializeField] private string _soundAgentPrefabAssetKey;
        [SerializeField] private int _initialAudioPoolSize = 16;
        public AsakiAudioConfig AsakiAudioConfig => asakiAudioConfig;
        public string SoundAgentPrefabAssetKey => _soundAgentPrefabAssetKey;
        public int InitialAudioPoolSize => _initialAudioPoolSize;

        // [新增] UI 配置区域 ============================================
        [Header("UI")]
        [Tooltip("UI 窗口配置表 (UIID 映射)")]
        [SerializeField] private AsakiUIConfig _uiConfig;
        [Tooltip("设计分辨率")]
        [SerializeField] private Vector2 _referenceResolution = new Vector2(1920, 1080);
        [Tooltip("屏幕适配模式 (0=Width, 1=Height, 0.5=Balanced)")]
        [Range(0f, 1f)]
        [SerializeField] private float _matchWidthOrHeight = 0.5f;

        public AsakiUIConfig UIConfig => _uiConfig;
        public Vector2 ReferenceResolution => _referenceResolution;
        public float MatchWidthOrHeight => _matchWidthOrHeight;
        // =============================================================
        
        [Header("Debug")]
        [SerializeField] private bool showDebugLogs = true;
        public bool ShowDebugLogs => showDebugLogs;
    }
}```

<!-- File: Asaki/Unity/Configuration/AsakiUIConfig.cs -->
<!-- GUID: 42f7d1303c804165919138aa7f552dba -->
<!-- Size: 932 bytes -->
<!-- Modified: 2025-12-22 16:43:08 -->
```csharp
using Asaki.Core.UI;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Unity.Configuration
{
	[Serializable]
	public struct UIInfo
	{
		public string Name;
		public int ID;
		public AsakiUILayer Layer;
		public string AssetPath;
		public bool UsePool;
	}

	[CreateAssetMenu(fileName = "AsakiUIConfig", menuName = "Asaki/Configuration/UI Configuration")]
	public class AsakiUIConfig : ScriptableObject
	{
		public List<UIInfo> UIList = new List<UIInfo>();
		private Dictionary<int, UIInfo> _lookup;

		public void InitializeLookup()
		{
			if (_lookup != null) return;
			_lookup = new Dictionary<int, UIInfo>(UIList.Count);
			foreach (var item in UIList)
			{
				_lookup.TryAdd(item.ID, item);
			}
		}

		public bool TryGet(int id, out UIInfo info)
		{
			if (_lookup == null) InitializeLookup();
			return _lookup!.TryGetValue(id, out info);
		}
	}
}
```

<!-- File: Asaki/Unity/Configuration/AsakiUITemplateConfig.cs -->
<!-- GUID: 836f176eeada4c64b783075c32794300 -->
<!-- Size: 722 bytes -->
<!-- Modified: 2025-12-22 16:38:30 -->
```csharp
using Asaki.Core;
using Asaki.Core.UI;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Unity
{
	[Serializable]
	public struct WidgetTemplate
	{
		public AsakiUIWidgetType Type;
		public GameObject Prefab;
	}

	[CreateAssetMenu(fileName = "AsakiUITemplateConfig", menuName = "Asaki/UI/Template Configuration")]
	public class AsakiUITemplateConfig : ScriptableObject
	{
		public List<WidgetTemplate> Templates = new List<WidgetTemplate>();
        
		// 运行时/编辑器查找缓存
		public GameObject GetTemplate(AsakiUIWidgetType type)
		{
			foreach (var t in Templates)
			{
				if (t.Type == type) return t.Prefab;
			}
			return null;
		}
	}
}
```

<!-- File: Asaki/Unity/Extensions/AsakiResFlowExtensions.cs -->
<!-- GUID: 2cc24338de874cd79d51ced3516a9010 -->
<!-- Size: 2371 bytes -->
<!-- Modified: 2025-12-22 16:47:46 -->
```csharp
using Asaki.Core.Resources;
using Asaki.Unity.Utils;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Extensions
{
	/// <summary>
	/// [资源流扩展] AsakiResFlow
	/// 将 Resources 的加载操作直接绑定到 MonoBehaviour 的生命周期。
	/// </summary>
	public static class AsakiResFlowExtensions
	{
		// =========================================================
		// 1. 生命周期感知的加载 (Lifecycle-Aware Loading)
		// =========================================================

		/// <summary>
		/// 加载资源，并自动绑定到 context 的生命周期。
		/// <para>如果 context (MonoBehaviour) 在加载完成前被销毁，任务将抛出 OperationCanceledException。</para>
		/// </summary>
		/// <typeparam name="T">资源类型</typeparam>
		/// <param name="service">资源服务</param>
		/// <param name="location">资源地址</param>
		/// <param name="context">上下文 (通常是 this)</param>
		public static Task<ResHandle<T>> LoadAsync<T>(this IAsakiResService service, string location, MonoBehaviour context)
			where T : class
		{
			// 自动获取 AsakiFlow 提供的生命周期 Token
			var token = context.GetToken();
			return service.LoadAsync<T>(location, token);
		}

		/// <summary>
		/// 批量加载资源，并自动绑定到 context 的生命周期。
		/// </summary>
		public static Task<List<ResHandle<T>>> LoadBatchAsync<T>(this IAsakiResService service, IEnumerable<string> locations, MonoBehaviour context)
			where T : class
		{
			var token = context.GetToken();
			return service.LoadBatchAsync<T>(locations, token);
		}

		public static Task<ResHandle<T>> LoadAsync<T>(
			this IAsakiResService service,
			string location,
			Action<float> onProgress, // 新增参数
			MonoBehaviour context)
			where T : class
		{
			var token = context.GetToken();
			return service.LoadAsync<T>(location, onProgress, token);
		}

		public static Task<List<ResHandle<T>>> LoadBatchAsync<T>(
			this IAsakiResService service,
			IEnumerable<string> locations,
			Action<float> onProgress, // 新增参数
			MonoBehaviour context)
			where T : class
		{
			var token = context.GetToken();
			return service.LoadBatchAsync<T>(locations, onProgress, token);
		}

	}
}
```

<!-- File: Asaki/Unity/Extensions/AsakiTaskExtensions.cs -->
<!-- GUID: d0190f43ddd1476cb858d6c558192cae -->
<!-- Size: 1433 bytes -->
<!-- Modified: 2025-12-23 18:44:10 -->
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Extensions
{
	public static class AsakiTaskExtensions
	{
		/// <summary>
		/// 安全等待任务完成或取消令牌触发。
		/// <para>解决问题：</para>
		/// <para>1. 即使底层任务无法取消（如资源加载中），也能立即响应用户取消。</para>
		/// <para>2. 避免 CancellationTokenRegistration 的内存泄漏。</para>
		/// </summary>
		public static async Task<T> WaitAsync<T>(this Task<T> task, CancellationToken token)
		{
			if (task.IsCompleted) return await task;

			token.ThrowIfCancellationRequested();

			// 使用 bool 作为占位符，RunContinuationsAsynchronously 防止死锁
			var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

			// 注册取消回调：当 token 取消时，让 tcs 完成
			using (token.Register(() => tcs.TrySetResult(true)))
			{
				// 等待 原始任务 OR 取消信号
				var completedTask = await Task.WhenAny(task, tcs.Task);

				if (completedTask == task)
				{
					return await task; // 原始任务完成
				}
				else
				{
					throw new OperationCanceledException(token); // 取消信号触发
				}
			}
		}
		
		public static void FireAndForget(this Task task)
		{
			if (task.IsFaulted) Debug.LogException(task.Exception);
		}
	}
}
```

<!-- File: Asaki/Unity/Extensions/AsakiUIExtensions.cs -->
<!-- GUID: 7476da145d6b47fe8f9a0b4e62c33b08 -->
<!-- Size: 6229 bytes -->
<!-- Modified: 2025-12-22 17:00:05 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Core.UI;
using Asaki.Generated;
using Asaki.Unity.Services.UI.Observers;
using System.Threading;
using System.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Asaki.Unity.Extensions
{
	public static class AsakiUIExtensions
	{
		// ===========================================
		// 1. 文本显示 (Display)
		// ===========================================

		public static IAsakiObserver<int> BindTo(this AsakiProperty<int> property, TextMeshPro text, string prefix = "", string suffix = "")
		{
			var observer = new AsakiTextMeshProIntObserver(text, prefix, suffix);
			property.Bind(observer);
			return observer;
		}


		public static IAsakiObserver<float> BindTo(this AsakiProperty<float> property, TextMeshPro text, string format = "F1", string prefix = "", string suffix = "")
		{
			var observer = new AsakiTextMeshProFloatObserver(text, format, prefix, suffix);
			property.Bind(observer);
			return observer;
		}

		/// <summary>
		/// 绑定 int 到 TextMeshPro (ZeroGC)
		/// </summary>
		public static IAsakiObserver<int> BindTo(this AsakiProperty<int> property, TMP_Text text, string prefix = "", string suffix = "")
		{
			var observer = new AsakiTMPTextIntObserver(text, prefix, suffix);
			property.Bind(observer);
			return observer;
		}

		/// <summary>
		/// [新增] 绑定 float 到 TextMeshPro (支持格式化，如 "F2")
		/// </summary>
		public static IAsakiObserver<float> BindTo(this AsakiProperty<float> property, TMP_Text text, string format = "F1", string prefix = "", string suffix = "")
		{
			var observer = new AsakiTMPTextFloatObserver(text, format, prefix, suffix);
			property.Bind(observer);
			return observer;
		}

		/// <summary>
		/// [新增] 绑定 string 到 TextMeshPro
		/// </summary>
		public static void BindTo(this AsakiProperty<string> property, TMP_Text text)
		{

			property.Subscribe(val =>
			{
				if (text != null) text.text = val;
			});
		}

		/// <summary>
		/// Legacy Text 绑定 (保留兼容性)
		/// </summary>
		public static IAsakiObserver<int> BindTo(this AsakiProperty<int> property, Text text, string prefix = "", string suffix = "")
		{
			var observer = new AsakiIntTextObserver(text, prefix, suffix);
			property.Bind(observer);
			return observer;
		}

		// ===========================================
		// 2. 输入控件 (Input)
		// ===========================================

		/// <summary>
		/// [双向绑定] 绑定 string 到 TMP_InputField
		/// </summary>
		public static IAsakiObserver<string> BindTwoWay(this AsakiProperty<string> property, TMP_InputField input)
		{
			var observer = new AsakiInputFieldObserver(input);
			property.Bind(observer);

			// UI -> Data
			input.onValueChanged.AddListener(val => property.Value = val);
			return observer;
		}

		/// <summary>
		/// [双向绑定] 绑定 int 到 TMP_Dropdown (下拉菜单)
		/// </summary>
		public static void BindTwoWay(this AsakiProperty<int> property, TMP_Dropdown dropdown)
		{
			// Data -> UI (使用 Lambda 简化，Dropdown 频率不高)
			property.Subscribe(val =>
			{
				if (dropdown != null && dropdown.value != val) dropdown.value = val;
			});

			// UI -> Data
			dropdown.onValueChanged.AddListener(val => property.Value = val);
		}

		// ===========================================
		// 3. 数值控件 (Slider/Toggle)
		// ===========================================

		public static IAsakiObserver<float> BindTo(this AsakiProperty<float> property, Slider slider)
		{
			var observer = new AsakiSliderObserver(slider);
			property.Bind(observer);
			return observer;
		}

		public static IAsakiObserver<float> BindTwoWay(this AsakiProperty<float> property, Slider slider)
		{
			var observer = BindTo(property, slider);
			slider.onValueChanged.AddListener(val => property.Value = val);
			return observer;
		}

		public static IAsakiObserver<bool> BindTo(this AsakiProperty<bool> property, Toggle toggle)
		{
			var observer = new AsakiToggleObserver(toggle);
			property.Bind(observer);
			return observer;
		}

		public static IAsakiObserver<bool> BindTwoWay(this AsakiProperty<bool> property, Toggle toggle)
		{
			var observer = BindTo(property, toggle);
			toggle.onValueChanged.AddListener(val => property.Value = val);
			return observer;
		}

		// ===========================================
		// 4. 状态与显隐 (State & Visibility)
		// ===========================================

		/// <summary>
		/// [新增] 绑定 bool 到 Button 的 interactable 属性
		/// 场景：金币不足时，按钮变灰
		/// </summary>
		public static IAsakiObserver<bool> BindInteractable(this AsakiProperty<bool> property, Selectable selectable)
		{
			var observer = new AsakiInteractableObserver(selectable);
			property.Bind(observer);
			return observer;
		}

		/// <summary>
		/// [新增] 绑定 bool 到 GameObject 的显隐 (SetActive)
		/// 场景：当 IsDead 为 true 时，显示 GameOverPanel
		/// </summary>
		/// <param name="invert">是否反转逻辑 (true: property为true时隐藏物体)</param>
		public static IAsakiObserver<bool> BindActive(this AsakiProperty<bool> property, GameObject target, bool invert = false)
		{
			var observer = new AsakiActiveObserver(target, invert);
			property.Bind(observer);
			return observer;
		}

		/// <summary>
		/// [新增] 绑定 bool 到 CanvasGroup 的 alpha (1 或 0) 和 blocksRaycasts
		/// 场景：比 SetActive 更高性能的软隐藏
		/// </summary>
		public static void BindCanvasGroup(this AsakiProperty<bool> property, CanvasGroup group)
		{
			property.Subscribe(show =>
			{
				if (group == null) return;
				group.alpha = show ? 1f : 0f;
				group.interactable = show;
				group.blocksRaycasts = show;
			});
		}


		public static Task<T> OpenAsync<T>(this IAsakiUIService service, UIID id, object args = null, CancellationToken token = default)
			where T : class, IAsakiWindow
		{
			// 核心逻辑：在这里进行枚举到 int 的强转
			return service.OpenAsync<T>((int)id, args, token);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Audio/AsakiAudioService.cs -->
<!-- GUID: 5412b67a4d8c47a18600bd76c1e3ce0b -->
<!-- Size: 9413 bytes -->
<!-- Modified: 2025-12-25 16:34:21 -->
```csharp
using Asaki.Core.Audio;
using Asaki.Core.Context;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Unity.Configuration;
using Asaki.Unity.Utils;
using Cysharp.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Audio
{
	/// <summary>
	/// [Pure C#] 音频服务管理器。
	/// 不继承 MonoBehaviour，由 AsakiContext 托管生命周期。
	/// </summary>
	public class AsakiAudioService : IAsakiAudioService
	{
		// ==========================================================
		// 1. 数据与依赖 (通过构造函数注入)
		// ==========================================================
		private readonly AsakiAudioConfig _config;
		private readonly string _agentAssetKey;
		private readonly int _initialPoolSize;

		public const string AGENT_POOL_KEY = "Asaki_SoundAgent";

		// ==========================================================
		// 2. 运行时状态
		// ==========================================================
		private IAsakiResService _resService;
		private IAsakiPoolService _poolService;
		private CancellationTokenSource _serviceCts;
		private int _handleCounter = 0;

		// 场景中的根节点，用于挂载所有 SoundAgent，保持 Hierarchy 整洁
		private GameObject _root;
		private Transform _rootTransform;

		// 活跃代理追踪 (Handle -> Agent)
		private readonly Dictionary<AsakiAudioHandle, AsakiSoundAgent> _activeAgents = new(32);
		/// <summary>
		/// 构造函数注入配置。
		/// 由于不再是 MonoBehaviour，无法使用 Inspector 赋值，必须由 ModuleSystem 传入。
		/// </summary>
		public AsakiAudioService(
			IAsakiResService resService,
			IAsakiPoolService poolService,
			AsakiAudioConfig config,
			string agentAssetKey = "Asaki/SoundAgent",
			int initialPoolSize = 16)
		{
			_resService = resService;
			_poolService = poolService;
			_config = config;
			_agentAssetKey = agentAssetKey;
			_initialPoolSize = initialPoolSize;
		}

		// ==========================================================
		// 3. IAsakiModule 生命周期实现
		// ==========================================================

		public void OnInit()
		{
			_serviceCts = new CancellationTokenSource();

			_root = new GameObject("[AsakiAudioSystem]");
			Object.DontDestroyOnLoad(_root);
			_rootTransform = _root.transform;

			if (_config != null) _config.InitializeLookup();
		}

		public async Task OnInitAsync()
		{
			await _poolService.PrewarmAsync(_agentAssetKey, _initialPoolSize);
		}

		public void OnDispose()
		{
			StopAll(0f);

			if (_serviceCts != null)
			{
				_serviceCts.Cancel();
				_serviceCts.Dispose();
				_serviceCts = null;
			}

			// 释放整个 Agent 池 (这会归还所有 Handle)
			_poolService?.ReleasePool(_agentAssetKey);

			if (_root != null)
			{
				Object.Destroy(_root);
				_root = null;
				_rootTransform = null;
			}

			_activeAgents.Clear();
		}

		// ==========================================================
		// 4. 核心功能实现
		// ==========================================================
		public AsakiAudioHandle Play(int assetId, AsakiAudioParams p = default, CancellationToken token = default)
		{
			// 1. 状态检查
			if (_resService == null || _poolService == null || _rootTransform == null) return AsakiAudioHandle.Invalid;

			// 2. 获取资源路径
			if (!_config.TryGet(assetId, out var item))
			{
				Debug.LogWarning($"[AsakiAudio] AudioID {assetId} not registered in Config.");
				return AsakiAudioHandle.Invalid;
			}
			string path = item.AssetPath;
			if (string.IsNullOrEmpty(path)) return AsakiAudioHandle.Invalid;
			float finalVolume = item.Volume * p.Volume;
			float finalPitch = item.Pitch * p.Pitch;
			if (item.RandomPitch)
			{
				finalPitch += UnityEngine.Random.Range(-0.1f, 0.1f);
			}
			bool finalLoop = item.Loop || p.IsLoop;
			var finalParams = p
			                  .SetVolume(finalVolume)
			                  .SetPitch(finalPitch)
			                  .SetLoop(finalLoop);
			// 3. 从池中生成 Agent
			// 使用 _agentAssetKey 作为 Pool Key
			GameObject go = _poolService.Spawn(_agentAssetKey, Vector3.zero, Quaternion.identity, _rootTransform);
			if (go == null) return AsakiAudioHandle.Invalid;

			var agent = go.GetComponent<AsakiSoundAgent>();
			if (agent == null)
			{
				_poolService.Despawn(go, _agentAssetKey);
				return AsakiAudioHandle.Invalid;
			}

			// 4. 生成 Handle 并记录
			var handle = new AsakiAudioHandle(++_handleCounter, Time.frameCount);
			_activeAgents.Add(handle, agent);
			
			// 5. 启动异步播放流程
			var linkedToken = CancellationTokenSource.CreateLinkedTokenSource(_serviceCts.Token, token).Token;

			// 这里传入 _poolService 和 _agentAssetKey，以便 Agent 播放完后能归还自己
			PlayInternal(agent, handle, path, finalParams, linkedToken, _agentAssetKey).FireAndForget(ex =>
			{
				if (ex is not OperationCanceledException)
					Debug.LogError($"[AsakiAudio] Loop Error: {ex}");
			});

			return handle;
		}

		#if ASAKI_USE_UNITASK
		private async UniTask PlayInternal(
			#else
        private async Task PlayInternal(
			#endif
			AsakiSoundAgent agent,
			AsakiAudioHandle handle,
			string path,
			AsakiAudioParams p,
			CancellationToken token,
			string poolKey)
		{
			try
			{
				// 将 poolService 传给 Agent
				await agent.PlayAsync(path, p, _resService, _poolService, token, poolKey);
			}
			finally
			{
				// 无论播放是否成功，都要从活跃列表中移除
				// 注意：Agent 的 Despawn 由 PlayAsync 内部的 finally 块处理
				_activeAgents.Remove(handle);
			}
		}

		public void Pause(AsakiAudioHandle handle)
		{
			if (TryGetAgent(handle, out var agent))
			{
				agent.Pause();
			}
		}

		public void Resume(AsakiAudioHandle handle)
		{
			if (TryGetAgent(handle, out var agent))
			{
				agent.Resume();
			}
		}

		public void Stop(AsakiAudioHandle handle, float fadeDuration = 0.2f)
		{
			if (_activeAgents.TryGetValue(handle, out var agent))
			{
				agent.Stop(fadeDuration);
				_activeAgents.Remove(handle);
			}
		}

		public void StopAll(float fadeDuration = 0.5f)
		{
			var agents = new List<AsakiSoundAgent>(_activeAgents.Values);
			_activeAgents.Clear();

			foreach (var agent in agents)
			{
				if (agent != null && agent.IsPlaying)
				{
					agent.Stop(fadeDuration);
				}
			}
		}

		// ==========================================================
		// 5. 其他接口 (Setters / Getters)
		// ==========================================================

		public void SetGlobalVolume(float volume) => AudioListener.volume = volume;
		public void PauseAll() => AudioListener.pause = true;
		public void ResumeAll() => AudioListener.pause = false;

		public void SetVolume(AsakiAudioHandle handle, float volume)
		{
			if (TryGetAgent(handle, out var agent)) agent.SetVolume(volume);
		}

		public void SetPitch(AsakiAudioHandle handle, float pitch)
		{
			if (TryGetAgent(handle, out var agent)) agent.SetPitch(pitch);
		}

		public void SetSpatialBlend(AsakiAudioHandle handle, float spatialBlend)
		{
			if (TryGetAgent(handle, out var agent))
				agent.GetComponent<AudioSource>().spatialBlend = spatialBlend;
		}

		public void SetPosition(AsakiAudioHandle handle, Vector3 position)
		{
			if (TryGetAgent(handle, out var agent)) agent.SetPosition(position);
		}

		public void SetLoop(AsakiAudioHandle handle, bool isLoop)
		{
			if (TryGetAgent(handle, out var agent)) agent.SetLoop(isLoop);
		}

		public void SetMuted(AsakiAudioHandle handle, bool isMuted)
		{
			if (TryGetAgent(handle, out var agent)) agent.SetMuted(isMuted);
		}

		public void SetPriority(AsakiAudioHandle handle, int priority)
		{
			if (TryGetAgent(handle, out var agent))
				agent.GetComponent<AudioSource>().priority = priority;
		}

		// Group 接口暂留空
		public void SetAudioGroup(AsakiAudioHandle handle, int groupId) { }
		public void SetGroupVolume(int groupId, float volume) { }
		public void SetGroupMuted(int groupId, bool isMuted) { }
		public void PauseGroup(int groupId) { }
		public void ResumeGroup(int groupId) { }
		public void StopGroup(int groupId, float fadeDuration = 0.2f) { }

		// 查询接口
		public bool IsPlaying(AsakiAudioHandle handle) => _activeAgents.ContainsKey(handle);
		public bool IsPaused(AsakiAudioHandle handle)
		{
			if (TryGetAgent(handle, out var agent))
			{
				return agent.IsPaused;
			}
			return false;
		}

		public float GetCurrentVolume(AsakiAudioHandle handle) => TryGetAgent(handle, out var agent) ? agent.GetComponent<AudioSource>().volume : 0f;
		public float GetCurrentPitch(AsakiAudioHandle handle) => TryGetAgent(handle, out var agent) ? agent.GetComponent<AudioSource>().pitch : 1f;
		public Vector3 GetPosition(AsakiAudioHandle handle) => TryGetAgent(handle, out var agent) ? agent.transform.position : Vector3.zero;

		private bool TryGetAgent(AsakiAudioHandle handle, out AsakiSoundAgent agent)
		{
			return _activeAgents.TryGetValue(handle, out agent) && agent;
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Audio/AsakiSoundAgent.cs -->
<!-- GUID: e04febada675439eb6eed60095f8c38d -->
<!-- Size: 6972 bytes -->
<!-- Modified: 2025-12-25 15:14:27 -->
```csharp
using Asaki.Core.Audio;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Unity.Configuration;
using Asaki.Unity.Utils;
using System;
using System.Threading;
using UnityEngine;
using AsakiSmartPool = Asaki.Core.Pooling.AsakiSmartPool;

#if ASAKI_USE_UNITASK
using Cysharp.Threading.Tasks;

#else
using System.Threading.Tasks;
#endif

namespace Asaki.Unity.Services.Audio
{
	[RequireComponent(typeof(AudioSource))]
	public class AsakiSoundAgent : MonoBehaviour, IAsakiPoolable
	{
		private AudioSource _source;
		private ResHandle<AudioClip> _clipHandle;
		private CancellationTokenSource _playCts;
		private Transform _transform;

		// 状态标记
		public bool IsPlaying { get; private set; }
		private bool _isPaused = false;
		public bool IsPaused => _isPaused;

		private void Awake()
		{
			_source = GetComponent<AudioSource>();
			_transform = transform;
			_source.playOnAwake = false;
		}

		// ==========================================================
		// 1. 对象池生命周期
		// ==========================================================

		public void OnSpawn()
		{
			IsPlaying = true;
			_isPaused = false;
			_playCts = new CancellationTokenSource();
		}

		public void OnDespawn()
		{
			// 1. 物理停止
			if (_source != null)
			{
				if (_source.isPlaying) _source.Stop();
				_source.clip = null;
			}

			// 2. 取消令牌清理
			if (_playCts != null)
			{
				_playCts.Cancel();
				_playCts.Dispose();
				_playCts = null;
			}

			// 3. 资源释放 (ResHandle Dispose -> Ref Count --)
			if (_clipHandle != null && _clipHandle.IsValid)
			{
				_clipHandle.Dispose();
				_clipHandle = null;
			}

			IsPlaying = false;
			_isPaused = false;
		}

		// ==========================================================
		// 2. 核心播放逻辑 (PlayAsync)
		// ==========================================================

		// 根据宏定义切换返回类型，保持强类型检查
		#if ASAKI_USE_UNITASK
		public async UniTask PlayAsync(
			#else
        public async Task PlayAsync(
			#endif
			string resourcePath,
			AsakiAudioParams p,
			IAsakiResService resService,
			IAsakiPoolService poolService, // [注入] 新版对象池服务
			CancellationToken serviceToken,
			string poolKey)
		{
			var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
				serviceToken,
				_playCts.Token,
				this.GetCancellationTokenOnDestroy()
			);

			try
			{
				// [Step 1] 异步加载音频资源 (利用 IAsakiResService 策略屏蔽路径差异)
				_clipHandle = await resService.LoadAsync<AudioClip>(resourcePath, linkedCts.Token);

				if (linkedCts.IsCancellationRequested) return;

				// 检查资源有效性 (Handle.IsValid && Asset != null)
				if (_clipHandle == null || !_clipHandle.IsValid)
				{
					Debug.LogWarning($"[AsakiAudio] Failed to load clip: {resourcePath}");
					return;
				}

				// [Step 2] 应用参数配置
				_transform.position = p.Position;
				_source.clip = _clipHandle.Asset; // 从 Handle 获取 Asset
				_source.volume = p.Volume;
				_source.pitch = p.Pitch;
				_source.spatialBlend = p.SpatialBlend;
				_source.loop = p.IsLoop;
				_source.priority = p.Priority;
				_source.mute = false;

				// [Step 3] 开始播放
				_source.Play();

				// [Step 4] 等待播放结束
				if (p.IsLoop)
				{
					// 循环模式：挂起直到被取消
					await AsakiAudioAsyncBridge.WaitUntilCanceled(linkedCts.Token);
				}
				else
				{
					// 单次模式：轮询播放状态
					while (_source.isPlaying || _isPaused)
					{
						if (linkedCts.IsCancellationRequested) break;
						await AsakiAudioAsyncBridge.Yield(); // 分帧等待
						if (_source == null) break;          // 防销毁
					}
				}
			}
			catch (OperationCanceledException)
			{ /* 正常取消 */
			}
			catch (Exception e)
			{
				Debug.LogError($"[AsakiAudio] Play error: {e}");
			}
			finally
			{
				// [Step 5] 播放结束，归还对象池
				linkedCts.Dispose();

				// 只有当 Unity 对象还存活且确实在播放状态时，才归还
				// 避免在场景卸载时重复 Despawn
				if (this && IsPlaying)
				{
					// 使用注入的 poolService 归还，不再依赖静态单例
					poolService.Despawn(gameObject, poolKey);
				}
			}
		}

		// ==========================================================
		// 3. 暂停与恢复 (新增)
		// ==========================================================

		public void Pause()
		{
			if (!IsPlaying || _isPaused) return; // 没在播，或者已经暂停了
			if (_source != null)
			{
				_source.Pause();
				_isPaused = true;
			}
		}

		public void Resume()
		{
			if (!IsPlaying || !_isPaused) return; // 没在播，或者本来就是播放状态
			if (_source != null)
			{
				_source.UnPause();
				_isPaused = false;
			}
		}

		// ==========================================================
		// 3. 动态控制 (Stop & Fade)
		// ==========================================================

		public void Stop(float fadeDuration)
		{
			if (!IsPlaying) return;

			// [Safe Call] 调用异步方法，并使用扩展方法 FireAndForget 处理异常
			// 此时 FadeOutAndStop 返回具体的 Task/UniTask，Bridge 中的重载会生效
			FadeOutAndStop(fadeDuration).FireAndForget(ex =>
			{
				// 忽略 OperationCanceledException，那是我们自己取消的
				if (ex is not OperationCanceledException)
				{
					Debug.LogError($"[AsakiAudio] FadeOut error: {ex}");
				}
			});
		}

		#if ASAKI_USE_UNITASK
		private async UniTask FadeOutAndStop(float duration)
			#else
        private async Task FadeOutAndStop(float duration)
			#endif
		{
			if (_source == null) return;

			// 如果处于暂停状态，先恢复以便进行淡出效果，或者直接停止
			if (_isPaused)
			{
				_source.UnPause();
				_isPaused = false;
			}

			float startVol = _source.volume;
			float timer = 0f;
			while (timer < duration)
			{
				timer += Time.unscaledDeltaTime;
				_source.volume = Mathf.Lerp(startVol, 0f, timer / duration);
				await AsakiAudioAsyncBridge.Yield();
				if (!IsPlaying || _source == null) return;
			}
			_playCts?.Cancel();
		}

		// ==========================================================
		// 4. Setter API
		// ==========================================================
		public void SetVolume(float vol)
		{
			if (_source) _source.volume = vol;
		}
		public void SetPitch(float pitch)
		{
			if (_source) _source.pitch = pitch;
		}
		public void SetPosition(Vector3 pos)
		{
			if (_transform) _transform.position = pos;
		}
		public void SetLoop(bool loop)
		{
			if (_source) _source.loop = loop;
		}
		public void SetMuted(bool muted)
		{
			if (_source) _source.mute = muted;
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Configuration/AsakiConfigHotReloader.cs -->
<!-- GUID: de4f7887b0fa4238b1338dbbaf90fb5c -->
<!-- Size: 5462 bytes -->
<!-- Modified: 2025-12-22 16:45:13 -->
```csharp
#if UNITY_EDITOR

using Asaki.Core.Configuration;
using Asaki.Core.Context;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using UnityEngine;
// 无论是否使用 UniTask，这里都引用 System.Threading.Tasks 以便处理反射返回的 Task

namespace Asaki.Unity.Services.Configuration
{
    /// <summary>
    /// [Editor Only] 配置热重载监听器
    /// </summary>
    public class AsakiConfigHotReloader : MonoBehaviour
    {
        private string _watchPath;
        private FileSystemWatcher _watcher;
        
        // 使用并发队列接收文件变更事件（FileSystemWatcher 在后台线程回调）
        private readonly ConcurrentQueue<string> _changedFiles = new ConcurrentQueue<string>();
        
        // 防抖字典
        private readonly Dictionary<string, float> _debounceMap = new Dictionary<string, float>();
        private const float DEBOUNCE_TIME = 0.5f;

        private void Start()
        {
            // 仅在编辑器下启用
            if (!Application.isEditor)
            {
                Destroy(this);
                return;
            }

            _watchPath = Path.Combine(Application.streamingAssetsPath, "Configs");
            if (!Directory.Exists(_watchPath)) return;

            InitWatcher();
            Debug.Log($"[AsakiConfig] Hot Reload Watcher Started: {_watchPath}");
        }

        private void InitWatcher()
        {
            _watcher = new FileSystemWatcher(_watchPath, "*.csv");
            _watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime;
            _watcher.Changed += OnFileChanged;
            _watcher.EnableRaisingEvents = true;
        }

        private void OnFileChanged(object sender, FileSystemEventArgs e)
        {
            _changedFiles.Enqueue(e.FullPath);
        }

        private void Update()
        {
            // 1. 处理队列
            while (_changedFiles.TryDequeue(out string filePath))
            {
                _debounceMap[filePath] = Time.realtimeSinceStartup + DEBOUNCE_TIME;
            }

            // 2. 检查防抖
            if (_debounceMap.Count > 0)
            {
                var toReload = new List<string>();
                var keys = new List<string>(_debounceMap.Keys);

                foreach (var key in keys)
                {
                    if (Time.realtimeSinceStartup >= _debounceMap[key])
                    {
                        toReload.Add(key);
                        _debounceMap.Remove(key);
                    }
                }

                // 3. 执行重载
                foreach (var path in toReload)
                {
                    ReloadConfig(path);
                }
            }
        }

        private void ReloadConfig(string filePath)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            
            // 需要反射查找配置类型
            Type configType = FindConfigType(fileName);

            if (configType != null)
            {
                Debug.Log($"[AsakiConfig] File Changed: {fileName}, Reloading...");
                
                var service = AsakiContext.Get<IAsakiConfigService>();
                if (service != null)
                {
                    var method = service.GetType().GetMethod("ReloadAsync");
                    if (method != null)
                    {
                        var genericMethod = method.MakeGenericMethod(configType);
                        var taskObj = genericMethod.Invoke(service, null);
                        
                        // 由于接口定义的 ReloadAsync 返回 Task，这里进行简单处理
                        if (taskObj is Task task)
                        {
                            // Fire and forget, catch exceptions
                            Task.Run(async () => {
                                try { await task; }
                                catch (Exception ex) { Debug.LogError(ex); }
                            });
                        }
                    }
                }
            }
        }

        private Type FindConfigType(string typeName)
        {
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                if (assembly.FullName.StartsWith("System") || assembly.FullName.StartsWith("Unity")) continue;
                
                // 尝试常用命名空间规则，或者遍历
                var type = assembly.GetType($"{assembly.GetName().Name}.{typeName}") 
                           ?? assembly.GetType(typeName);
                
                if (type != null) return type;
                
                foreach(var t in assembly.GetTypes())
                {
                    if (t.Name == typeName && typeof(IAsakiConfig).IsAssignableFrom(t))
                        return t;
                }
            }
            return null;
        }

        private void OnDestroy()
        {
            if (_watcher != null)
            {
                _watcher.EnableRaisingEvents = false;
                _watcher.Dispose();
                _watcher = null;
            }
        }
    }
}
#endif```

<!-- File: Asaki/Unity/Services/Configuration/AsakiConfigRegistry.cs -->
<!-- GUID: 1b660b5d031b4275bde906f43b5589db -->
<!-- Size: 1164 bytes -->
<!-- Modified: 2025-12-22 16:45:13 -->
```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

// 统一使用标准 Task

namespace Asaki.Unity.Services.Configuration
{
	/// <summary>
	/// [Asaki Core] 配置注册中心
	/// <para>统一返回 System.Threading.Tasks.Task，确保跨程序集兼容性。</para>
	/// </summary>
	public static class AsakiConfigRegistry
	{
		// 签名：(Service, ConfigName, FilePath) -> Task
		private static readonly List<Func<AsakiConfigService, string, string, Task>> _loaders 
			= new List<Func<AsakiConfigService, string, string, Task>>();

		public static void RegisterLoader(Func<AsakiConfigService, string, string, Task> loader)
		{
			if (!_loaders.Contains(loader))
			{
				_loaders.Add(loader);
			}
		}

		public static Task GetLoader(AsakiConfigService service, string configName, string path)
		{
			foreach (var loader in _loaders)
			{
				var task = loader(service, configName, path);
				if (task != null)
				{
					return task;
				}
			}
			return null; // 返回 null 代表没人处理，而不是 default
		}
        
		public static void Clear() => _loaders.Clear();
	}
}
```

<!-- File: Asaki/Unity/Services/Configuration/AsakiConfigService.cs -->
<!-- GUID: 0f0306b453e74cfea43a12a8b1a7c2a2 -->
<!-- Size: 10362 bytes -->
<!-- Modified: 2025-12-23 19:34:42 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Configuration;
using Asaki.Unity.Services.Serialization;
using Asaki.Unity.Utils;
using Cysharp.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using UnityEngine;
// 核心引用
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Configuration
{
	public class AsakiConfigService : IAsakiConfigService
	{
		// [Security] 系统级序列化口令
		// 必须与 AsakiSaveGenerator 中的定义保持完全一致
		// 只有持有此 Key 的服务才有权将 Config 写入二进制流
		public const string SYSTEM_PERMISSION_KEY = "ASAKI_SYS_KEY_9482_ACCESS";

		private readonly Dictionary<Type, Dictionary<int, IAsakiConfig>> _configStore = new Dictionary<Type, Dictionary<int, IAsakiConfig>>();
		private readonly Dictionary<Type, object> _listStore = new Dictionary<Type, object>();

		private string _csvRootPath;
		private string _binaryCachePath;
		private bool _isEditor;
		private IAsakiEventService _asakiEventService;
		public AsakiConfigService(IAsakiEventService asakiEventService)
		{
			_asakiEventService = asakiEventService;
		}

		public void OnInit()
		{
			_csvRootPath = Path.Combine(Application.streamingAssetsPath, "Configs");
			_binaryCachePath = Path.Combine(Application.persistentDataPath, "ConfigCache");
			_isEditor = Application.isEditor;

			if (!Directory.Exists(_binaryCachePath)) Directory.CreateDirectory(_binaryCachePath);

			if (_isEditor && Application.isPlaying)
			{
				var go = new GameObject("[AsakiConfigHotReloader]");
				go.AddComponent<AsakiConfigHotReloader>();
				Object.DontDestroyOnLoad(go);
			}
		}

		public async Task OnInitAsync()
		{
			await LoadAllAsync();
			Debug.Log($"[AsakiConfig] Service Ready. Loaded {_configStore.Count} tables.");
		}

		public void OnDispose()
		{
			_configStore.Clear();
			_listStore.Clear();
		}

		// =========================================================
		// IAsakiConfigService 接口实现
		// =========================================================

		public Task LoadAllAsync()
		{
			return LoadAllInternal();
		}

		public Task ReloadAsync<T>() where T : class, IAsakiConfig, new()
		{
			return ReloadInternal<T>();
		}

		public T Get<T>(int id) where T : class, IAsakiConfig, new()
		{
			if (_configStore.TryGetValue(typeof(T), out var dict))
			{
				if (dict.TryGetValue(id, out var val)) return (T)val;
			}
			return null;
		}

		public IReadOnlyList<T> GetAll<T>() where T : class, IAsakiConfig, new()
		{
			if (_listStore.TryGetValue(typeof(T), out var list))
			{
				return (IReadOnlyList<T>)list;
			}
			return Array.Empty<T>();
		}

		// =========================================================
		// 核心加载逻辑
		// =========================================================

		private async Task LoadAllInternal()
		{
			if (!Directory.Exists(_csvRootPath)) return;
			var files = Directory.GetFiles(_csvRootPath, "*.csv");
			var tasks = new List<Task>();

			foreach (var file in files)
			{
				string fileName = Path.GetFileNameWithoutExtension(file);

				// 此时 GetLoader 返回的是标准的 Task
				var loadTask = AsakiConfigRegistry.GetLoader(this, fileName, file);

				if (loadTask != null)
				{
					tasks.Add(loadTask);
				}
				else
				{
					Debug.LogWarning($"[AsakiConfig] Skipped '{fileName}'. No registry entry found.");
				}
			}

			await Task.WhenAll(tasks);
		}

		// =========================================================
		// 公开给 Registry 调用的方法 (签名必须返回 Task)
		// =========================================================

		public async Task LoadInternalAsync<T>(string csvPath) where T : class, IAsakiConfig, new()
		{
			string fileName = Path.GetFileNameWithoutExtension(csvPath);
			string binaryPath = Path.Combine(_binaryCachePath, fileName + ".bin");
			List<T> results = null;
			bool shouldLoadBinary = false;


			if (File.Exists(binaryPath))
			{
				if (_isEditor)
				{
					DateTime binTime = File.GetLastWriteTime(binaryPath);
					DateTime csvTime = File.GetLastWriteTime(csvPath);
					if (binTime >= csvTime)
					{
						shouldLoadBinary = true;
					}
					else
					{
						Debug.LogWarning($"[AsakiConfig] Detected stale binary for '{fileName}'. Re-baking from CSV...");
					}
				}
				else
				{
					shouldLoadBinary = true;
				}
			}

			if (shouldLoadBinary)
			{
				try
				{
					results = await LoadFromBinaryAsync<T>(binaryPath);
				}
				catch (Exception ex)
				{
					Debug.LogError($"[AsakiConfig] Failed to load binary '{fileName}', falling back to CSV. Error: {ex.Message}");
					results = null; // 加载失败，回退到 CSV
				}
			}

			if (results == null)
			{
				#if ASAKI_USE_UNITASK
				await UniTask.SwitchToThreadPool();
				string csvContent = await File.ReadAllTextAsync(csvPath);
				await UniTask.SwitchToMainThread();
				#else
                string csvContent = await System.Threading.Tasks.Task.Run(() => File.ReadAllTextAsync(csvPath));
				#endif
				results = await ParseCsvAsync<T>(csvContent);

				// 3. 自动烘焙 (Auto Bake)
				// 只要读了 CSV，就顺手更新一下 Bin，这样下次启动就能快了
				await SaveToBinaryAsync(binaryPath, results);
			}
			BuildIndex(results);
		}

		// =========================================================
		// 内部实现 (Internal)
		// =========================================================

		private async Task<List<T>> ParseCsvAsync<T>(string csvContent) where T : class, IAsakiConfig, new()
		{
			return await Task.Run(() =>
			{
				var lines = csvContent.Replace("\r\n", "\n").Split('\n');
				if (lines.Length < 2) return Task.FromResult(new List<T>());

				var headers = AsakiCsvUtils.ParseLine(lines[0]);
				var headerMap = new Dictionary<string, int>();
				for (int i = 0; i < headers.Length; i++) headerMap[headers[i].Trim()] = i;

				var result = new List<T>(lines.Length);
				for (int i = 1; i < lines.Length; i++)
				{
					if (string.IsNullOrWhiteSpace(lines[i])) continue;

					var rowData = AsakiCsvUtils.ParseLine(lines[i]);
					var reader = new AsakiCsvReader(rowData, headerMap);
					var obj = new T();
					obj.Deserialize(reader);
					result.Add(obj);
				}
				return Task.FromResult(result);
			});
		}

		private async Task<List<T>> LoadFromBinaryAsync<T>(string path) where T : class, IAsakiConfig, new()
		{
			#if ASAKI_USE_UNITASK
			await UniTask.SwitchToThreadPool();
			byte[] bytes = await File.ReadAllBytesAsync(path);
			await UniTask.SwitchToMainThread();
			#else
            byte[] bytes = await Task.Run(() => File.ReadAllBytesAsync(path));
			#endif
			return DeserializeBytes<T>(bytes);
		}

		private async Task SaveToBinaryAsync<T>(string path, List<T> data) where T : class, IAsakiConfig
		{
			byte[] bytes = SerializeBytes(data);
			#if ASAKI_USE_UNITASK
			await UniTask.SwitchToThreadPool();
			await File.WriteAllBytesAsync(path, bytes);
			await UniTask.SwitchToMainThread();
			#else
            await Task.Run(() => File.WriteAllBytesAsync(path, bytes));
			#endif
		}

		private async Task ReloadInternal<T>() where T : class, IAsakiConfig, new()
		{
			string csvPath = Path.Combine(_csvRootPath, typeof(T).Name + ".csv");
			if (File.Exists(csvPath))
			{
				Debug.Log($"[AsakiConfig] Hot Reloading: {typeof(T).Name}...");

				// 1. 读取最新的 CSV 内容
				#if ASAKI_USE_UNITASK
				await UniTask.SwitchToThreadPool();
				string content = await File.ReadAllTextAsync(csvPath);
				await UniTask.SwitchToMainThread();
				#else
                string content = await System.Threading.Tasks.Task.Run(() => File.ReadAllTextAsync(csvPath));
				#endif

				// 2. 解析
				var list = await ParseCsvAsync<T>(content);

				// 3. 更新内存索引
				BuildIndex(list);

				// 4. [关键] 立即更新二进制缓存
				string fileName = typeof(T).Name;
				string binaryPath = Path.Combine(_binaryCachePath, fileName + ".bin");
				await SaveToBinaryAsync(binaryPath, list);

				// 5. 发送事件
				_asakiEventService.Publish(new AsakiConfigReloadedEvent { ConfigType = typeof(T) });
			}
		}

		// =========================================================
		// 纯同步辅助方法
		// =========================================================

		private List<T> DeserializeBytes<T>(byte[] bytes) where T : class, IAsakiConfig, new()
		{
			using (var ms = new MemoryStream(bytes))
			{
				var reader = new AsakiBinaryReader(ms);
				int count = reader.ReadInt(null);
				var list = new List<T>(count);
				for (int i = 0; i < count; i++)
				{
					var obj = new T();
					obj.Deserialize(reader);
					list.Add(obj);
				}
				return list;
			}
		}

		private byte[] SerializeBytes<T>(List<T> data) where T : class, IAsakiConfig
		{
			using (var ms = new MemoryStream())
			{
				var writer = new AsakiBinaryWriter(ms);
				writer.WriteInt(null, data.Count);

				// [Key Pattern Implementation]
				// 遍历所有对象，解锁权限，然后序列化
				foreach (var item in data)
				{
					// [Fix] 显式接口调用：直接调用生成器生成的 AllowConfigSerialization 方法
					// 传递硬编码的 System Key。如果 Key 不对，item 内部会报错并拒绝解锁。
					// 这种方式不需要反射，性能高，类型安全，且 IL2CPP 友好。

					// 注意：因为 T 已经约束为 IAsakiConfig，而我们在 IAsakiConfig 中新增了 AllowConfigSerialization
					// 所以这里可以直接调用，非常干净。
					item.AllowConfigSerialization(SYSTEM_PERMISSION_KEY);

					// 执行序列化 (此时 item 内部 _allowConfigSerialization 已经为 true)
					item.Serialize(writer);
				}

				return ms.ToArray();
			}
		}

		private void BuildIndex<T>(List<T> list) where T : class, IAsakiConfig
		{
			var dict = new Dictionary<int, IAsakiConfig>(list.Count);
			foreach (var item in list)
			{
				if (!dict.ContainsKey(item.Id)) dict.Add(item.Id, item);
			}
			_configStore[typeof(T)] = dict;
			_listStore[typeof(T)] = list;
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Configuration/AsakiCsvReader.cs -->
<!-- GUID: 87f6571089a045eb8cf1b8d7d5b79b8c -->
<!-- Size: 4971 bytes -->
<!-- Modified: 2025-12-22 16:45:09 -->
```csharp
using Asaki.Core.Serialization;
using System.Collections.Generic;
using UnityEngine;

namespace Asaki.Unity.Services.Configuration
{
    /// <summary>
    /// CSV 适配器：将 CSV 行数据伪装成 IAsakiReader 流
    /// 核心目的：利用 Roslyn 生成的 Deserialize 代码，实现零反射解析
    /// </summary>
    public class AsakiCsvReader : IAsakiReader
    {
        private readonly string[] _rowData;
        private readonly Dictionary<string, int> _headerMap;

        // 构造时传入当前行数据和表头映射
        public AsakiCsvReader(string[] rowData, Dictionary<string, int> headerMap)
        {
            _rowData = rowData;
            _headerMap = headerMap;
        }

        // --- 核心魔法：列查找 ---
        private string GetCol(string key)
        {
            // 如果 Key 为空（某些生成的代码可能不传Key），或者找不到列，返回空
            if (string.IsNullOrEmpty(key) || !_headerMap.TryGetValue(key, out int index))
                return string.Empty;
            
            // 防止越界
            if (index >= _rowData.Length) return string.Empty;
            
            return _rowData[index];
        }

        public int ReadVersion() => 1; // CSV 不处理版本控制，默认兼容

        // --- 基础类型解析 ---
        
        public int ReadInt(string key)
        {
            string s = GetCol(key);
            return int.TryParse(s, out int v) ? v : 0;
        }

        public long ReadLong(string key)
        {
            string s = GetCol(key);
            return long.TryParse(s, out long v) ? v : 0L;
        }

        public float ReadFloat(string key)
        {
            string s = GetCol(key);
            return float.TryParse(s, out float v) ? v : 0f;
        }

        public double ReadDouble(string key)
        {
            string s = GetCol(key);
            return double.TryParse(s, out double v) ? v : 0d;
        }

        public string ReadString(string key)
        {
            // 处理 CSV 中常见的转义引号 "" -> "
            string s = GetCol(key);
            if (string.IsNullOrEmpty(s)) return string.Empty;
            return s.Replace("\"\"", "\"");
        }

        public bool ReadBool(string key)
        {
            string s = GetCol(key).ToLower();
            return s == "1" || s == "true" || s == "yes";
        }

        public uint ReadUInt(string key) => uint.TryParse(GetCol(key), out uint v) ? v : 0;
        public ulong ReadULong(string key) => ulong.TryParse(GetCol(key), out ulong v) ? v : 0;

        // --- Unity 原生类型解析 (Native Support) ---
        // 策略：假设 CSV 中 Vector3 存为 "10.5,20,0" 这样的字符串
        
        public Vector3 ReadVector3(string key) => ParseVector3(GetCol(key));
        public Vector2 ReadVector2(string key) => ParseVector2(GetCol(key));
        
        public Vector3Int ReadVector3Int(string key)
        {
            var v = ParseVector3(GetCol(key));
            return new Vector3Int((int)v.x, (int)v.y, (int)v.z);
        }

        public Vector2Int ReadVector2Int(string key)
        {
            var v = ParseVector2(GetCol(key));
            return new Vector2Int((int)v.x, (int)v.y);
        }

        public Vector4 ReadVector4(string key) => Vector4.zero; // 暂不支持
        public Quaternion ReadQuaternion(string key) => Quaternion.identity; // 暂不支持
        public Bounds ReadBounds(string key) => default; // 暂不支持

        // --- 解析辅助 ---
        private Vector3 ParseVector3(string content)
        {
            if (string.IsNullOrWhiteSpace(content)) return Vector3.zero;
            var parts = content.Trim('"').Split(','); // 简单处理
            if (parts.Length < 3) return Vector3.zero;
            
            float.TryParse(parts[0], out float x);
            float.TryParse(parts[1], out float y);
            float.TryParse(parts[2], out float z);
            return new Vector3(x, y, z);
        }

        private Vector2 ParseVector2(string content)
        {
            if (string.IsNullOrWhiteSpace(content)) return Vector2.zero;
            var parts = content.Trim('"').Split(',');
            if (parts.Length < 2) return Vector2.zero;
            
            float.TryParse(parts[0], out float x);
            float.TryParse(parts[1], out float y);
            return new Vector2(x, y);
        }

        // --- 复杂对象与集合 (CSV 不支持嵌套，直接跳过) ---
        public T ReadObject<T>(string key, T existingObj = default) where T : IAsakiSavable, new()
        {
            // CSV 是扁平的，不支持嵌套对象读取
            return default;
        }

        public int BeginList(string key) => 0; // 不支持 List
        public void EndList() { }
    }
}```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiCoroutineRunner.cs -->
<!-- GUID: fb468c54dbb94558a21da27654d30d7c -->
<!-- Size: 230 bytes -->
<!-- Modified: 2025-12-23 17:48:27 -->
```csharp
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	[AddComponentMenu("")]
	internal class AsakiCoroutineRunner : MonoBehaviour
	{
		private void Awake()
		{
			DontDestroyOnLoad(gameObject);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Bridge.cs -->
<!-- GUID: ad3ffcfc7ea949ae94b19b66c15cb1c1 -->
<!-- Size: 3592 bytes -->
<!-- Modified: 2025-12-23 17:51:33 -->
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	public partial class AsakiRoutineProvider
	{
		// =========================================================
        // Core Bridge: IEnumerator -> Task
        // =========================================================

        /// <summary>
        /// [核心桥接] 将 Unity 协程封装为标准 Task。
        /// <para>1. 支持 await 语法糖。</para>
        /// <para>2. 支持 CancellationToken 取消 (立即停止协程)。</para>
        /// <para>3. 0 轮询开销 (Zero Polling Overhead)。</para>
        /// </summary>
        /// <param name="routine">要执行的 Unity 协程迭代器</param>
        /// <param name="token">取消令牌</param>
        private Task RunRoutine(System.Collections.IEnumerator routine, CancellationToken token)
        {
            // 1. 快速检查：如果已经取消，直接返回 Canceled Task
            if (token.IsCancellationRequested) return Task.FromCanceled(token);
            
            // 2. 安全检查：如果 Runner 丢失 (比如游戏退出时)，抛出异常或快速返回
            if (_runner == null) return Task.FromException(new InvalidOperationException("Asaki Coroutine Runner is missing or destroyed."));

            // 3. 创建 TCS (TaskCompletionSource)
            // 关键点：RunContinuationsAsynchronously
            // 这能防止在某些极端情况下 (如协程同步完成) 导致的死锁，并强制后续代码在异步上下文中执行。
            var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

            // 4. 准备协程引用，用于后续取消
            Coroutine activeCoroutine = null;

            // 5. 注册取消回调 (Safety Valve)
            // 当 Token 被 Cancel 时，这个回调会被立即执行
            var registration = token.Register(() => 
            {
                // A. 停止 Unity 侧的协程 (防止后台空跑)
                if (activeCoroutine != null && _runner != null) 
                {
                    _runner.StopCoroutine(activeCoroutine);
                }
                
                // B. 将 Task 标记为取消
                tcs.TrySetCanceled(token);
            });

            // 6. 启动包装协程 (Wrapper)
            // 我们不能直接跑 routine，因为我们需要知道它什么时候结束
            activeCoroutine = _runner.StartCoroutine(ExecWrapper(routine, tcs, registration));

            return tcs.Task;
        }

        /// <summary>
        /// 内部包装器：负责等待原始协程完成，并处理结果
        /// </summary>
        private System.Collections.IEnumerator ExecWrapper(
            System.Collections.IEnumerator targetRoutine, 
            TaskCompletionSource<bool> tcs, 
            CancellationTokenRegistration registration)
        {
            // 等待原始业务逻辑执行完毕 (全权交给 Unity 引擎)
            yield return targetRoutine;

            // === 只有当上面这一行跑完，才会执行下面 ===
            
            // 清理取消注册 (既然跑完了，就不需要监听取消了)
            registration.Dispose();

            // 如果 Task 还没结束 (没被取消)，则标记为成功
            if (!tcs.Task.IsCompleted)
            {
                tcs.TrySetResult(true);
            }
        }
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Core.cs -->
<!-- GUID: 87308edfc0be45f2a16e78acb03ebaed -->
<!-- Size: 3084 bytes -->
<!-- Modified: 2025-12-23 17:50:38 -->
```csharp
using Asaki.Core.Coroutines;
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object; 

namespace Asaki.Unity.Services.Coroutines
{
    // [修改点 1] 增加 IDisposable 接口，养成良好习惯
    public partial class AsakiRoutineProvider : IAsakiRoutineService, IDisposable
    {
        private CancellationTokenSource _serviceCts = new();
        private int _runningTaskCount = 0;

        // [修改点 2] 持有 Runner 的引用
        private AsakiCoroutineRunner _runner;

        // [修改点 3] 构造函数初始化
        public AsakiRoutineProvider()
        {
            InitializeRunner();
        }

        private void InitializeRunner()
        {
            // 防止重复初始化
            if (_runner != null) return;

            // 必须在主线程执行 (构造函数如果不在主线程会报错，但在 Unity 服务定位器模式中通常是安全的)
            var go = new GameObject("[Asaki.Routine.Kernel]");
            Object.DontDestroyOnLoad(go);
            
            // 挂载驱动器
            _runner = go.AddComponent<AsakiCoroutineRunner>();
        }

        public int RunningTaskCount => _runningTaskCount;

        public void CancelAllTasks()
        {
            if (_serviceCts != null)
            {
                _serviceCts.Cancel();
                _serviceCts.Dispose();
            }
            _serviceCts = new CancellationTokenSource();
        }

        public CancellationToken CreateLinkedToken(CancellationToken externalToken = default)
        {
            if (_serviceCts.IsCancellationRequested) return CancellationToken.None;
            if (externalToken == CancellationToken.None) return _serviceCts.Token;
            return CancellationTokenSource.CreateLinkedTokenSource(_serviceCts.Token, externalToken).Token;
        }

        private async Task Track(Func<Task> taskFunc)
        {
            Interlocked.Increment(ref _runningTaskCount);
            try
            {
                await taskFunc();
            }
            catch (OperationCanceledException)
            {
                // 任务被取消是正常操作
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                throw;
            }
            finally
            {
                Interlocked.Decrement(ref _runningTaskCount);
            }
        }

        // [修改点 4] 销毁逻辑
        public void Dispose()
        {
            CancelAllTasks();

            // 销毁宿主 GameObject
            if (_runner != null)
            {
                // 区分运行时和编辑器模式的销毁
                if (Application.isPlaying) 
                    Object.Destroy(_runner.gameObject);
                else 
                    Object.DestroyImmediate(_runner.gameObject);
                
                _runner = null;
            }
        }
    }
}```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Tasks.cs -->
<!-- GUID: 8ec10dc87628413194c72042d2e30eb2 -->
<!-- Size: 7380 bytes -->
<!-- Modified: 2025-12-23 17:58:59 -->
```csharp
using Asaki.Core.Coroutines;
using Cysharp.Threading.Tasks;
using System;
using System.Collections; // 引入 IEnumerator
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Unity.Services.Coroutines
{
	/// <summary>
	/// [异步服务实现] Part 3: Tasks & Orchestration (Native Refactored)
	/// </summary>
	public partial class AsakiRoutineProvider
	{
		// =========================================================
		// 1. 任务执行包装
		// =========================================================

		public Task RunTask(Func<Task> taskFunc, CancellationToken token = default)
		{
			// Track 负责了计数和异常时的计数恢复，直接复用
			return Track(taskFunc);
		}

		public async Task<T> RunTask<T>(Func<Task<T>> taskFunc, CancellationToken token = default)
		{
			// 链接 Token (虽然 taskFunc 内部可能不使用，但作为 API 契约建议处理)
			// 注意：这里我们无法强行取消 taskFunc 内部的逻辑，除非 taskFunc 接收 token
			// 所以这里的 token 主要是为了 Check
			if (token.IsCancellationRequested) throw new OperationCanceledException(token);

			Interlocked.Increment(ref _runningTaskCount);
			try
			{
				return await taskFunc();
			}
			finally
			{
				Interlocked.Decrement(ref _runningTaskCount);
			}
		}

		// =========================================================
		// 2. 快捷调用 (自动享受 Native 优化)
		// =========================================================

		public async Task DelayedCall(float delaySeconds, Action action, CancellationToken token = default, bool unscaled = false)
		{
			// 使用 Track 确保计入 RunningTaskCount
			await Track(async () =>
			{
				var linkedToken = CreateLinkedToken(token);

				// 这里调用的是 Part 2 中已经优化的 Native 方法
				if (unscaled) await WaitSecondsUnscaled(delaySeconds, linkedToken);
				else await WaitSeconds(delaySeconds, linkedToken);

				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		public async Task NextFrameCall(Action action, CancellationToken token = default)
		{
			await Track(async () =>
			{
				var linkedToken = CreateLinkedToken(token);
				await WaitFrame(linkedToken);
				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		public async Task When(Func<bool> condition, Action action, CancellationToken token = default)
		{
			await Track(async () =>
			{
				var linkedToken = CreateLinkedToken(token);
				await WaitUntil(condition, linkedToken);
				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		// =========================================================
		// 3. 批量与流程控制
		// =========================================================

		public Task WaitAll(params Task[] tasks) => Task.WhenAll(tasks);

		public Task WaitAny(params Task[] tasks) => Task.WhenAny(tasks);

		public async Task Sequence(params Func<Task>[] actions)
		{
			await Track(async () =>
			{
				foreach (var action in actions)
				{
					// 依次执行，只要子任务是 Native 的，这里就是高效的
					await action();
				}
			});
		}

		public async Task Parallel(params Func<Task>[] actions)
		{
			await Track(async () =>
			{
				var tasks = new Task[actions.Length];
				for (int i = 0; i < actions.Length; i++)
				{
					tasks[i] = actions[i]();
				}
				await Task.WhenAll(tasks);
			});
		}

		public async Task Retry(Func<Task> action, int maxRetries = 3, float retryDelay = 1f, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			await Track(async () =>
			{
				for (int i = 0; i < maxRetries; i++)
				{
					try
					{
						await action();
						return; // 成功
					}
					catch (Exception)
					{
						if (i == maxRetries - 1) throw; // 最后一次失败
						if (linkedToken.IsCancellationRequested) return;

						// 失败等待 (Native 优化)
						await WaitSeconds(retryDelay, linkedToken);
					}
				}
			});
		}

		// =========================================================
		// 4. [重构重点] 自定义等待源 (Native Optimized)
		// =========================================================

		public Task WaitCustom(IAsakiWaitSource waitSource, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			// UniTask 路径：使用 ToUniTask 或手动轮询
			// 为了保持一致性，且 IAsakiWaitSource 是 C# 接口，我们依然需要轮询
			// 但 UniTask 的轮询开销极低
			return WaitCustomUniTask(waitSource, linkedToken).AsTask();
			#else
            // Native 路径：使用 RunRoutine 下沉到协程
            return RunRoutine(WaitCustomRoutine(waitSource), linkedToken);
			#endif
		}

		#if ASAKI_USE_UNITASK
		private async Cysharp.Threading.Tasks.UniTask WaitCustomUniTask(IAsakiWaitSource source, CancellationToken token)
		{
			while (!source.IsCompleted)
			{
				source.Update();
				await Cysharp.Threading.Tasks.UniTask.Yield(Cysharp.Threading.Tasks.PlayerLoopTiming.Update, token);
			}
		}
		#endif

		/// <summary>
		/// [内部协程] 将 Update 循环下沉到 Unity 引擎层
		/// </summary>
		private IEnumerator WaitCustomRoutine(IAsakiWaitSource source)
		{
			while (!source.IsCompleted)
			{
				// 执行用户的自定义 Update 逻辑
				source.Update();

				// 等待一帧 (0 GC)
				yield return null;
			}
		}

		// =========================================================
		// 5. Builder 实现 (无需修改，逻辑正确)
		// =========================================================

		public IWaitBuilder CreateWaitBuilder()
		{
			return new AsakiWaitBuilder(this);
		}

		private class AsakiWaitBuilder : IWaitBuilder
		{
			private readonly IAsakiRoutineService _service;
			private readonly List<Func<CancellationToken, Task>> _steps = new List<Func<CancellationToken, Task>>();

			public AsakiWaitBuilder(IAsakiRoutineService service)
			{
				_service = service;
			}

			public IWaitBuilder Seconds(float seconds, bool unscaled = false)
			{
				_steps.Add(ct => unscaled
					? _service.WaitSecondsUnscaled(seconds, ct)
					: _service.WaitSeconds(seconds, ct));
				return this;
			}

			public IWaitBuilder Frames(int count)
			{
				_steps.Add(ct => _service.WaitFrames(count, ct));
				return this;
			}

			public IWaitBuilder FixedFrames(int count)
			{
				_steps.Add(ct => _service.WaitFixedFrames(count, ct));
				return this;
			}

			public IWaitBuilder Until(Func<bool> condition)
			{
				_steps.Add(ct => _service.WaitUntil(condition, ct));
				return this;
			}

			public IWaitBuilder While(Func<bool> condition)
			{
				_steps.Add(ct => _service.WaitWhile(condition, ct));
				return this;
			}

			public async Task Build(CancellationToken token = default)
			{
				// 这里再次 Link 是为了安全，确保 Builder 执行过程中的取消能被响应
				var linkedToken = _service.CreateLinkedToken(token);

				foreach (var step in _steps)
				{
					if (linkedToken.IsCancellationRequested) break;
					await step(linkedToken);
				}
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Time.cs -->
<!-- GUID: 57e39c58841244bb82d1220bc3df61e1 -->
<!-- Size: 7960 bytes -->
<!-- Modified: 2025-12-23 17:54:00 -->
```csharp
using Cysharp.Threading.Tasks; // 如果没有定义宏，这行会被忽略或报错，但在 Asaki 中通常通过 ASMDEF 隔离
using System;
using System.Collections; // 必须引用
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	/// <summary>
	/// [异步服务实现] Part 2: Time & Wait (Native Refactored)
	/// <para>V5.0 重构版：抛弃 Task.Yield 轮询，全面拥抱 Unity 原生 Coroutine。</para>
	/// </summary>
	public partial class AsakiRoutineProvider
	{
		// =========================================================
		// 1. 辅助协程实现 (Impls)
		// 这里的很多指令是 YieldInstruction，需要包裹在 IEnumerator 中
		// =========================================================

		private IEnumerator WaitForSecondsImpl(float seconds)
		{
			yield return new WaitForSeconds(seconds);
		}

		private IEnumerator WaitForSecondsRealtimeImpl(float seconds)
		{
			yield return new WaitForSecondsRealtime(seconds);
		}

		private IEnumerator WaitFramesImpl(int count)
		{
			for (int i = 0; i < count; i++) yield return null;
		}

		private IEnumerator WaitFixedFramesImpl(int count)
		{
			var wait = new WaitForFixedUpdate();
			for (int i = 0; i < count; i++) yield return wait;
		}

		private IEnumerator WaitUntilImpl(Func<bool> predicate)
		{
			yield return new WaitUntil(predicate);
		}

		private IEnumerator WaitWhileImpl(Func<bool> predicate)
		{
			yield return new WaitWhile(predicate);
		}

		// =========================================================
		// 2. 时间等待 (Time)
		// =========================================================

		public Task WaitSeconds(float seconds, CancellationToken token = default)
		{
			// 1. 链接 Token
			var linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			return UniTask.Delay(TimeSpan.FromSeconds(seconds), DelayType.DeltaTime, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			// 2. 快速路径：时间为0或已取消
			if (seconds <= 0) return Task.CompletedTask;
			
			// 3. 桥接到原生协程
			return RunRoutine(WaitForSecondsImpl(seconds), linkedToken);
			#endif
		}

		public Task WaitSecondsUnscaled(float seconds, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			return UniTask.Delay(TimeSpan.FromSeconds(seconds), DelayType.UnscaledDeltaTime, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			if (seconds <= 0) return Task.CompletedTask;
			return RunRoutine(WaitForSecondsRealtimeImpl(seconds), linkedToken);
			#endif
		}

		// =========================================================
		// 3. 帧等待 (Frames)
		// =========================================================

		public Task WaitFrame(CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.Yield(PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			// 这里的 1 代表等待 1 帧 (yield return null)
			return RunRoutine(WaitFramesImpl(1), linkedToken);
			#endif
		}

		public Task WaitFrames(int count, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.DelayFrame(count, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			if (count <= 0) return Task.CompletedTask;
			return RunRoutine(WaitFramesImpl(count), linkedToken);
			#endif
		}

		public Task WaitFixedFrame(CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.Yield(PlayerLoopTiming.FixedUpdate, linkedToken).AsTask();
			#else
			return RunRoutine(WaitFixedFramesImpl(1), linkedToken);
			#endif
		}

		public Task WaitFixedFrames(int count, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.DelayFrame(count, PlayerLoopTiming.FixedUpdate, linkedToken).AsTask();
			#else
			if (count <= 0) return Task.CompletedTask;
			return RunRoutine(WaitFixedFramesImpl(count), linkedToken);
			#endif
		}

		// =========================================================
		// 4. 条件等待 (Conditions)
		// =========================================================

		public Task WaitUntil(Func<bool> predicate, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.WaitUntil(predicate, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			return RunRoutine(WaitUntilImpl(predicate), linkedToken);
			#endif
		}

		public Task WaitWhile(Func<bool> predicate, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.WaitWhile(predicate, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			return RunRoutine(WaitWhileImpl(predicate), linkedToken);
			#endif
		}

		// =========================================================
		// 5. 复杂逻辑：带超时的等待 (Complex Logic)
		// =========================================================

		public async Task<bool> WaitUntil(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default)
		{
			var linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			try
			{
				await UniTask.WaitUntil(predicate, PlayerLoopTiming.Update, linkedToken)
				             .Timeout(TimeSpan.FromSeconds(timeoutSeconds));
				return true;
			}
			catch (TimeoutException) { return false; }
			catch (OperationCanceledException) { return false; } // 根据需求，取消也可以视为"未成功"
			#else
			
			// === Native Implementation ===
			// 这是一个手动构建的"有返回值"的桥接器

			// 1. 快速检查
			if (linkedToken.IsCancellationRequested) return false;
			if (_runner == null) return false;

			// 2. 创建 TCS (返回 bool)
			var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

			// 3. 启动协程引用
			Coroutine activeCoroutine = null;

			// 4. 注册取消回调
			using (linkedToken.Register(() => 
			{
				if (activeCoroutine != null && _runner != null) _runner.StopCoroutine(activeCoroutine);
				tcs.TrySetCanceled(linkedToken);
			}))
			{
				// 5. 启动自定义的超时协程
				activeCoroutine = _runner.StartCoroutine(WaitUntilTimeoutRoutine(predicate, timeoutSeconds, tcs));

				try 
				{
					return await tcs.Task;
				}
				catch (OperationCanceledException)
				{
					return false;
				}
			}
			#endif
		}

		/// <summary>
		/// [内部协程] 执行带超时的条件等待
		/// </summary>
		private IEnumerator WaitUntilTimeoutRoutine(Func<bool> predicate, float timeout, TaskCompletionSource<bool> tcs)
		{
			float timer = 0f;
			
			// 核心循环：完全在 Unity 协程调度器中运行
			// 相比 C# 的 Task.Yield 循环，这里避免了大量的 Task 状态机上下文切换
			while (timer < timeout)
			{
				// 检查条件
				if (predicate())
				{
					tcs.TrySetResult(true); // 成功
					yield break;
				}

				// 如果外部 Task 已经被取消 (通过 Register 回调)，则退出协程
				if (tcs.Task.IsCanceled) yield break;

				// 等待下一帧 (原生 Unity 等待)
				yield return null;
				
				// 累加时间
				timer += Time.deltaTime;
			}
			
			// 循环结束仍未满足 -> 超时
			tcs.TrySetResult(false);
		}

		public async Task<bool> WaitWhile(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default)
		{
			// 复用 WaitUntil 的逻辑，只是条件取反
			return await WaitUntil(() => !predicate(), timeoutSeconds, token);
		}
	}
}```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiTaskVoid.cs -->
<!-- GUID: 3cf83cadeb054bcaa74e4e1179ec69bb -->
<!-- Size: 3305 bytes -->
<!-- Modified: 2025-12-23 17:56:06 -->
```csharp
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Asaki.Core.Tasks
{
    /// <summary>
    /// [Asaki Native] 轻量级异步 void 替代方案。
    /// <para>用于 "Fire-and-Forget" 场景。</para>
    /// <para>相比 async void，它能捕获并记录未处理的异常，防止程序崩溃或异常静默丢失。</para>
    /// </summary>
    [AsyncMethodBuilder(typeof(AsakiTaskVoidMethodBuilder))]
    public readonly struct AsakiTaskVoid
    {
        /// <summary>
        /// 显式调用此方法以消除 "调用未等待" 的编译器警告。
        /// </summary>
        public void Forget()
        {
            // 纯语义方法，运行时无操作
        }
    }

    /// <summary>
    /// [Internal] 负责构建 AsakiTaskVoid 状态机的构建器。
    /// 核心逻辑在于 SetException 时将异常输出到 Unity 控制台。
    /// </summary>
    public struct AsakiTaskVoidMethodBuilder
    {
        // 1. 创建构建器实例 (编译器调用)
        public static AsakiTaskVoidMethodBuilder Create() => default;

        // 2. 返回给调用者的对象 (编译器调用)
        public AsakiTaskVoid Task => default;

        // 3. 状态机启动 (编译器调用)
        [DebuggerHidden]
        public void Start<TStateMachine>(ref TStateMachine stateMachine) 
            where TStateMachine : IAsyncStateMachine
        {
            stateMachine.MoveNext();
        }

        // 4. 关联状态机 (编译器调用 - 仅在类模式下使用，Struct模式下通常为空)
        public void SetStateMachine(IAsyncStateMachine stateMachine) { }

        // 5. 任务成功完成时调用
        public void SetResult()
        {
            // Do nothing - void 任务不需要结果
        }

        // 6. [核心] 任务抛出未处理异常时调用
        public void SetException(Exception exception)
        {
            // 在这里拦截了原本会导致 async void 崩溃或静默失败的异常
            // 强制输出到 Unity 控制台
            AsakiTaskExceptionLogger.Log(exception);
        }

        // 7. 处理 await (常规)
        public void AwaitOnCompleted<TAwaiter, TStateMachine>(
            ref TAwaiter awaiter, ref TStateMachine stateMachine)
            where TAwaiter : INotifyCompletion
            where TStateMachine : IAsyncStateMachine
        {
            awaiter.OnCompleted(stateMachine.MoveNext);
        }

        // 8. 处理 await (不安全/高性能)
        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(
            ref TAwaiter awaiter, ref TStateMachine stateMachine)
            where TAwaiter : ICriticalNotifyCompletion
            where TStateMachine : IAsyncStateMachine
        {
            awaiter.UnsafeOnCompleted(stateMachine.MoveNext);
        }
    }

    /// <summary>
    /// [Internal] 简单的异常日志记录器
    /// </summary>
    internal static class AsakiTaskExceptionLogger
    {
        public static void Log(Exception ex)
        {
            // 你可以在这里扩展，比如上报到服务器或弹出错误窗口
            UnityEngine.Debug.LogException(ex);
        }
    }
}```

<!-- File: Asaki/Unity/Services/Resources/AsakiResKitFactory.cs -->
<!-- GUID: f5d83e95d244456aa8e543cd6d41b42d -->
<!-- Size: 3579 bytes -->
<!-- Modified: 2025-12-23 19:40:56 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Coroutines;
using Asaki.Core.Resources;
using Asaki.Unity.Services.Resources.Lookup;
using Asaki.Unity.Services.Resources.Strategies;
using System;

namespace Asaki.Unity.Services.Resources
{
    /// <summary>
    /// [Resources 工厂]
    /// 负责组装 Strategy, Lookup 和 Service，产出可用的 IAsakiResService。
    /// </summary>
    public static class AsakiResKitFactory
    {
        // 用于存储自定义策略的构建器 (针对 Custom 模式)
        private static Func<IAsakiResStrategy> _customStrategyBuilder;
        private static Func<IAsakiResDependencyLookup> _customLookupBuilder;

        /// <summary>
        /// 注册自定义策略 (如果你想用 AssetBundle 或其他方案)
        /// </summary>
        public static void RegisterCustom(Func<IAsakiResStrategy> strategyBuilder, Func<IAsakiResDependencyLookup> lookupBuilder = null)
        {
            _customStrategyBuilder = strategyBuilder;
            _customLookupBuilder = lookupBuilder;
        }

        /// <summary>
        /// 创建 Resources 服务实例
        /// </summary>
        /// <param name="mode">运行模式</param>
        /// <param name="routineService">异步驱动服务 (必须已初始化)</param>
        /// <returns>初始化好的资源服务</returns>
        public static IAsakiResService Create(AsakiResKitMode mode, IAsakiRoutineService routineService, IAsakiEventService eventService)
        {
            if (routineService == null) 
                throw new ArgumentNullException(nameof(routineService), "[ResKitFactory] RoutineService cannot be null.");

            IAsakiResStrategy strategy = null;
            IAsakiResDependencyLookup lookup = null;

            switch (mode)
            {
                case AsakiResKitMode.Resources:
                    // 策略：原生 Resources
                    strategy = new AsakiResourcesStrategy();
                    // 依赖：Resources 自动管理，不需要手动 Lookup
                    lookup = AsakiNullResDependencyLookup.Instance; 
                    break;

                case AsakiResKitMode.Addressables:
#if ASAKI_USE_ADDRESSABLE
                    // 策略：Addressables
                    strategy = new AsakiAddressablesStrategy();
                    // 依赖：Addressables 内部 Catalog 自动管理
                    lookup = AsakiNullResDependencyLookup.Instance;
#else
                    throw new NotSupportedException(
                        "[ResKitFactory] Addressables mode requires 'ASAKI_USE_ADDRESSABLE' macro and Addressables package installed.");
#endif
                    break;

                case AsakiResKitMode.Custom:
                    if (_customStrategyBuilder == null)
                        throw new InvalidOperationException("[ResKitFactory] Custom mode selected but no custom strategy registered.");
                    
                    strategy = _customStrategyBuilder();
                    // 如果没提供 lookup，默认给个空的
                    lookup = _customLookupBuilder != null ? _customLookupBuilder() : AsakiNullResDependencyLookup.Instance;
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(mode), mode, null);
            }

            // 组装并返回
            var service = new AsakiResService(strategy, routineService, lookup);
            return service;
        }
    }
}```

<!-- File: Asaki/Unity/Services/Resources/AsakiResKitMode.cs -->
<!-- GUID: 588a17e859e54e1b9335985711dcbbd2 -->
<!-- Size: 826 bytes -->
<!-- Modified: 2025-12-22 16:45:54 -->
```csharp
namespace Asaki.Unity.Services.Resources
{
	/// <summary>
	/// [Resources 运行模式]
	/// </summary>
	public enum AsakiResKitMode
	{
		/// <summary>
		/// 使用 UnityEngine.Resources (开发期/原型期)
		/// <para>优点：无需打包，即改即用。</para>
		/// <para>缺点：构建包体大，内存管理较差，不支持热更。</para>
		/// </summary>
		Resources,

		/// <summary>
		/// 使用 Unity Addressables (生产环境)
		/// <para>优点：内存管理优秀，自动依赖处理，支持热更。</para>
		/// <para>缺点：需要 Build Bundle 步骤。</para>
		/// </summary>
		Addressables,

		/// <summary>
		/// 自定义模式 (例如原生 AssetBundle)
		/// <para>需要通过 Factory.RegisterCustomStrategy 注册。</para>
		/// </summary>
		Custom
	}
}
```

<!-- File: Asaki/Unity/Services/Resources/AsakiResService.cs -->
<!-- GUID: 8c8cebc2930541ae83c403d57cce02d5 -->
<!-- Size: 13477 bytes -->
<!-- Modified: 2025-12-22 16:45:54 -->
```csharp
using Asaki.Core.Coroutines;
using Asaki.Core.Resources;
using Asaki.Unity.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Resources
{
    public class AsakiResService : IAsakiResService
    {
        private readonly IAsakiResStrategy _strategy;
        private readonly IAsakiRoutineService _routineService;
        private readonly IAsakiResDependencyLookup _asakiResDependencyLookup;

        private class ResRecord
        {
            public string Location;
            public Object Asset;
            public int RefCount;
            // 使用 HashSet 防止重复依赖
            public HashSet<string> DependencyLocations = new HashSet<string>();
            public TaskCompletionSource<Object> LoadingTcs = new(TaskCreationOptions.RunContinuationsAsynchronously);

            public Action<float> ProgressCallbacks;

            public void ReportProgress(float progress)
            {
                ProgressCallbacks?.Invoke(progress);
            }
        }

        private readonly Dictionary<string, ResRecord> _cache = new();
        private readonly object _lock = new object();

        public AsakiResService(IAsakiResStrategy strategy, IAsakiRoutineService routineService, IAsakiResDependencyLookup asakiResDependencyLookup)
        {
            _strategy = strategy;
            _routineService = routineService;
            _asakiResDependencyLookup = asakiResDependencyLookup;
        }

        public Task OnInitAsync() => _strategy.InitializeAsync();
        public void OnInit() { }

        public void OnDispose()
        {
            lock (_lock)
            {
                foreach (var kvp in _cache)
                {
                    if (kvp.Value.Asset != null)
                        _strategy.UnloadAssetInternal(kvp.Key, kvp.Value.Asset);
                }
                _cache.Clear();
            }
        }

        // =========================================================
        // Load Interface
        // =========================================================

        public Task<ResHandle<T>> LoadAsync<T>(string location, CancellationToken token) where T : class
        {
            return LoadAsync<T>(location, null, token);
        }

        public async Task<ResHandle<T>> LoadAsync<T>(string location, Action<float> onProgress, CancellationToken token) where T : class
        {
            var record = GetOrCreateRecord(location);

            // 进度回调注册
            if (onProgress != null)
            {
                if (record.Asset != null) onProgress(1f);
                else record.ProgressCallbacks += onProgress;
            }

            // 乐观锁引用计数
            Interlocked.Increment(ref record.RefCount);

            try
            {
                var assetObj = await record.LoadingTcs.Task.WaitAsync(token);

                if (assetObj is T tAsset)
                {
                    return new ResHandle<T>(location, tAsset, this);
                }
                else
                {
                    throw new InvalidCastException($"[Resources] Type mismatch for {location}. Expected {typeof(T)}, got {assetObj?.GetType()}");
                }
            }
            catch (Exception)
            {
                // 发生取消或错误时，回滚引用
                ReleaseInternal(location);
                throw;
            }
            finally
            {
                // 清理进度委托，防止内存泄漏
                if (onProgress != null)
                {
                    record.ProgressCallbacks -= onProgress;
                }
            }
        }

        // =========================================================
        // Internal Logic
        // =========================================================

        private ResRecord GetOrCreateRecord(string location)
        {
            ResRecord record;
            bool isOwner = false;

            lock (_lock)
            {
                if (!_cache.TryGetValue(location, out record))
                {
                    record = new ResRecord { Location = location };
                    _cache.Add(location, record);
                    isOwner = true;
                }
            }

            if (isOwner)
            {
                SafeStartLoadTask(record);
            }

            return record;
        }

        private async void SafeStartLoadTask(ResRecord record)
        {
            try
            {
                await LoadTaskInternal(record);
            }
            catch (Exception ex)
            {
                // 确保 TCS 终结
                if (!record.LoadingTcs.Task.IsCompleted)
                {
                    record.LoadingTcs.TrySetException(ex);
                }

                // 从缓存移除
                lock (_lock) { _cache.Remove(record.Location); }

                // 错误回滚：释放已加载的依赖
                // 注意：这里需要对 DependencyLocations 加锁，防止与 ReleaseInternal 冲突
                lock (record.DependencyLocations)
                {
                    foreach (var dep in record.DependencyLocations) ReleaseInternal(dep);
                }
            }
        }

        private async Task LoadTaskInternal(ResRecord record)
        {
            try
            {
                // --- 1. 依赖加载 ---
                var deps = _asakiResDependencyLookup.GetDependencies(record.Location);
                if (deps != null)
                {
                    foreach (var depLoc in deps)
                    {
                        var depRecord = GetOrCreateRecord(depLoc);
                        
                        // [关键修正1] 先增加引用计数
                        Interlocked.Increment(ref depRecord.RefCount);

                        // [关键修正2] 检查主资源有效性并记录依赖
                        // 如果此时主资源已经被 Release 并移出缓存，我们不能继续持有依赖，否则会导致依赖泄露
                        bool isValid = false;
                        lock (_lock)
                        {
                            if (_cache.ContainsKey(record.Location))
                            {
                                lock (record.DependencyLocations)
                                {
                                    record.DependencyLocations.Add(depLoc);
                                }
                                isValid = true;
                            }
                        }

                        // 如果主资源已失效（被取消），立即释放刚才获取的依赖并终止
                        if (!isValid)
                        {
                            ReleaseInternal(depLoc);
                            throw new OperationCanceledException($"[Resources] Loading aborted for {record.Location}");
                        }

                        // [关键修正3] 记录之后再等待
                        // 这样即使 Wait 超时抛出异常，catch 块也能在 DependencyLocations 中找到并释放它
                        var dependencyTask = depRecord.LoadingTcs.Task;
                        var finishedTask = await Task.WhenAny(dependencyTask, Task.Delay(10000));
                        
                        if (finishedTask != dependencyTask)
                        {
                            throw new TimeoutException($"[Resources] Dependency Timeout: {depLoc} (Possible circular dependency)");
                        }
                        
                        // 确保依赖任务没有报错
                        if (dependencyTask.IsFaulted) throw dependencyTask.Exception;
                    }
                }

                // --- 2. 自身加载 ---
                
                // 切换到主线程
                var asset = await _routineService.RunTask(async () => await _strategy.LoadAssetInternalAsync(
                    record.Location,
                    typeof(Object),
                    record.ReportProgress,
                    CancellationToken.None
                ));

                if (asset == null) throw new Exception($"[Resources] Asset not found: {record.Location}");

                record.Asset = asset;
                record.LoadingTcs.TrySetResult(asset);
                record.ReportProgress(1f);
            }
            catch (Exception ex)
            {
                record.LoadingTcs.TrySetException(ex);
                
                // 清理缓存
                lock (_lock) { _cache.Remove(record.Location); }

                // 回滚依赖
                lock (record.DependencyLocations)
                {
                    foreach (var dep in record.DependencyLocations) ReleaseInternal(dep);
                }
            }
        }

        // =========================================================
        // Release Logic
        // =========================================================

        public void Release(string location)
        {
            ReleaseInternal(location);
        }

        private void ReleaseInternal(string rootLocation)
        {
            var pendingRelease = new Stack<string>();
            pendingRelease.Push(rootLocation);

            lock (_lock)
            {
                while (pendingRelease.Count > 0)
                {
                    var currentLocation = pendingRelease.Pop();

                    if (_cache.TryGetValue(currentLocation, out var record))
                    {
                        record.RefCount--;

                        if (record.RefCount <= 0)
                        {
                            if (record.Asset != null)
                            {
                                try { _strategy.UnloadAssetInternal(currentLocation, record.Asset); }
                                catch (Exception e) { UnityEngine.Debug.LogError(e); }
                            }
                            
                            // 必须先移除，防止 LoadTaskInternal 继续往里面加依赖
                            _cache.Remove(currentLocation);

                            if (record.DependencyLocations != null)
                            {
                                // 这里加锁是为了安全，尽管 RefCount=0 时理论上 LoadTaskInternal 应该已经停了或者也会失败
                                lock (record.DependencyLocations)
                                {
                                    foreach (var dep in record.DependencyLocations)
                                    {
                                        pendingRelease.Push(dep);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // =========================================================
        // Batch Operations
        // =========================================================

        public async Task<List<ResHandle<T>>> LoadBatchAsync<T>(IEnumerable<string> locations, Action<float> onProgress, CancellationToken token) where T : class
        {
            var locList = locations.ToList();
            if (locList.Count == 0) 
            {
                onProgress?.Invoke(1f);
                return new List<ResHandle<T>>();
            }

            // [关键修正4] 批量进度聚合
            // 我们不能直接把 onProgress 传给每个任务，否则进度条会乱跳
            float[] progresses = new float[locList.Count];
            Action<float> GetProgressHandler(int index)
            {
                return (p) =>
                {
                    progresses[index] = p;
                    {
                        // 计算平均进度
                        float total = 0f;
                        for (int i = 0; i < progresses.Length; i++) total += progresses[i];
                        onProgress(total / progresses.Length);
                    }
                };
            }

            var tasks = new Task<ResHandle<T>>[locList.Count];
            for (int i = 0; i < locList.Count; i++)
            {
                // 为每个任务分配一个专属的进度回调
                tasks[i] = LoadAsync<T>(locList[i], onProgress == null ? null : GetProgressHandler(i), token);
            }

            var results = await Task.WhenAll(tasks);
            return results.ToList();
        }

        public Task<List<ResHandle<T>>> LoadBatchAsync<T>(IEnumerable<string> locations, CancellationToken token) where T : class
        {
            return LoadBatchAsync<T>(locations, null, token);
        }

        public void ReleaseBatch(IEnumerable<string> locations)
        {
            foreach (var location in locations) Release(location);
        }
    }
}```

<!-- File: Asaki/Unity/Services/Resources/Lookup/AsakiNullResDependencyLookup.cs -->
<!-- GUID: d6d82e8eeb1540e6bfb68e5eb868e5d7 -->
<!-- Size: 842 bytes -->
<!-- Modified: 2025-12-22 16:45:54 -->
```csharp
using Asaki.Core.Resources;
using System.Collections.Generic;

namespace Asaki.Unity.Services.Resources.Lookup
{
	/// <summary>
	/// [直通式依赖查询]
	/// 适用于 Resources 和 Addressables。
	/// 因为这两个系统内部会自动处理依赖加载，不需要 Resources 介入递归逻辑。
	/// </summary>
	public class AsakiNullResDependencyLookup : IAsakiResDependencyLookup
	{
		// 静态单例，避免重复分配
		public static readonly AsakiNullResDependencyLookup Instance = new AsakiNullResDependencyLookup();

		public IEnumerable<string> GetDependencies(string location)
		{
			// 返回 null，告诉 ResManager：“这个资源没有需要我在应用层手动管理的依赖，
			// 请直接调用 Strategy.LoadAssetInternalAsync，让底层去处理。”
			return null;
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Resources/Strategies/AsakiAddressablesStrategy.cs -->
<!-- GUID: 9fe87cc98a2c4de2b03db1d30a5e4aec -->
<!-- Size: 2010 bytes -->
<!-- Modified: 2025-12-22 16:58:46 -->
```csharp
#if ASAKI_USE_ADDRESSABLE

using Asaki.Core.Resources;
using Cysharp.Threading.Tasks;
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine.AddressableAssets;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Resources.Strategies
{
	public class AsakiAddressablesStrategy : IAsakiResStrategy
	{
		public string StrategyName => "Addressables";
		public async Task InitializeAsync()
		{
			#if ASAKI_USE_UNITASK
			await Addressables.InitializeAsync().ToUniTask();
			#else
			await Addressables.InitializeAsync().Task;
			#endif
		}
		public async Task<Object> LoadAssetInternalAsync(string location, Type type, Action<float> onProgress, CancellationToken token)
		{
			var handle = Addressables.LoadAssetAsync<Object>(location);

			try
			{
				// 1. 如果不需要进度，直接等待结果
				if (onProgress == null)
				{
					#if ASAKI_USE_UNITASK
					return await handle.ToUniTask(cancellationToken: token);
					#else
                    return await handle.Task; // 注意：这里最好也加 AsakiTaskExtensions.WaitAsync 处理取消
					#endif
				}

				// 2. 如果需要进度，手动轮询
				while (!handle.IsDone)
				{
					if (token.IsCancellationRequested) throw new OperationCanceledException(token);

					// Addressables 的 PercentComplete
					onProgress.Invoke(handle.PercentComplete);
                    
					await Task.Yield();
				}

				if (handle.Status == UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationStatus.Succeeded)
				{
					onProgress.Invoke(1f);
					return handle.Result;
				}
				else
				{
					throw handle.OperationException ?? new Exception($"Addressables load failed: {location}");
				}
			}
			catch (Exception)
			{
				if (handle.IsValid()) Addressables.Release(handle);
				throw;
			}
		}
		public void UnloadAssetInternal(string location, Object asset)
		{
			Addressables.Release(asset);
		}
	}
}
#endif
```

<!-- File: Asaki/Unity/Services/Resources/Strategies/AsakiResourcesStrategy.cs -->
<!-- GUID: 78097ac0353745129a61ab704cea1e5f -->
<!-- Size: 1496 bytes -->
<!-- Modified: 2025-12-22 16:58:46 -->
```csharp
using Asaki.Core.Resources;
using Asaki.Unity.Utils;
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Resources.Strategies
{
	public class AsakiResourcesStrategy : IAsakiResStrategy
	{

		public string StrategyName => "Resources (Native)";
		public Task InitializeAsync()
		{
			return Task.CompletedTask;
		}
		public async Task<Object> LoadAssetInternalAsync(string location, Type type, Action<float> onProgress, CancellationToken token)
		{
			var request = UnityEngine.Resources.LoadAsync(location, type);

			// 如果没有进度回调，直接使用之前的 Bridge
			if (onProgress == null)
			{
				return await request.ToTask(token);
			}

			// === 进度轮询模式 ===
			// 只要没完成，就每帧报告一次进度
			while (!request.isDone)
			{
				// 响应取消
				if (token.IsCancellationRequested)
				{
					// Resources.LoadAsync 无法真正取消底层 IO，但我们可以停止等待
					throw new OperationCanceledException(token);
				}

				// 报告进度
				onProgress.Invoke(request.progress);
                
				// 等待下一帧
				await Task.Yield();
			}

			// 完成
			onProgress.Invoke(1f);
			return request.asset;
		}
		public void UnloadAssetInternal(string location, Object asset)
		{
			if (asset is not GameObject)
				UnityEngine.Resources.UnloadAsset(asset);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Serialization/AsakiBinaryWriter.cs -->
<!-- GUID: f2dc7055f9714f1a8187c39f9fa71c63 -->
<!-- Size: 5589 bytes -->
<!-- Modified: 2025-12-22 16:46:33 -->
```csharp
using Asaki.Core.Serialization;
using System.IO;
using UnityEngine;

// 确保引用了你的数学库

namespace Asaki.Unity.Services.Serialization
{
	// ==================================================================================
	// 写入器：极速、紧凑、忽略 Key
	// ==================================================================================
	public class AsakiBinaryWriter : IAsakiWriter
	{
		private readonly BinaryWriter _bw;

		public AsakiBinaryWriter(Stream stream)
		{
			// LeaveOpen = true: 允许外部管理流的生命周期 (如 FileStream, MemoryStream)
			_bw = new BinaryWriter(stream, System.Text.Encoding.UTF8, true);
		}

		public void WriteVersion(int version) => _bw.Write((short)version);

		// --- 基础类型 ---
		public void WriteInt(string key, int value) => _bw.Write(value);
		public void WriteLong(string key, long value) => _bw.Write(value);
		public void WriteFloat(string key, float value) => _bw.Write(value);
		public void WriteDouble(string key, double value) => _bw.Write(value);
		public void WriteString(string key, string value) => _bw.Write(value ?? string.Empty);
		public void WriteBool(string key, bool value) => _bw.Write(value);
		public void WriteUInt(string key, uint value) => _bw.Write(value);
		public void WriteULong(string key, ulong value) => _bw.Write(value);
		

		// --- Asaki Math (直接打平写入，Zero GC) ---
		public void WriteVector2Int(string key, Vector2Int value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
		}
		public void WriteVector3Int(string key, Vector3Int value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
			_bw.Write(value.z);
		}
		

		public void WriteVector2(string key, Vector2 value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
		}
		public void WriteVector3(string key, Vector3 value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
			_bw.Write(value.z);
		}
		public void WriteVector4(string key, Vector4 value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
			_bw.Write(value.z);
			_bw.Write(value.w);
		}
		
		public void WriteQuaternion(string key, Quaternion value)
		{
			_bw.Write(value.x);
			_bw.Write(value.y);
			_bw.Write(value.z);
			_bw.Write(value.w);
		}

		public void WriteBounds(string key, Bounds value)
		{
			// 假设 AABB 包含 min 和 max 两个 float3
			WriteVector3(null, value.min);
			WriteVector3(null, value.max);
		}

		// --- 复杂对象 ---
		public void WriteObject<T>(string key, T value) where T : IAsakiSavable
		{
			// 写入 Null 标记位 (False = Null, True = Not Null)
			if (value == null)
			{
				_bw.Write(false);
				return;
			}
			_bw.Write(true);
			value.Serialize(this); // 递归调用
		}

		// --- 集合与结构控制 ---
		public void BeginList(string key, int count) => _bw.Write(count); // 只写数量
		public void EndList() { }                                         // 二进制不需要结束符

		public void BeginObject(string key) { } // 二进制不需要结构标记
		public void EndObject() { }
	}

	// ==================================================================================
	// 读取器：顺序读取、对象复用
	// ==================================================================================
	public class AsakiBinaryReader : IAsakiReader
	{
		private readonly BinaryReader _br;

		public AsakiBinaryReader(Stream stream)
		{
			_br = new BinaryReader(stream, System.Text.Encoding.UTF8, true);
		}

		public int ReadVersion() => _br.ReadInt16();

		// --- 基础类型 ---
		public int ReadInt(string key) => _br.ReadInt32();
		public long ReadLong(string key) => _br.ReadInt64();
		public float ReadFloat(string key) => _br.ReadSingle();
		public double ReadDouble(string key) => _br.ReadDouble();
		public string ReadString(string key) => _br.ReadString();
		public bool ReadBool(string key) => _br.ReadBoolean();
		public uint ReadUInt(string key) => _br.ReadUInt32();
		public ulong ReadULong(string key) => _br.ReadUInt64();

		// --- Asaki Math ---
		public Vector2Int ReadVector2Int(string key) => new Vector2Int(_br.ReadInt32(), _br.ReadInt32());
		public Vector3Int ReadVector3Int(string key) => new Vector3Int(_br.ReadInt32(), _br.ReadInt32(), _br.ReadInt32());

		public Vector2 ReadVector2(string key) => new Vector2(_br.ReadSingle(), _br.ReadSingle());
		public Vector3 ReadVector3(string key) => new Vector3(_br.ReadSingle(), _br.ReadSingle(), _br.ReadSingle());
		public Vector4 ReadVector4(string key) => new Vector4(_br.ReadSingle(), _br.ReadSingle(), _br.ReadSingle(), _br.ReadSingle());

		public Quaternion ReadQuaternion(string key) => new Quaternion(_br.ReadSingle(), _br.ReadSingle(), _br.ReadSingle(), _br.ReadSingle());

		public Bounds ReadBounds(string key)
		{
			// 顺序必须与 Write 一致
			var min = ReadVector3(null);
			var max = ReadVector3(null);
			return new Bounds(min, max);
		}

		// --- 复杂对象 ---
		public T ReadObject<T>(string key, T existingObj = default) where T : IAsakiSavable, new()
		{
			// 1. 检查 Null 标记
			bool isNotNull = _br.ReadBoolean();
			if (!isNotNull) return default;

			// 2. 实例复用 (Zero GC 关键)
			T instance = existingObj;
			if (instance == null) instance = new T();

			// 3. 填充数据
			instance.Deserialize(this);
			return instance;
		}

		// --- 集合控制 ---
		public int BeginList(string key) => _br.ReadInt32(); // 读取数量
		public void EndList() { }
	}
}
```

<!-- File: Asaki/Unity/Services/Serialization/AsakiJsonWriter.cs -->
<!-- GUID: 1c80b327fda24efbab77cda5a0ce259b -->
<!-- Size: 6204 bytes -->
<!-- Modified: 2025-12-22 16:46:33 -->
```csharp
using Asaki.Core.Serialization;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Asaki.Unity.Services.Serialization
{
	/// <summary>
	/// 调试专用 JSON 写入器
	/// 特性：格式化输出 (Pretty Print)，方便人工查阅
	/// 注意：性能不如 BinaryWriter，建议仅在 Editor 模式或 Debug 版本使用
	/// </summary>
	public class AsakiJsonWriter : IAsakiWriter
	{
		private readonly StringBuilder _sb;
		private int _indent;

		// 状态栈：用于跟踪当前容器是否包含元素（控制逗号逻辑）
		private readonly Stack<ContainerContext> _contextStack = new Stack<ContainerContext>();

		private class ContainerContext
		{
			public bool IsArray;
			public bool HasWrittenFirstElement;
		}

		public AsakiJsonWriter(StringBuilder sb)
		{
			_sb = sb;
			_sb.AppendLine("{"); // 根对象开始
			_indent++;
			PushContext(false); // 根总是 Object
		}

		public string GetResult()
		{
			// 补全根对象的结束符 (如果尚未关闭)
			while (_indent > 0)
			{
				_indent--;
				_sb.AppendLine("\n}");
			}
			return _sb.ToString();
		}

		// =========================================================
		// 核心辅助逻辑：逗号与缩进
		// =========================================================
		private void WritePrefix(string key)
		{
			var ctx = _contextStack.Peek();

			// 如果不是第一个元素，先补上前一个元素的逗号
			if (ctx.HasWrittenFirstElement)
			{
				_sb.AppendLine(",");
			}
			ctx.HasWrittenFirstElement = true;

			// 写入缩进
			_sb.Append(' ', _indent * 4);

			// 写入 Key (如果是 Object)
			if (!ctx.IsArray)
			{
				_sb.Append($"\"{key}\": ");
			}
		}

		private void PushContext(bool isArray)
		{
			_contextStack.Push(new ContainerContext { IsArray = isArray });
		}

		private void PopContext()
		{
			_contextStack.Pop();
		}

		// =========================================================
		// 接口实现
		// =========================================================

		public void WriteVersion(int version) => WriteInt("version", version);

		// --- 基础类型 ---
		public void WriteInt(string key, int value)
		{
			WritePrefix(key);
			_sb.Append(value);
		}

		public void WriteLong(string key, long value)
		{
			WritePrefix(key);
			_sb.Append(value);
		}

		public void WriteFloat(string key, float value)
		{
			WritePrefix(key);
			_sb.Append(value.ToString("F3")); // 保留3位小数，避免 float 精度噪音
		}

		public void WriteDouble(string key, double value)
		{
			WritePrefix(key);
			_sb.Append(value.ToString("F4"));
		}

		public void WriteString(string key, string value)
		{
			WritePrefix(key);
			// 简单转义：处理引号和换行 (生产环境建议用更严谨的转义)
			string escaped = value?.Replace("\"", "\\\"").Replace("\n", "\\n") ?? "";
			_sb.Append($"\"{escaped}\"");
		}

		public void WriteBool(string key, bool value)
		{
			WritePrefix(key);
			_sb.Append(value ? "true" : "false");
		}

		public void WriteUInt(string key, uint value) => WriteLong(key, value);
		public void WriteULong(string key, ulong value) => WriteString(key, value.ToString()); // JS/JSON 不支持大整数，存字符串安全

		// --- Math 类型 (展开为内联对象或数组) ---
		// 策略：为了可读性，Math 类型写成紧凑的 Object，如 { "x": 1, "y": 2 }

		public void WriteVector2Int(string key, Vector2Int value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x}, \"y\": {value.y} }}");
		}

		public void WriteVector3Int(string key, Vector3Int value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x}, \"y\": {value.y}, \"z\": {value.z} }}");
		}
		public void WriteVector2(string key, Vector2 value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x:F2}, \"y\": {value.y:F2} }}");
		}
		public void WriteVector3(string key, Vector3 value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x:F2}, \"y\": {value.y:F2}, \"z\": {value.z:F2} }}");
		}
		public void WriteVector4(string key, Vector4 value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x:F2}, \"y\": {value.y:F2}, \"z\": {value.z:F2}, \"w\": {value.w:F2} }}");
		}

		public void WriteQuaternion(string key, Quaternion value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"x\": {value.x:F2}, \"y\": {value.y:F2}, \"z\": {value.z:F2}, \"w\": {value.w:F2} }}");
		}


		public void WriteBounds(string key, Bounds value)
		{
			WritePrefix(key);
			_sb.Append($"{{ \"center\": {{" +
			           $"\"{value.center.x:F2}\", " +
			           $"\"{value.center.y:F2}\", " +
			           $"\"{value.center.z:F2}\"}}" +
			           $"\"size\": {{" +
			           $"\"{value.size.x:F2}\", " +
			           $"\"{value.size.y:F2}\", " +
			           $"\"{value.size.z:F2}\"}}");
		}
		// --- 结构控制 ---

		public void BeginObject(string key)
		{
			WritePrefix(key);
			_sb.AppendLine("{");
			_indent++;
			PushContext(false);
		}

		public void EndObject()
		{
			_indent--;
			PopContext();
			_sb.AppendLine();
			_sb.Append(' ', _indent * 4);
			_sb.Append("}");
		}

		public void BeginList(string key, int count)
		{
			WritePrefix(key);
			_sb.AppendLine("[");
			_indent++;
			PushContext(true);
		}

		public void EndList()
		{
			_indent--;
			PopContext();
			_sb.AppendLine();
			_sb.Append(' ', _indent * 4);
			_sb.Append("]");
		}

		// --- 递归对象 ---
		public void WriteObject<T>(string key, T value) where T : IAsakiSavable
		{
			if (value == null)
			{
				WritePrefix(key);
				_sb.Append("null");
				return;
			}

			// 对于 Object，我们利用它的 Serialize 方法
			// 但需要在外部包裹一层 BeginObject/EndObject 逻辑
			// 除非该 Object 内部自己处理了结构 (通常 Serialize 只负责写内容)

			// 修正策略：AsakiSavable.Serialize 通常只写内容。
			// JSON 需要大括号包裹。

			BeginObject(key);
			value.Serialize(this);
			EndObject();
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Serialization/AsakiSaveService.cs -->
<!-- GUID: 05f894c357b74c509dd317c76b05d0da -->
<!-- Size: 6555 bytes -->
<!-- Modified: 2025-12-23 19:37:42 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Serialization;
using Asaki.Unity.Utils;
using Cysharp.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using AsakiBroker = Asaki.Core.Broker.AsakiBroker;

namespace Asaki.Unity.Services.Serialization
{
    public class AsakiSaveService : IAsakiSaveService
    {
        private string _rootPath;
        private bool _isDebug;
        private IAsakiEventService _eventService;
        public AsakiSaveService(IAsakiEventService eventService)
        {
            _eventService = eventService;
        }

        public void OnInit()
        {
            _rootPath = Path.Combine(Application.persistentDataPath, "Saves");
            _isDebug = Application.isEditor || Debug.isDebugBuild;
            if (!Directory.Exists(_rootPath)) Directory.CreateDirectory(_rootPath);
        }

        public Task OnInitAsync() => Task.CompletedTask;
        public void OnDispose() { }

        // =========================================================
        // 路径策略 (Encapsulation)
        // =========================================================
        private string GetSlotDir(int id) => Path.Combine(_rootPath, $"Slot_{id}");
        private string GetDataPath(int id) => Path.Combine(GetSlotDir(id), "data.bin");
        private string GetMetaPath(int id) => Path.Combine(GetSlotDir(id), "meta.json");

        // =========================================================
        // 核心 Slot 逻辑
        // =========================================================

        public async Task SaveSlotAsync<TMeta, TData>(int slotId, TMeta meta, TData data) 
            where TMeta : IAsakiSlotMeta where TData : IAsakiSavable
        {
            string dir = GetSlotDir(slotId);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);

            // 自动填充基础元数据
            meta.SlotId = slotId;
            meta.LastSaveTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

            _eventService.Publish(new AsakiSaveBeginEvent { Filename = $"Slot_{slotId}" });

            try
            {
                // Step 1: [主线程] 内存快照 (Snapshot)
                // 必须在主线程执行 Serialize，防止访问 UnityEngine 对象或数据在写入时被逻辑修改
                byte[] dataBuffer;
                using (var ms = new MemoryStream())
                {
                    var writer = new AsakiBinaryWriter(ms);
                    data.Serialize(writer);
                    dataBuffer = ms.ToArray();
                }

                // Step 2: [后台线程] 异步 IO
#if ASAKI_USE_UNITASK
                await UniTask.SwitchToThreadPool();
#endif
                await File.WriteAllBytesAsync(GetDataPath(slotId), dataBuffer);

                // Meta 数据的持久化 (JSON 方便外部查阅)
                if (_isDebug)
                {
                    // 复用 AsakiStringBuilderPool 减少 GC
                    var sb = AsakiStringBuilderPool.Rent();
                    try {
                        var jsonWriter = new AsakiJsonWriter(sb);
                        meta.Serialize(jsonWriter);
                        await File.WriteAllTextAsync(GetMetaPath(slotId), jsonWriter.GetResult());
                    } finally {
                        AsakiStringBuilderPool.Return(sb);
                    }
                }

#if ASAKI_USE_UNITASK
                await UniTask.SwitchToMainThread();
#endif
                _eventService.Publish(new AsakiSaveSuccessEvent { Filename = $"Slot_{slotId}" });
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AsakiSave] Slot {slotId} Save Failed: {ex.Message}");
                _eventService.Publish(new AsakiSaveFailedEvent { Filename = $"Slot_{slotId}", ErrorMessage = ex.Message });
                throw;
            }
        }

        public async Task<(TMeta Meta, TData Data)> LoadSlotAsync<TMeta, TData>(int slotId) 
            where TMeta : IAsakiSlotMeta, new() where TData : IAsakiSavable, new()
        {
            if (!SlotExists(slotId)) throw new FileNotFoundException($"Slot {slotId} not found.");

            try
            {
                // Step 1: [后台线程] 并行读取二进制和元数据
#if ASAKI_USE_UNITASK
                await UniTask.SwitchToThreadPool();
#endif
                byte[] dataBuffer = await File.ReadAllBytesAsync(GetDataPath(slotId));
                string metaJson = await File.ReadAllTextAsync(GetMetaPath(slotId));

#if ASAKI_USE_UNITASK
                await UniTask.SwitchToMainThread();
#endif
                // Step 2: [主线程] 反序列化并触发 UI 绑定
                var data = new TData();
                using (var ms = new MemoryStream(dataBuffer))
                {
                    var reader = new AsakiBinaryReader(ms);
                    data.Deserialize(reader);
                }

                // Meta 加载 (此处示例简化，实际应使用 AsakiJsonReader)
                var meta = new TMeta();
                // 暂时使用简单逻辑或 JsonReader 实现...
                
                return (meta, data);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AsakiSave] Slot {slotId} Load Failed: {ex.Message}");
                throw;
            }
        }

        // =========================================================
        // Slot 管理工具
        // =========================================================

        public List<int> GetUsedSlots()
        {
            if (!Directory.Exists(_rootPath)) return new List<int>();
            return Directory.GetDirectories(_rootPath, "Slot_*")
                .Select(d => Path.GetFileName(d).Replace("Slot_", ""))
                .Where(s => int.TryParse(s, out _))
                .Select(int.Parse)
                .ToList();
        }

        public bool SlotExists(int slotId) => File.Exists(GetDataPath(slotId));

        public bool DeleteSlot(int slotId)
        {
            string dir = GetSlotDir(slotId);
            if (Directory.Exists(dir))
            {
                Directory.Delete(dir, true);
                return true;
            }
            return false;
        }
    }
}```

<!-- File: Asaki/Unity/Services/UI/AsakiUIManager.cs -->
<!-- GUID: aaf5d7b61fe24bd2be041cf7097e9e11 -->
<!-- Size: 8589 bytes -->
<!-- Modified: 2025-12-23 23:36:43 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Context;
using Asaki.Core.Pooling;
using Asaki.Core.Resources;
using Asaki.Core.Simulation;
using Asaki.Core.UI;
using Asaki.Unity.Configuration;
using Asaki.Unity.Extensions;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.UI
{
	public class AsakiUIManager : IAsakiUIService, IAsakiTickable
	{
		private AsakiUIRoot _asakiUIRoot;
		private IAsakiResService _resService;
		private IAsakiPoolService _poolService;
		private IAsakiEventService _eventService;
		private AsakiSimulationManager _asakiSimulationManager;
		private AsakiUIConfig _uiConfig;
		private readonly Vector2 _refRes;
		private readonly float _matchMode;

		// 窗口栈 (Normal层)
		private Stack<IAsakiWindow> _normalStack = new Stack<IAsakiWindow>();

		// [新增] Popup层计数器 (用于判断是否需要恢复 Normal 层输入)
		private int _activePopupCount = 0;

		// [新增] 窗口实例到层级的映射缓存 (避免 Close 时无法获知层级)
		private readonly Dictionary<IAsakiWindow, AsakiUILayer> _windowLayerMap = new Dictionary<IAsakiWindow, AsakiUILayer>();

		private readonly HashSet<string> _pooledAssets = new HashSet<string>();
		
		// 线程安全的销毁队列
		private readonly ConcurrentQueue<IAsakiWindow> _pendingDestroyQueue = new ConcurrentQueue<IAsakiWindow>();

		public AsakiUIManager(AsakiUIConfig configAsset, Vector2 refRes, float matchMode, IAsakiEventService eventService, IAsakiResService resService, IAsakiPoolService poolService)
		{
			_uiConfig = configAsset;
			_refRes = refRes;
			_matchMode = matchMode;
			_eventService = eventService;
			_resService = resService;
			_poolService = poolService;
		}

		public void OnInit()
		{
			_asakiSimulationManager = AsakiContext.Get<AsakiSimulationManager>();
			_asakiSimulationManager.Register(this);

			if (_asakiUIRoot == null)
			{
				var rootGo = new GameObject("Asaki_UIRoot");
				Object.DontDestroyOnLoad(rootGo);
				_asakiUIRoot = rootGo.AddComponent<AsakiUIRoot>();
				_asakiUIRoot.Initialize(_refRes, _matchMode);
			}
		}

		public Task OnInitAsync()
		{
			if (_uiConfig != null)
			{
				_uiConfig.InitializeLookup();
			}
			else
			{
				Debug.LogWarning("[AsakiUI] No UIConfig assigned in AsakiConfig!");
			}
			return Task.CompletedTask;
		}

		public async Task<T> OpenAsync<T>(int uiId, object args = null, CancellationToken token = default)
			where T : class, IAsakiWindow
		{
			// 基础检查
			if (token.IsCancellationRequested) return null;

			if (_uiConfig == null || !_uiConfig.TryGet(uiId, out UIInfo info))
			{
				Debug.LogError($"[AsakiUI] UIID {uiId} not found.");
				return null;
			}

			ResHandle<GameObject> rawHandle = null;
			GameObject instance = null;
			T window;

			try
			{
				Transform parent = _asakiUIRoot.GetLayerNode(info.Layer);

				// === V5.1 池化分支 ===
				if (info.UsePool)
				{
					// [Step 1] 异步预热
					await _poolService.PrewarmAsync(info.AssetPath, 1);
					if (token.IsCancellationRequested) return null;

					// [Step 2] 同步生成
					instance = _poolService.Spawn(info.AssetPath, Vector3.zero, Quaternion.identity, parent);
					_pooledAssets.Add(info.AssetPath);

					window = instance.GetComponent<T>();
					if (window is AsakiUIWindow baseWindow)
					{
						baseWindow.IsPooled = true;
						baseWindow.PoolKey = info.AssetPath;
						baseWindow.ResHandle = null;
					}
				}
				// === V5.1 普通分支 ===
				else
				{
					// [Step 1] 异步加载
					rawHandle = await _resService.LoadAsync<GameObject>(info.AssetPath, token);
					if (!rawHandle.IsValid) return null;
					if (token.IsCancellationRequested)
					{
						rawHandle.Dispose();
						return null;
					}

					// [Step 2] 实例化
					instance = Object.Instantiate(rawHandle.Asset, parent);
					window = instance.GetComponent<T>();
					if (window is AsakiUIWindow baseWindow)
					{
						baseWindow.IsPooled = false;
						baseWindow.ResHandle = new AsakiUIResourceHandleAdapter(rawHandle);
						rawHandle = null;
					}
				}

				if (window == null) throw new Exception($"Window component missing on {instance.name}");

				// [新增] 记录窗口层级，便于 Close 时处理逻辑
				_windowLayerMap[window] = info.Layer;

				// === [核心优化] 输入屏蔽逻辑 ===
				// 如果打开的是 Popup，物理屏蔽 Normal 层的输入
				if (info.Layer == AsakiUILayer.Popup)
				{
					_activePopupCount++;
					if (_activePopupCount == 1) // 只要有一个 Popup 存在，就屏蔽下层
					{
						_asakiUIRoot.SetLayerRaycast(AsakiUILayer.Normal, false);
					}
				}

				await window.OnOpenAsync(args, token);

				// 栈管理 (仅 Normal 层入栈)
				if (info.Layer == AsakiUILayer.Normal)
				{
					if (_normalStack.Count > 0) _normalStack.Peek().OnCover();
					_normalStack.Push(window);
				}

				return window;
			}
			catch (Exception e)
			{
				// 异常回滚
				if (instance != null)
				{
					if (info.UsePool) _poolService.Despawn(instance, info.AssetPath);
					else Object.Destroy(instance);
				}
				rawHandle?.Dispose();

				Debug.LogError($"[AsakiUI] OpenUI Failed: {e}");
				return null;
			}
		}

		// [修改] 泛型关闭接口
		public void Close<T>() where T : IAsakiWindow
		{
			if (_normalStack.Count > 0 && _normalStack.Peek() is T)
			{
				Close(_normalStack.Peek());
				return;
			}

			var target = _normalStack.FirstOrDefault(w => w is T);
			if (target != null)
			{
				Close(target);
			}
			else
			{
				Debug.LogWarning($"[AsakiUI] Window {typeof(T).Name} not found in stack.");
			}
		}

		// [修改] 线程安全的关闭入口
		public void Close(IAsakiWindow window)
		{
			if (window == null) return;
			_pendingDestroyQueue.Enqueue(window);
		}

		public void Back()
		{
			if (_normalStack.Count > 0)
			{
				Close(_normalStack.Peek());
			}
		}

		// [新增] 心跳驱动，处理销毁列表
		public void Tick(float deltaTime)
		{
			while (_pendingDestroyQueue.TryDequeue(out var window))
			{
				ProcessCloseRequest(window);
			}
		}

		// [修改] 实际的主线程关闭逻辑
		private void ProcessCloseRequest(IAsakiWindow window)
		{
			// 1. 栈状态维护
			if (_normalStack.Count > 0 && _normalStack.Peek() == window)
			{
				_normalStack.Pop();
				if (_normalStack.Count > 0) _normalStack.Peek().OnReveal();
			}
			else if (_normalStack.Contains(window))
			{
				RemoveWindowFromStackMiddle(window);
			}

			// 2. === [核心优化] 恢复输入逻辑 ===
			if (_windowLayerMap.TryGetValue(window, out var layer))
			{
				if (layer == AsakiUILayer.Popup)
				{
					_activePopupCount--;
					if (_activePopupCount <= 0)
					{
						_activePopupCount = 0; // 防御性归零
						// 如果没有 Popup 了，恢复 Normal 层输入
						_asakiUIRoot.SetLayerRaycast(AsakiUILayer.Normal, true);
					}
				}
				_windowLayerMap.Remove(window); // 清理映射
			}

			// 3. 执行关闭
			HandleCloseAsync(window).FireAndForget();
		}

		private void RemoveWindowFromStackMiddle(IAsakiWindow target)
		{
			var temp = new Stack<IAsakiWindow>();
			while (_normalStack.Count > 0)
			{
				var cur = _normalStack.Pop();
				if (cur == target) break; // 找到并丢弃
				temp.Push(cur);
			}
			while (temp.Count > 0) _normalStack.Push(temp.Pop());
		}

		private async Task HandleCloseAsync(IAsakiWindow window)
		{
			// Window 内部处理回收/销毁
			await window.OnCloseAsync(CancellationToken.None);
		}

		public void OnDispose()
		{
			// 1. 关闭所有窗口
			while (_normalStack.Count > 0)
			{
				HandleCloseAsync(_normalStack.Pop()).FireAndForget();
			}
			_normalStack.Clear();

			// 2. 释放池
			if (_poolService != null)
			{
				foreach (var assetPath in _pooledAssets)
				{
					_poolService.ReleasePool(assetPath);
				}
			}
			_pooledAssets.Clear();
			_windowLayerMap.Clear();

			// 3. 注销 Tick
			if (_asakiSimulationManager != null)
			{
				_asakiSimulationManager.Unregister(this);
			}

			// 4. 销毁 Root
			if (_asakiUIRoot != null)
			{
				Object.Destroy(_asakiUIRoot.gameObject);
				_asakiUIRoot = null;
			}
		}
	}
}```

<!-- File: Asaki/Unity/Services/UI/AsakiUIRoot.cs -->
<!-- GUID: e3b36c7dbe734f9c838ca156e400bdcd -->
<!-- Size: 5052 bytes -->
<!-- Modified: 2025-12-23 23:35:51 -->
```csharp
using Asaki.Core.UI;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Asaki.Unity.Services.UI
{
    public class AsakiUIRoot : MonoBehaviour
    {
        // 存储层级节点
        private readonly Dictionary<AsakiUILayer, Transform> _layers = new Dictionary<AsakiUILayer, Transform>();
        
        // [新增] 存储各层的 Raycaster，用于物理屏蔽优化
        private readonly Dictionary<AsakiUILayer, GraphicRaycaster> _layerRaycasters = new Dictionary<AsakiUILayer, GraphicRaycaster>();

        private Vector2 _referenceResolution;
        private float _matchWidthOrHeight;

        /// <summary>
        /// 初始化 UI 根节点结构
        /// </summary>
        public void Initialize(Vector2 referenceResolution, float matchWidthOrHeight)
        {
            _referenceResolution = referenceResolution;
            _matchWidthOrHeight = matchWidthOrHeight;

            // 1. 确保 EventSystem (兼容新旧输入系统)
            EnsureEventSystem();
            
            // 2. 清理残留子节点 (防止热重载或重复初始化导致的重叠)
            foreach (Transform child in transform) Destroy(child.gameObject);
            _layers.Clear();
            _layerRaycasters.Clear();

            // 3. [核心优化] 创建分离的 Canvas 层级
            // Order 间隔 1000，确保层级绝对分离且中间有足够的空间插入动态层(如果有)
            CreateLayerNode("0_Scene", AsakiUILayer.Scene, 0);       // 0-999
            CreateLayerNode("1_Normal", AsakiUILayer.Normal, 1000);  // 1000-1999
            CreateLayerNode("2_Popup", AsakiUILayer.Popup, 2000);    // 2000-2999
            CreateLayerNode("3_System", AsakiUILayer.System, 3000);  // 3000+

            DontDestroyOnLoad(gameObject);
        }

        private void CreateLayerNode(string goName, AsakiUILayer layer, int sortOrder)
        {
            GameObject go = new GameObject(goName);
            go.transform.SetParent(transform, false);
            
            // [A] 独立的 Canvas
            // 优势：层级间互不干扰，Popup 层的 Rebuild 不会波及 Normal 层
            Canvas c = go.AddComponent<Canvas>();
            c.renderMode = RenderMode.ScreenSpaceOverlay;
            c.overrideSorting = true; // 开启独立排序
            c.sortingOrder = sortOrder;
            
            // [B] 独立的 Scaler
            // 必须每个 Canvas 都挂 Scaler，否则无法正确适配屏幕
            CanvasScaler s = go.AddComponent<CanvasScaler>();
            s.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            s.referenceResolution = _referenceResolution;
            s.matchWidthOrHeight = _matchWidthOrHeight;

            // [C] 独立的 Raycaster
            GraphicRaycaster r = go.AddComponent<GraphicRaycaster>();
            _layerRaycasters[layer] = r;

            // [D] 统一的 CanvasGroup
            // 用于实现层级整体淡入淡出 (例如：打开 System 菜单时，Normal 层整体变暗)
            CanvasGroup group = go.AddComponent<CanvasGroup>();
            // 默认设置
            group.alpha = 1f;
            group.ignoreParentGroups = false;

            _layers[layer] = go.transform;
        }

        /// <summary>
        /// 获取层级节点
        /// </summary>
        public Transform GetLayerNode(AsakiUILayer layer)
        {
            return _layers.TryGetValue(layer, out var node) ? node : transform;
        }

        /// <summary>
        /// [性能优化接口] 控制某一层是否接收输入
        /// <para>场景：打开全屏 Popup 时，调用 SetLayerRaycast(Normal, false) 物理屏蔽下层点击</para>
        /// </summary>
        public void SetLayerRaycast(AsakiUILayer layer, bool enable)
        {
            if (_layerRaycasters.TryGetValue(layer, out var raycaster))
            {
                if (raycaster.enabled != enable)
                    raycaster.enabled = enable;
            }
        }

        /// <summary>
        /// 确保场景中存在 EventSystem
        /// </summary>
        private void EnsureEventSystem()
        {
            if (FindFirstObjectByType<EventSystem>()) return;

            GameObject eventSystemGo = new GameObject("Asaki_EventSystem");
            Object.DontDestroyOnLoad(eventSystemGo);
            eventSystemGo.AddComponent<EventSystem>();

            // [兼容性处理] 
#if ENABLE_INPUT_SYSTEM
            // 如果你使用了 New Input System 且安装了 InputSystem 包，Unity 会自动处理或提示添加组件。
            // 这里为了最广泛的兼容性，默认添加 Standalone，New Input System 会提示 Replace。
            eventSystemGo.AddComponent<StandaloneInputModule>(); 
#else
            eventSystemGo.AddComponent<StandaloneInputModule>();
#endif
        }
    }
}```

<!-- File: Asaki/Unity/Services/UI/AsakiUIWindow.cs -->
<!-- GUID: 250bdb5c6ef9432a803ec50601607a22 -->
<!-- Size: 6835 bytes -->
<!-- Modified: 2025-12-23 23:20:19 -->
```csharp
using Asaki.Core.Context; // [新增] 用于获取服务
using Asaki.Core.Pooling;
using Asaki.Core.UI;
using Asaki.Unity.Extensions;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

// [移除] 旧的静态引用
// using AsakiSmartPool = Asaki.Core.Pooling.AsakiSmartPool;

namespace Asaki.Unity.Services.UI
{
    [RequireComponent(typeof(CanvasGroup))]
    public abstract class AsakiUIWindow : MonoBehaviour, IAsakiWindow, IAsakiPoolable
    {
        [Header("Focus Management")]
        [SerializeField] 
        private Selectable _firstFocusObject;
        private GameObject _previousFocus;
        // 持有抽象句柄 (非池化模式下使用)
        public IUIResourceHandle ResHandle { get; set; }
        
        public CanvasGroup CanvasGroup { get; private set; }

        public string PoolKey { get; set; }
        
        // 标记是否是池化对象 (由 UIManager 在 Spawn 后赋值)
        public bool IsPooled { get; set; }
        
        protected virtual void Awake()
        {
            CanvasGroup = GetComponent<CanvasGroup>();
        }

        // ====================================================
        // IAsakiPoolable 生命周期
        // ====================================================

        public virtual void OnSpawn()
        {
            // [Pooling] 取出时重置基础状态
            if (CanvasGroup != null)
            {
                CanvasGroup.alpha = 1;
                CanvasGroup.blocksRaycasts = true;
            }
            this.gameObject.SetActive(true);
        }

        public virtual void OnDespawn()
        {
            // [Pooling] 回收时逻辑
            this.gameObject.SetActive(false);
            
            // 注意：不要在这里 Dispose ResHandle。
            // 如果是池化对象，ResHandle 由 PoolService/UIManager 持有。
            // 如果是非池化对象，Destroy 时会由 CloseInternal 处理。
        }

        // ====================================================
        // 核心流程控制 (Template Method)
        // ====================================================

        public async Task OnOpenAsync(object args, CancellationToken token)
        {
            
            if (EventSystem.current != null)
            {
                _previousFocus = EventSystem.current.currentSelectedGameObject;
            }
            // 1. 基础状态设置
            gameObject.SetActive(true);
            // 暂时阻挡交互，防止动画过程中误触
            if (CanvasGroup != null) CanvasGroup.blocksRaycasts = false; 

            // 2. [同步] 业务逻辑回调 (刷新数据)
            OnRefresh(args); 

            // 3. [异步] 入场动画
            await PlayEntryAnimation(token);

            // 4. 动画结束，开启交互
            if (CanvasGroup != null)
            {
                CanvasGroup.alpha = 1;
                CanvasGroup.blocksRaycasts = true;
            }
            
            if (_firstFocusObject != null && EventSystem.current != null)
            {
                // 清除当前选择，防止 UGUI 状态残留
                EventSystem.current.SetSelectedGameObject(null);
                EventSystem.current.SetSelectedGameObject(_firstFocusObject.gameObject);
            }
        }

        public async Task OnCloseAsync(CancellationToken token)
        {
            // 禁止交互
            if (CanvasGroup != null) CanvasGroup.blocksRaycasts = false;
            
            if (EventSystem.current != null && _previousFocus != null)
            {
                // 简单的有效性检查：上一个对象还在场景里且激活
                if (_previousFocus.activeInHierarchy)
                {
                    EventSystem.current.SetSelectedGameObject(_previousFocus);
                }
            }
            _previousFocus = null; // 清理引用
            
            // 1. [异步] 离场动画
            await PlayExitAnimation(token);

            // 2. 销毁/回收逻辑
            CloseInternal();
        }

        // ====================================================
        // 子类扩展点
        // ====================================================

        protected virtual void OnRefresh(object args) { }

        protected virtual Task PlayEntryAnimation(CancellationToken token)
        {
            return Task.CompletedTask;
        }

        protected virtual Task PlayExitAnimation(CancellationToken token)
        {
            return Task.CompletedTask;
        }

        // ====================================================
        // 内部逻辑与辅助
        // ====================================================
        
        // 提供给 Button Click Event 的同步入口
        public void Close()
        {
            HandleCloseAsync().FireAndForget();
        }
        
        private async Task HandleCloseAsync()
        {
             // 确保 Close 也走完整的动画流程
             await OnCloseAsync(CancellationToken.None);
        }

        private void CloseInternal()
        {
            if (IsPooled && !string.IsNullOrEmpty(PoolKey))
            {
                // [分支 A: 池化对象] -> 归还进池子
                
                // V5.1 最佳实践：通过 Context 获取服务实例
                if (AsakiContext.TryGet<IAsakiPoolService>(out var poolService))
                {
                    poolService.Despawn(this.gameObject, PoolKey);
                }
                else
                {
                    // 极端情况：服务已销毁 (比如游戏退出时)，直接销毁物体
                    Destroy(this.gameObject);
                }
            }
            else
            {
                // [分支 B: 普通对象] -> 销毁
                
                // 1. 释放句柄 (RefCount -1)
                ResHandle?.Dispose(); 
                ResHandle = null;
                
                // 2. 销毁 GameObject
                Destroy(this.gameObject); 
            }
        }

        // 栈管理行为：被覆盖时
        public virtual void OnCover() 
        {
            if (CanvasGroup != null) CanvasGroup.blocksRaycasts = false;
        }
        
        // 栈管理行为：恢复显示时
        public virtual void OnReveal()
        {
            if (CanvasGroup)
            {
                CanvasGroup.blocksRaycasts = true;
                gameObject.SetActive(true);
            }
        }
    }
}```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiActiveObserver.cs -->
<!-- GUID: 7de1f0354d8545b9994e29e5c3cd52cf -->
<!-- Size: 732 bytes -->
<!-- Modified: 2025-12-22 16:47:30 -->
```csharp
using Asaki.Core.MVVM;
using UnityEngine;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiActiveObserver : IAsakiObserver<bool>
	{
		private readonly GameObject _target;
		// 可选：是否反转逻辑 (如 IsDead -> ShowGameOver, 此时不需要反转；IsAlive -> HideGrave，需要反转)
		private readonly bool _invert; 

		public AsakiActiveObserver(GameObject target, bool invert = false)
		{
			_target = target;
			_invert = invert;
		}

		public void OnValueChange(bool value)
		{
			if (_target == null) return;
			bool activeState = _invert ? !value : value;
            
			if (_target.activeSelf != activeState)
			{
				_target.SetActive(activeState);
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiInputFieldObserver.cs -->
<!-- GUID: 459bd829bd6c4b979f3b7421371d5d1b -->
<!-- Size: 463 bytes -->
<!-- Modified: 2025-12-22 16:47:30 -->
```csharp
using Asaki.Core.MVVM;
using TMPro;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiInputFieldObserver : IAsakiObserver<string>
	{
		private readonly TMP_InputField _input;

		public AsakiInputFieldObserver(TMP_InputField input)
		{
			_input = input;
		}

		public void OnValueChange(string value)
		{
			if (_input == null) return;
			
			if (_input.text != value)
			{
				_input.text = value ?? "";
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiInteractableObserver.cs -->
<!-- GUID: 3f491276085c4c5d9bb6762fb2a80ea2 -->
<!-- Size: 536 bytes -->
<!-- Modified: 2025-12-22 16:47:30 -->
```csharp
using Asaki.Core.MVVM;
using UnityEngine.UI;

namespace Asaki.Unity.Services.UI.Observers
{

	public class AsakiInteractableObserver : IAsakiObserver<bool>
	{
		private readonly Selectable _selectable; // Button, Toggle, Slider 都是 Selectable

		public AsakiInteractableObserver(Selectable selectable)
		{
			_selectable = selectable;
		}

		public void OnValueChange(bool value)
		{
			if (_selectable != null && _selectable.interactable != value)
			{
				_selectable.interactable = value;
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiIntTextObserver.cs -->
<!-- GUID: 1eac169ffa9b49739614da3ca3dd722f -->
<!-- Size: 1625 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Unity.Utils;
using UnityEngine.UI;

// 如果使用 TextMeshPro，请引用 TMPro

namespace Asaki.Unity.Services.UI.Observers
{
	/// <summary>
	/// [性能组件] 专门用于将 int 属性绑定到 Text 组件。
	/// 避免了 "Prefix" + value + "Suffix" 拼接产生的垃圾。
	/// </summary>
	public class AsakiIntTextObserver : IAsakiObserver<int>
	{
		private readonly Text _targetText;
		private readonly string _prefix;
		private readonly string _suffix;

		private int _lastValue = int.MinValue; 

		public AsakiIntTextObserver(Text targetText, string prefix = "", string suffix = "")
		{
			_targetText = targetText;
			_prefix = prefix;
			_suffix = suffix;
		}

		public void OnValueChange(int value)
		{
			if (_targetText == null) return; // 防止 UI 被销毁后报错
            
			// 脏检查：如果 UI 上已经是这个数字，就不动它 (节省 Canvas Rebuild)
			if (value == _lastValue) return;
			_lastValue = value;

			// 1. 从池中借出 StringBuilder
			var sb = AsakiStringBuilderPool.Rent();

			// 2. 拼接 (Append(int) 是无 GC 的)
			if (!string.IsNullOrEmpty(_prefix)) sb.Append(_prefix);
			sb.Append(value);
			if (!string.IsNullOrEmpty(_suffix)) sb.Append(_suffix);

			// 3. 赋值并归还
			// 注意：对于 Legacy Text，ToString() 依然会产生一个 String 对象的 GC，
			// 但这已经是原生组件的极限。如果是 TextMeshPro，可以使用 _tmp.SetText(sb); 达到真·ZeroGC。
			_targetText.text = AsakiStringBuilderPool.GetStringAndRelease(sb);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiSliderObserver.cs -->
<!-- GUID: 8136d26664cc41a895e2f0df8badcecc -->
<!-- Size: 568 bytes -->
<!-- Modified: 2025-12-22 16:47:30 -->
```csharp
using Asaki.Core.MVVM;
using UnityEngine.UI;

namespace Asaki.Unity.Services.UI.Observers
{
	/// <summary>
	/// [Slider专用] 将 float 属性绑定到进度条。
	/// </summary>
	public class AsakiSliderObserver : IAsakiObserver<float>
	{
		private readonly Slider _slider;

		public AsakiSliderObserver(Slider slider)
		{
			_slider = slider;
		}

		public void OnValueChange(float value)
		{
			if (_slider == null) return;
			if (!UnityEngine.Mathf.Approximately(_slider.value, value))
			{
				_slider.value = value;
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiTextMeshProFloatObserver.cs -->
<!-- GUID: 368aca87f32d4edca4f12f866705301c -->
<!-- Size: 1084 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Unity.Utils;
using TMPro;
using UnityEngine;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiTextMeshProFloatObserver : IAsakiObserver<float>
	{
		private readonly TextMeshPro _target;
		private readonly string _format;
		private readonly string _prefix;
		private readonly string _suffix;
		private float _lastValue = float.MinValue;

		public AsakiTextMeshProFloatObserver(TextMeshPro target, string format = "F1", string prefix = "", string suffix = "")
		{
			_target = target;
			_format = format;
			_prefix = prefix;
			_suffix = suffix;
		}

		public void OnValueChange(float value)
		{
			if (!_target) return;
			if (Mathf.Approximately(value, _lastValue)) return; // 脏检查
			_lastValue = value;

			// 1. 借出 Builder
			var sb = AsakiStringBuilderPool.Rent();

			// 2. 拼接
			if (!string.IsNullOrEmpty(_prefix)) sb.Append(_prefix);
			sb.Append(value.ToString(_format));
			if (!string.IsNullOrEmpty(_suffix)) sb.Append(_suffix);

			_target.SetText(sb);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiTextMeshProIntObserver.cs -->
<!-- GUID: 2b6888d018c94be993093563f73abc85 -->
<!-- Size: 928 bytes -->
<!-- Modified: 2025-12-22 16:59:30 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Unity.Utils;
using TMPro;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiTextMeshProIntObserver : IAsakiObserver<int>
	{
		private readonly TextMeshPro _target;
		private readonly string _prefix;
		private readonly string _suffix;
		private int _lastValue = int.MinValue;

		public AsakiTextMeshProIntObserver(TextMeshPro target, string prefix = "", string suffix = "")
		{
			_target = target;
			_prefix = prefix;
			_suffix = suffix;
		}
		
		public void OnValueChange(int value)
		{
			if (!_target) return;
			if (value == _lastValue) return; // 脏检查
			_lastValue = value;
			var sb = AsakiStringBuilderPool.Rent();
			if (!string.IsNullOrEmpty(_prefix)) sb.Append(_prefix);
			sb.Append(value);
			if (!string.IsNullOrEmpty(_suffix)) sb.Append(_suffix);
			_target.SetText(sb);
			AsakiStringBuilderPool.Return(sb);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiTMPTextFloatObserver.cs -->
<!-- GUID: f6f2bf471a324a058276f1672abd59df -->
<!-- Size: 1136 bytes -->
<!-- Modified: 2025-12-22 17:00:06 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Unity.Utils;
using TMPro;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiTMPTextFloatObserver : IAsakiObserver<float>
	{
		private readonly TMP_Text _target;
		private readonly string _format; // 例如 "F1", "0.00"
		private readonly string _prefix;
		private readonly string _suffix;
		private float _lastValue = float.NaN; // 使用 NaN 确保第一次一定更新

		public AsakiTMPTextFloatObserver(TMP_Text target, string format = "F1", string prefix = "", string suffix = "")
		{
			_target = target;
			_format = format;
			_prefix = prefix;
			_suffix = suffix;
		}

		public void OnValueChange(float value)
		{
			if (!_target) return;
			if (UnityEngine.Mathf.Approximately(_lastValue, value)) return;
			_lastValue = value;

			var sb = AsakiStringBuilderPool.Rent();
			if (!string.IsNullOrEmpty(_prefix)) sb.Append(_prefix);
			
			sb.Append(value.ToString(_format)); 
            
			if (!string.IsNullOrEmpty(_suffix)) sb.Append(_suffix);
            
			_target.SetText(sb);
			AsakiStringBuilderPool.Return(sb);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiTMPTextIntObserver.cs -->
<!-- GUID: bf65f102c5d644a18bbeebfbe5fe1f43 -->
<!-- Size: 1204 bytes -->
<!-- Modified: 2025-12-22 17:00:06 -->
```csharp
using Asaki.Core.MVVM;
using Asaki.Unity.Utils;
using TMPro;

namespace Asaki.Unity.Services.UI.Observers
{
	/// <summary>
	/// [TMP专用] 零GC Int 绑定器。
	/// 利用 TextMeshPro 的 SetText(StringBuilder) 实现极致性能。
	/// </summary>
	public class AsakiTMPTextIntObserver : IAsakiObserver<int>
	{
		private readonly TMP_Text _target;
		private readonly string _prefix;
		private readonly string _suffix;
		private int _lastValue = int.MinValue;

		public AsakiTMPTextIntObserver(TMP_Text target, string prefix = "", string suffix = "")
		{
			_target = target;
			_prefix = prefix;
			_suffix = suffix;
		}

		public void OnValueChange(int value)
		{
			if (!_target) return;
			if (value == _lastValue) return; // 脏检查
			_lastValue = value;

			// 1. 借出 Builder
			var sb = AsakiStringBuilderPool.Rent();

			// 2. 拼接
			if (!string.IsNullOrEmpty(_prefix)) sb.Append(_prefix);
			sb.Append(value);
			if (!string.IsNullOrEmpty(_suffix)) sb.Append(_suffix);

			// 3. 直接喂给 TextMeshPro (这是 TextMeshPro 独有的 ZeroGC API)
			_target.SetText(sb);

			// 4. 归还
			AsakiStringBuilderPool.Return(sb);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/UI/Observers/AsakiToggleObserver.cs -->
<!-- GUID: d162c7a94d564fdea9d3ad78653695e1 -->
<!-- Size: 426 bytes -->
<!-- Modified: 2025-12-22 16:47:30 -->
```csharp
using Asaki.Core.MVVM;
using UnityEngine.UI;

namespace Asaki.Unity.Services.UI.Observers
{
	public class AsakiToggleObserver : IAsakiObserver<bool>
	{
		private readonly Toggle _toggle;

		public AsakiToggleObserver(Toggle toggle)
		{
			_toggle = toggle;
		}

		public void OnValueChange(bool value)
		{
			if (_toggle != null && _toggle.isOn != value)
			{
				_toggle.isOn = value;
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Utils/AsakiAudioAsyncBridge.cs -->
<!-- GUID: a5084336e21f494da2c58e7309d57a87 -->
<!-- Size: 7226 bytes -->
<!-- Modified: 2025-12-22 16:47:41 -->
```csharp
using Cysharp.Threading.Tasks;
using System;
using System.Threading;
#if ASAKI_USE_UNITASK

#else
using System.Threading.Tasks;
using System.Collections;
#endif

namespace Asaki.Unity.Utils
{
	/// <summary>
	/// [Internal] 音频模块专用的异步桥接器。
	/// 屏蔽 UniTask / Task / Coroutine 的差异。
	/// </summary>
	internal static class AsakiAudioAsyncBridge
	{
		// ==========================================================
		// 1. 统一的返回类型 (ReturnType)
		// ==========================================================
		#if ASAKI_USE_UNITASK
		public struct Awaitable : System.Runtime.CompilerServices.ICriticalNotifyCompletion
		{
			private UniTask _task;
			public Awaitable(UniTask task) => _task = task;
			public Awaitable GetAwaiter() => this;
			public bool IsCompleted => _task.GetAwaiter().IsCompleted;
			public void GetResult() => _task.GetAwaiter().GetResult();
			public void OnCompleted(Action continuation) => _task.GetAwaiter().OnCompleted(continuation);
			public void UnsafeOnCompleted(Action continuation) => _task.GetAwaiter().UnsafeOnCompleted(continuation);

			#if ASAKI_USE_UNITASK
			public void ForgetInternal(Action<Exception> onException)
			{
				_task.Forget();
			}
			#endif
		}

		public struct AwaitableVoid
		{
			private UniTaskVoid _task;
			public AwaitableVoid(UniTaskVoid task) => _task = task;
			public void Forget() => _task.Forget();
		}
		#else
        public struct Awaitable : System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            private Task _task;
            public Awaitable(Task task) => _task = task;
            public Awaitable GetAwaiter() => this;
            public bool IsCompleted => _task.GetAwaiter().IsCompleted;
            public void GetResult() => _task.GetAwaiter().GetResult();
            public void OnCompleted(Action continuation) => _task.GetAwaiter().OnCompleted(continuation);
            public void UnsafeOnCompleted(Action continuation) => _task.GetAwaiter().UnsafeOnCompleted(continuation);
        }

        public struct AwaitableVoid 
        {
            private Task _task;
            public AwaitableVoid(Task task) => _task = task;
            public void Forget() { /* Task 本身如果不 await 就是 Fire&Forget */ }
        }
		#endif

		// ==========================================================
		// 2. 统一的延迟方法 (Delay)
		// ==========================================================
		public static Awaitable Delay(int millisecondsDelay, bool ignoreTimeScale, CancellationToken token)
		{
			#if ASAKI_USE_UNITASK
			// Delay 返回的是 UniTask，可以直接构造
			return new Awaitable(UniTask.Delay(millisecondsDelay, ignoreTimeScale, PlayerLoopTiming.Update, token));
			#else
            return new Awaitable(Task.Delay(millisecondsDelay, token));
			#endif
		}

		// ==========================================================
		// 3. 统一的帧等待 (Yield) - [修复点]
		// ==========================================================
		public static Awaitable Yield()
		{
			#if ASAKI_USE_UNITASK
			// [修复] YieldAwaitable -> UniTask
			// 使用辅助方法将 Yield 包装为标准 UniTask
			return new Awaitable(YieldToUniTask());
			#else
            // [修复] YieldAwaitable -> Task
            return new Awaitable(YieldToTask());
			#endif
		}

		#if ASAKI_USE_UNITASK
		// 辅助：将 YieldAwaitable 转换为 UniTask
		private static async UniTask YieldToUniTask()
		{
			await UniTask.Yield(PlayerLoopTiming.Update);
		}
		#else
        // 辅助：将 YieldAwaitable 转换为 Task
        private static async Task YieldToTask() 
        { 
            await Task.Yield(); 
        }
		#endif

		// ==========================================================
		// 4. 统一的取消等待 (WaitUntilCanceled)
		// ==========================================================
		public static Awaitable WaitUntilCanceled(CancellationToken token)
		{
			#if ASAKI_USE_UNITASK
			return new Awaitable(UniTask.WaitUntilCanceled(token));
			#else
            // 原生 Task 模拟 WaitUntilCanceled
            return new Awaitable(Task.Delay(-1, token).ContinueWith(_ => { }, TaskContinuationOptions.OnlyOnCanceled));
			#endif
		}


		// ==========================================================
		// 5. Fire and Forget (核心规避方案)
		// ==========================================================

		// ==========================================================
		// 5. Fire and Forget (核心规避方案)
		// ==========================================================

		#if ASAKI_USE_UNITASK
		// [修复点] 添加 Action<Exception> 参数
		public static void FireAndForget(this UniTask task, Action<Exception> onException = null)
		{
			// UniTask.Forget() 默认只打印日志到 UnityConsole
			// 如果用户提供了自定义异常处理，我们需要自己 wrap 一下
			if (onException == null)
			{
				task.Forget();
			}
			else
			{
				ForgetWithCustomHandler(task, onException).Forget();
			}
		}

		private static async UniTaskVoid ForgetWithCustomHandler(UniTask task, Action<Exception> onException)
		{
			try { await task; }
			catch (Exception ex) { onException(ex); }
		}
		#else
        // [修复点] 添加 Action<Exception> 参数
        public static async void FireAndForget(this Task task, Action<Exception> onException = null)
        {
            try { await task; }
            catch (Exception e) 
            { 
                if (onException != null) onException(e);
                else UnityEngine.Debug.LogException(e); 
            }
        }
		#endif

		/// <summary>
		/// 安全地“遗忘”一个异步任务。
		/// 替代 async void，防止异常导致的崩溃或静默失败。
		/// </summary>
		public static void FireAndForget(this Awaitable awaitable, Action<Exception> onException = null)
		{
			#if ASAKI_USE_UNITASK
			// UniTask 的 Forget 已经处理了异常日志
			// 但我们需要把我们的 Wrapper 拆箱出来
			// 由于 Awaitable 是结构体，我们需要在 Awaitable 里暴露内部 Task，或者直接在这里操作
			awaitable.ForgetInternal(onException);
			#else
            // 原生 Task 的 FireAndForget 实现
            HandleTask(awaitable, onException);
			#endif
		}

		#if ASAKI_USE_UNITASK
		// 扩展 Awaitable 结构体以支持 Forget
		// 请在 Awaitable 结构体中添加这个方法:
		/*
		public void ForgetInternal(Action<Exception> onException)
		{
		    _task.Forget(); // UniTask 自带异常处理
		}
		*/
		#else
        private static async void HandleTask(Awaitable awaitable, Action<Exception> onException)
        {
            try
            {
                // 等待 Task 完成，如果有异常会在此时抛出
                await awaitable;
            }
            catch (Exception e)
            {
                if (onException != null) onException(e);
                else Debug.LogException(e); // 默认兜底日志
            }
        }
		#endif

	}
}
```

<!-- File: Asaki/Unity/Utils/AsakiCsvUtils.cs -->
<!-- GUID: 62f015a329cd4788826d5df73ce49768 -->
<!-- Size: 1181 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
// File: Asaki/Unity/Configuration/AsakiCsvUtils.cs

using System.Collections.Generic;
using System.Text;

namespace Asaki.Unity.Utils
{
	public static class AsakiCsvUtils
	{
		/// <summary>
		/// 解析 CSV 行，处理引号包裹的情况 (e.g. "Weapon, Fire", 100)
		/// </summary>
		public static string[] ParseLine(string line)
		{
			if (string.IsNullOrEmpty(line)) return new string[0];

			var result = new List<string>();
			var current = new StringBuilder();
			bool inQuotes = false;

			for (int i = 0; i < line.Length; i++)
			{
				char c = line[i];

				if (c == '"')
				{
					// 检查是否是转义引号 (两个双引号 "")
					if (inQuotes && i + 1 < line.Length && line[i + 1] == '"')
					{
						current.Append('"');
						i++; // 跳过下一个引号
					}
					else
					{
						inQuotes = !inQuotes; // 切换状态
					}
				}
				else if (c == ',' && !inQuotes)
				{
					// 分隔符
					result.Add(current.ToString().Trim());
					current.Clear();
				}
				else
				{
					current.Append(c);
				}
			}

			result.Add(current.ToString().Trim());
			return result.ToArray();
		}
	}
}
```

<!-- File: Asaki/Unity/Utils/AsakiFlow.cs -->
<!-- GUID: 12ec41cfa3764232a145f74936def60d -->
<!-- Size: 2980 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
using Asaki.Core.Coroutines;
using System.Threading;
using UnityEngine;

namespace Asaki.Unity.Utils
{
    /// <summary>
    /// [流控制核心] AsakiFlow
    /// 负责连接 Unity 生命周期与 Asaki 异步系统，消除 "Token Hell"。
    /// </summary>
    public static class AsakiFlow
    {
        // =========================================================
        // 1. 生命周期绑定 (Lifecycle Binding)
        // =========================================================

        /// <summary>
        /// 获取当前 MonoBehaviour 的生命周期 Token。
        /// <para>当 GameObject 被销毁时，此 Token 会自动取消。</para>
        /// <para>兼容性：自动适配 Unity 2022.2+ 原生 API，旧版本自动挂载追踪器。</para>
        /// </summary>
        public static CancellationToken GetToken(this MonoBehaviour self)
        {
            if (self == null) return CancellationToken.None;

#if UNITY_2022_2_OR_NEWER
            // Unity 2022.2+ 原生支持
            return self.destroyCancellationToken;
#else
            // Unity 2021.3 LTS 兼容方案
            var tracker = self.GetComponent<AsakiLifecycleTracker>();
            if (tracker == null)
            {
                // 懒加载：只有在请求 Token 时才添加追踪组件
                tracker = self.gameObject.AddComponent<AsakiLifecycleTracker>();
                
                // 隐藏组件，保持 Inspector 干净
                tracker.hideFlags = HideFlags.HideInInspector; 
            }
            return tracker.Token;
#endif
        }

        // =========================================================
        // 2. 混合链接 (Hybrid Linking)
        // =========================================================

        /// <summary>
        /// [核心语法糖] 创建一个 "双重保险" 的 Token。
        /// <para>取消条件：Service 被重置 OR 目标 Component 被销毁。</para>
        /// <para>用法：await _routine.WaitSeconds(1f, _routine.Link(this));</para>
        /// </summary>
        /// <param name="service">异步服务实例</param>
        /// <param name="component">绑定的 Unity 组件</param>
        public static CancellationToken Link(this IAsakiRoutineService service, MonoBehaviour component)
        {
            var componentToken = component.GetToken();
            
            // 利用 Service 现有的 CreateLinkedToken 方法
            // 它会自动连接 Service 自身的全局 CTS
            return service.CreateLinkedToken(componentToken);
        }

        /// <summary>
        /// 链接另一个外部 Token (通常用于 UI 窗口关闭按钮)
        /// </summary>
        public static CancellationToken Link(this IAsakiRoutineService service, CancellationToken externalToken)
        {
            return service.CreateLinkedToken(externalToken);
        }
    }
}```

<!-- File: Asaki/Unity/Utils/AsakiResKitAsyncBridge.cs -->
<!-- GUID: 4827729bf51743b5b544ce4522369235 -->
<!-- Size: 2515 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
using Cysharp.Threading.Tasks;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Utils
{
	/// <summary>
	/// [异步桥接器]
	/// 屏蔽 UniTask 与原生 Task/Coroutine 的差异。
	/// </summary>
	public static class AsakiResKitAsyncBridge
	{
		/// <summary>
		/// 将 ResourceRequest (Unity 异步加载) 转换为标准 Task。
		/// </summary>
		public static Task<Object> ToTask(this ResourceRequest request, CancellationToken token = default)
		{
			#if ASAKI_USE_UNITASK
			// === 方案 A: 有 UniTask (高性能，零分配等待) ===
			// UniTask 能够直接 await ResourceRequest，并且支持 Token 取消
			return request.ToUniTask(cancellationToken: token).AsTask();
			#else
            // === 方案 B: 原生兼容 (使用 TCS 包装) ===
            var tcs = new TaskCompletionSource<Object>();

            // 1. 注册取消回调
            if (token.IsCancellationRequested)
            {
                tcs.SetCanceled();
                return tcs.Task;
            }
            
            // 注册 Token 取消时的行为
            var registration = token.Register(() => 
            {
                tcs.TrySetCanceled();
                // 注意：ResourceRequest 很难真正从底层取消，这里只是断开 Task 连接
            });

            // 2. 监听 Unity 完成事件
            request.completed += _ => 
            {
                registration.Dispose();
                if (token.IsCancellationRequested)
                {
                    tcs.TrySetCanceled();
                    return;
                }

                if (request.asset == null)
                {
                    // 可以在这里决定是返回 null 还是抛出异常
                    tcs.TrySetResult(null); 
                }
                else
                {
                    tcs.TrySetResult(request.asset);
                }
            };

            return tcs.Task;
			#endif
		}

		/// <summary>
		/// 将 Addressables 的 Handle 或其他 Task 统一化
		/// </summary>
		public static Task<T> ConvertTask<T>(Task<T> task)
		{
			// 如果已经是 Task，直接返回
			return task;
		}

		#if ASAKI_USE_UNITASK
		// 专门用于将 UniTask 转回 Task 的重载
		public static Task<T> ConvertTask<T>(UniTask<T> task)
		{
			return task.AsTask();
		}
		#endif
	}
}
```

<!-- File: Asaki/Unity/Utils/AsakiStringBuilderPool.cs -->
<!-- GUID: a9c2f46ba980423898bd1681a841e281 -->
<!-- Size: 1357 bytes -->
<!-- Modified: 2025-12-22 16:48:01 -->
```csharp
using System.Collections.Generic;
using System.Text;

namespace Asaki.Unity.Utils
{
	/// <summary>
	/// [工具类] StringBuilder 对象池。
	/// 用于避免字符串拼接时的临时内存分配。
	/// </summary>
	public static class AsakiStringBuilderPool
	{
		// 静态栈，用于缓存对象
		private static readonly Stack<StringBuilder> _pool = new Stack<StringBuilder>(8);
		private const int MAX_CAPACITY = 1024; // 如果 Builder 变得太大，就丢弃，防止内存占用过高

		/// <summary>
		/// 借出一个 StringBuilder
		/// </summary>
		public static StringBuilder Rent()
		{
			if (_pool.Count > 0)
			{
				return _pool.Pop();
			}
			return new StringBuilder(256); // 默认 256 字符容量
		}

		/// <summary>
		/// 归还一个 StringBuilder
		/// </summary>
		public static void Return(StringBuilder sb)
		{
			if (sb == null) return;

			// 如果容量撑得太大，直接丢弃，不入池
			if (sb.Capacity > MAX_CAPACITY)
			{
				return;
			}

			// 清空内容，准备下次使用
			sb.Clear();
			_pool.Push(sb);
		}
        
		/// <summary>
		/// 快捷方法：借出 -> 转换 -> 归还
		/// </summary>
		public static string GetStringAndRelease(StringBuilder sb)
		{
			string result = sb.ToString();
			Return(sb);
			return result;
		}
	}
}
```

<!-- File: Game/Examples/BrokerExample.cs -->
<!-- GUID: 9eae53e2474e494dbfcfc9417ac6656c -->
<!-- Size: 631 bytes -->
<!-- Modified: 2025-12-23 19:32:26 -->
```csharp
using Asaki.Core.Broker;
using Asaki.Core.Context;
using UnityEngine;

namespace Game.Test
{
	public struct AsakiPlayerJumpExampleEvent : IAsakiEvent { }
	public class BrokerExample : MonoBehaviour, IAsakiHandler<AsakiPlayerJumpExampleEvent>
	{
		private void OnEnable()
		{
			this.AsakiRegister();
		}

		private void OnDisable()
		{
			this.AsakiUnregister();
		}
		public void OnEvent(AsakiPlayerJumpExampleEvent e)
		{
			Debug.Log("OnEvent");
		}

		[ContextMenu("Test")]
		public void test()
		{
			AsakiContext.Get<IAsakiEventService>().Publish(new AsakiPlayerJumpExampleEvent());
		}
	}
}
```

<!-- File: Game/Examples/ConfigExample.cs -->
<!-- GUID: 0fddf2819dd74f31bd4f5555ac467ee8 -->
<!-- Size: 2433 bytes -->
<!-- Modified: 2025-12-23 14:04:32 -->
```csharp
using Asaki.Core;
using Asaki.Core.Configuration;
using Asaki.Core.Context;
using UnityEngine;

namespace Game.Test
{
	[AsakiSave]
	public partial class AsakiWeaponConfigExample : IAsakiConfig
	{
		[AsakiSaveMember] public int Id { get; set; }
		[AsakiSaveMember] public string WeaponAssetPath { get; set; }

	}

	/*
	// <auto-generated/>
	// 生成时间: 12/22/2025 19:32:24
	using Asaki.Core.Serialization;
	using UnityEngine;
	using System.Collections.Generic;
	using System;

	namespace Game.Test
	{
	    partial class AsakiWeaponConfigExample : IAsakiSavable
	    {
	        // WARNING: This is a configuration type. Direct serialization is restricted for safety.
	        private bool _allowConfigSerialization = false;

	        /// <summary>
	        /// Internal method to enable config serialization. This should ONLY be called by the config system.
	        /// </summary>
	        internal void AllowConfigSerialization(bool allow = true)
	        {
	            _allowConfigSerialization = allow;
	        }

	        public void Serialize(IAsakiWriter writer)
	        {
	            // SECURITY CHECK: Prevent accidental serialization of config objects
	            if (!_allowConfigSerialization)
	            {
	                throw new InvalidOperationException("Security violation: Attempt to serialize configuration object 'AsakiWeaponConfigExample'. " +
	                    "Configuration objects should NEVER be saved in game saves. " +
	                    "Instead, save only the configuration ID and reload the config when needed.");
	            }

	            writer.BeginObject("AsakiWeaponConfigExample");
	            writer.WriteInt("Id", this.Id);
	            writer.WriteString("WeaponAssetPath", this.WeaponAssetPath);
	            writer.EndObject();
	        }

	        public void Deserialize(IAsakiReader reader)
	        {
	            this.Id = reader.ReadInt("Id");
	            this.WeaponAssetPath = reader.ReadString("WeaponAssetPath");
	        }
	    }
	}

	 */

	public class ConfigExample : MonoBehaviour
	{
		[ContextMenu("Query")]
		public void Query()
		{
			var weapon = AsakiContext.Get<IAsakiConfigService>().Get<AsakiWeaponConfigExample>(0);
			if(weapon != null)
			{
				Debug.Log(weapon.WeaponAssetPath);
			}
			else
			{
				Debug.LogError("Weapon config not found.");
			}
		}
	}
}
```

<!-- File: Game/Examples/MVVMExample.cs -->
<!-- GUID: 04c1a4dc064047f8ad3d8b8607840fa0 -->
<!-- Size: 1547 bytes -->
<!-- Modified: 2025-12-22 18:10:59 -->
```csharp
using Asaki.Core;
using Asaki.Core.MVVM;
using System;
using UnityEngine;

namespace Game.Test
{
	[AsakiBind]
	public partial class AsakiMVVMExampleModel
	{
		public AsakiProperty<int> Health;
	}

	/*
	// <auto-generated/>
	// 生成时间: 12/22/2025 18:10:13
	using System;
	using UnityEngine;
	using Asaki.Core.MVVM;

	namespace Game.Test
	{
	    public partial class AsakiMVVMExampleModel
	    {
	        public enum PropertyId
	        {
	            Health,
	        }

	        public object GetProperty(PropertyId id)
	        {
	            switch (id)
	            {
	                case PropertyId.Health: return this.Health;
	            }
	            return null;
	        }

	        /// <summary>
	        /// 绑定到 Action 委托 (便捷模式)
	        /// </summary>
	        public void BindHealth(Action<int> action)
	        {
	            if (this.Health != null) this.Health.Subscribe(action);
	        }

	        /// <summary>
	        /// 绑定到 Observer 结构体 (高性能 ZeroGC 模式)
	        /// </summary>
	        public void BindHealth(IAsakiObserver<int> observer)
	        {
	            if (this.Health != null) this.Health.Bind(observer);
	        }

	    }
	}

	 */

	public class MVVMExample : MonoBehaviour
	{
		private void Start()
		{
			AsakiMVVMExampleModel model = new AsakiMVVMExampleModel();
			model.BindHealth(OnHealthUpdate);
		}

		public void OnHealthUpdate(int headlth)
		{
			Debug.Log(headlth);
		}
	}
}
```

<!-- File: Game/Examples/SaveExample.cs -->
<!-- GUID: f1e19f109143452095f8e59a4e13571b -->
<!-- Size: 1678 bytes -->
<!-- Modified: 2025-12-22 19:17:21 -->
```csharp
using Asaki.Core;
using System.Collections.Generic;

namespace Game.Test
{
	[AsakiSave]
	public partial class AsakiSaveExampleModel
	{
		[AsakiSaveMember(Order = 1)] public int version;
		[AsakiSaveMember(Order = 2)] public List<string> tests;
	}
	
	/*
	基于Rolsyn自动生成
	// 生成时间: 12/22/2025 19:16:58
	using Asaki.Core.Serialization;
	using UnityEngine;
	using System.Collections.Generic;
	using System;

	namespace Game.Test
	{
	    partial class AsakiSaveExampleModel : IAsakiSavable
	    {
	        public void Serialize(IAsakiWriter writer)
	        {
	            writer.BeginObject("AsakiSaveExampleModel");
	            writer.WriteInt("version", this.version);
	            writer.BeginList("tests", this.tests != null ? this.tests.Count : 0);
	            if (this.tests != null)
	            {
	                foreach (var item in this.tests)
	                {
	                    writer.WriteString("Item", item);
	                }
	            }
	            writer.EndList();
	            writer.EndObject();
	        }

	        public void Deserialize(IAsakiReader reader)
	        {
	            this.version = reader.ReadInt("version");
	            int count_tests = reader.BeginList("tests");
	            if (this.tests == null) this.tests = new System.Collections.Generic.List<string>(count_tests);
	            this.tests.Clear();
	            for (int i = 0; i < count_tests; i++)
	            {
	                this.tests.Add(reader.ReadString("Item"));
	            }
	            reader.EndList();
	        }
	    }
	}


	 */
	
	public class SaveExample
	{
		
	}
}
```

```
