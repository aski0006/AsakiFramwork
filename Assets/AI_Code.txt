# Unity Scripts Aggregation
# Generated: 2025-12-30 14:36:08
# Total Files: 13
# Total Size: 41475 bytes

<!-- File: Asaki/Core/Coroutines/IAsakiCoroutineService.cs -->
<!-- GUID: 5d64d36ebfc94b3a8b1e0bf5a05c1811 -->
<!-- Size: 5264 bytes -->
<!-- Modified: 2025-12-26 16:44:24 -->
```csharp
using Asaki.Core.Context;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Core.Coroutines
{
	/// <summary>
	/// [异步服务接口] (v3.0 Enhanced)
	/// 提供完整的时间控制、条件等待和任务管理能力。
	/// </summary>
	public interface IAsakiCoroutineService : IAsakiService
	{
		// === 基本等待方法 ===

		/// <summary>
		/// 等待指定秒数 (受 TimeScale 影响)
		/// </summary>
		Task WaitSeconds(float seconds, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定秒数 (真实时间，不受 TimeScale 影响)
		/// </summary>
		Task WaitSecondsUnscaled(float seconds, CancellationToken token = default(CancellationToken));

		// === 帧等待 ===

		/// <summary>
		/// 等待下一帧 (Update)
		/// </summary>
		Task WaitFrame(CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定数量的帧
		/// </summary>
		Task WaitFrames(int count, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待物理/固定帧 (FixedUpdate)
		/// </summary>
		Task WaitFixedFrame(CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待指定数量的物理帧
		/// </summary>
		Task WaitFixedFrames(int count, CancellationToken token = default(CancellationToken));

		// === 条件等待 ===

		/// <summary>
		/// 挂起直到条件为 true
		/// </summary>
		Task WaitUntil(Func<bool> predicate, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 挂起直到条件为 false
		/// </summary>
		Task WaitWhile(Func<bool> predicate, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待直到条件为 true，带超时时间
		/// </summary>
		Task<bool> WaitUntil(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 等待直到条件为 false，带超时时间
		/// </summary>
		Task<bool> WaitWhile(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken));

		// === 任务管理 ===

		/// <summary>
		/// 异步执行一个任务，自动处理取消和异常
		/// </summary>
		Task RunTask(Func<Task> taskFunc, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 异步执行一个带返回值的任务
		/// </summary>
		Task<T> RunTask<T>(Func<Task<T>> taskFunc, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 延迟执行一个动作
		/// </summary>
		Task DelayedCall(float delaySeconds, Action action, CancellationToken token = default(CancellationToken), bool unscaledTime = false);

		/// <summary>
		/// 在下一帧执行一个动作
		/// </summary>
		Task NextFrameCall(Action action, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 当条件满足时执行一个动作
		/// </summary>
		Task When(Func<bool> condition, Action action, CancellationToken token = default(CancellationToken));

		// === 批量任务管理 ===

		/// <summary>
		/// 等待所有任务完成
		/// </summary>
		Task WaitAll(params Task[] tasks);

		/// <summary>
		/// 等待任意一个任务完成
		/// </summary>
		Task WaitAny(params Task[] tasks);

		/// <summary>
		/// 顺序执行多个异步操作
		/// </summary>
		Task Sequence(params Func<Task>[] actions);

		/// <summary>
		/// 并行执行多个异步操作
		/// </summary>
		Task Parallel(params Func<Task>[] actions);

		/// <summary>
		/// 重试执行异步操作
		/// </summary>
		Task Retry(Func<Task> action, int maxRetries = 3, float retryDelay = 1f, CancellationToken token = default(CancellationToken));

		// === 高级等待模式 ===

		/// <summary>
		/// 等待一个自定义的等待源
		/// </summary>
		Task WaitCustom(IAsakiWaitSource waitSource, CancellationToken token = default(CancellationToken));

		/// <summary>
		/// 创建可配置的等待构建器
		/// </summary>
		IWaitBuilder CreateWaitBuilder();

		// === 状态和取消 ===

		/// <summary>
		/// 当前运行的任务数量
		/// </summary>
		int RunningTaskCount { get; }

		/// <summary>
		/// 取消所有正在运行的任务
		/// </summary>
		void CancelAllTasks();

		/// <summary>
		/// 创建一个链接到服务生命周期的取消令牌
		/// </summary>
		CancellationToken CreateLinkedToken(CancellationToken externalToken = default(CancellationToken));
	}

	// === 扩展接口 ===

	/// <summary>
	/// 自定义等待源接口
	/// </summary>
	public interface IAsakiWaitSource
	{
		bool IsCompleted { get; }
		float Progress { get; }
		void Update();
	}

	/// <summary>
	/// 等待构建器接口（流畅API）
	/// </summary>
	public interface IWaitBuilder
	{
		IWaitBuilder Seconds(float seconds, bool unscaled = false);
		IWaitBuilder Frames(int count);
		IWaitBuilder FixedFrames(int count);
		IWaitBuilder Until(Func<bool> condition);
		IWaitBuilder While(Func<bool> condition);
		Task Build(CancellationToken token = default(CancellationToken));
	}
}
```

<!-- File: Asaki/Core/Network/AsakiWebException.cs -->
<!-- GUID: 6060da023f6e4716abff77c13a072245 -->
<!-- Size: 299 bytes -->
<!-- Modified: 2025-12-26 16:01:43 -->
```csharp
namespace Asaki.Core.Network
{
	public class AsakiWebException : System.Exception
	{
		public long ResponseCode { get; }
		public string Url { get; }
		public AsakiWebException(string message, long code, string url) : base(message)
		{
			ResponseCode = code;
			Url = url;
		}
	}
}
```

<!-- File: Asaki/Core/Network/IAsakiWebService.cs -->
<!-- GUID: aba658193b4f4f8cbc29d55c5417edf0 -->
<!-- Size: 1095 bytes -->
<!-- Modified: 2025-12-26 21:44:49 -->
```csharp
using Asaki.Core.Context;
using Asaki.Core.Serialization;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Core.Network
{
	public interface IAsakiWebService : IAsakiService
	{
		void SetBaseUrl(string url);
		void SetTimeout(int seconds);

		void AddInterceptor(IAsakiWebInterceptor interceptor);
		void RemoveInterceptor(IAsakiWebInterceptor interceptor);

		/// <summary>
		/// GET 请求
		/// </summary>
		Task<TResponse> GetAsync<TResponse>(string apiPath)
			where TResponse : IAsakiSavable, new();

		Task<TResponse> PostAsync<TRequest, TResponse>(string apiPath, TRequest body)
			where TRequest : IAsakiSavable
			where TResponse : IAsakiSavable, new();

		Task<TResponse> PostFormAsync<TResponse>(string apiPath, WWWForm form)
			where TResponse : IAsakiSavable, new();
	}

	public interface IAsakiWebInterceptor
	{
		void OnRequest(UnityEngine.Networking.UnityWebRequest uwr);
		bool OnResponse(UnityEngine.Networking.UnityWebRequest uwr);
		void OnError(UnityEngine.Networking.UnityWebRequest uwr, System.Exception ex);
	}

}
```

<!-- File: Asaki/Unity/Extensions/AsakiUnityWebRequestExtensions.cs -->
<!-- GUID: 947f331e8c164a769544907162fc8707 -->
<!-- Size: 640 bytes -->
<!-- Modified: 2025-12-26 21:45:52 -->
```csharp
using System.Threading.Tasks;
using UnityEngine.Networking;

namespace Asaki.Unity.Extensions
{
	public static class AsakiUnityWebRequestExtensions
	{
		public static Task SendWebRequestAsTask(this UnityWebRequest uwr)
		{
			var tcs = new TaskCompletionSource<bool>();

			// UnityWebRequestAsyncOperation 是一个 AsyncOperation
			UnityWebRequestAsyncOperation op = uwr.SendWebRequest();

			op.completed += (asyncOp) =>
			{
				// 无论成功还是失败，只要请求结束，Task 就结束
				// 具体的成功/失败由 uwr.result 判断
				tcs.SetResult(true);
			};

			return tcs.Task;
		}
	}
}
```

<!-- File: Asaki/Unity/Modules/AsakiWebModule.cs -->
<!-- GUID: 9888f8a05ec34490a2f3c4f664a5323a -->
<!-- Size: 864 bytes -->
<!-- Modified: 2025-12-27 18:41:56 -->
```csharp
using Asaki.Core;
using Asaki.Core.Context;
using Asaki.Core.Network;
using Asaki.Unity.Configuration;
using Asaki.Unity.Services.Network;
using System.Threading.Tasks;

namespace Asaki.Unity.Modules
{
	[AsakiModule(priority: 100)]
	public class AsakiWebModule : IAsakiModule
	{

		private AsakiWebService _asakiWebService;

		public void OnInit()
		{
			AsakiConfig asakiConfig = AsakiContext.Get<AsakiConfig>();
			_asakiWebService = new AsakiWebService();
			_asakiWebService.OnInit();
			_asakiWebService.SetBaseUrl(asakiConfig.BaseUrt);
			_asakiWebService.SetTimeout(asakiConfig.WebTimeoutSeconds);
			AsakiContext.Register<IAsakiWebService>(_asakiWebService);
		}
		public async Task OnInitAsync()
		{
			await _asakiWebService.OnInitAsync();
		}
		public void OnDispose()
		{
			_asakiWebService?.OnDispose();
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiCoroutineRunner.cs -->
<!-- GUID: fb468c54dbb94558a21da27654d30d7c -->
<!-- Size: 230 bytes -->
<!-- Modified: 2025-12-23 17:48:27 -->
```csharp
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	[AddComponentMenu("")]
	internal class AsakiCoroutineRunner : MonoBehaviour
	{
		private void Awake()
		{
			DontDestroyOnLoad(gameObject);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Bridge.cs -->
<!-- GUID: ad3ffcfc7ea949ae94b19b66c15cb1c1 -->
<!-- Size: 3084 bytes -->
<!-- Modified: 2025-12-26 21:44:47 -->
```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	public partial class AsakiCoroutineProvider
	{
		// =========================================================
		// Core Bridge: IEnumerator -> Task
		// =========================================================

		/// <summary>
		/// [核心桥接] 将 Unity 协程封装为标准 Task。
		/// <para>1. 支持 await 语法糖。</para>
		/// <para>2. 支持 CancellationToken 取消 (立即停止协程)。</para>
		/// <para>3. 0 轮询开销 (Zero Polling Overhead)。</para>
		/// </summary>
		/// <param name="routine">要执行的 Unity 协程迭代器</param>
		/// <param name="token">取消令牌</param>
		private Task RunRoutine(System.Collections.IEnumerator routine, CancellationToken token)
		{
			// 1. 快速检查：如果已经取消，直接返回 Canceled Task
			if (token.IsCancellationRequested) return Task.FromCanceled(token);

			// 2. 安全检查：如果 Runner 丢失 (比如游戏退出时)，抛出异常或快速返回
			if (_runner == null) return Task.FromException(new InvalidOperationException("Asaki Coroutine Runner is missing or destroyed."));

			// 3. 创建 TCS (TaskCompletionSource)
			// 关键点：RunContinuationsAsynchronously
			// 这能防止在某些极端情况下 (如协程同步完成) 导致的死锁，并强制后续代码在异步上下文中执行。
			var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

			// 4. 准备协程引用，用于后续取消
			Coroutine activeCoroutine = null;

			// 5. 注册取消回调 (Safety Valve)
			// 当 Token 被 Cancel 时，这个回调会被立即执行
			CancellationTokenRegistration registration = token.Register(() =>
			{
				// A. 停止 Unity 侧的协程 (防止后台空跑)
				if (activeCoroutine != null && _runner != null)
				{
					_runner.StopCoroutine(activeCoroutine);
				}

				// B. 将 Task 标记为取消
				tcs.TrySetCanceled(token);
			});

			// 6. 启动包装协程 (Wrapper)
			// 我们不能直接跑 routine，因为我们需要知道它什么时候结束
			activeCoroutine = _runner.StartCoroutine(ExecWrapper(routine, tcs, registration));

			return tcs.Task;
		}

		/// <summary>
		/// 内部包装器：负责等待原始协程完成，并处理结果
		/// </summary>
		private System.Collections.IEnumerator ExecWrapper(
			System.Collections.IEnumerator targetRoutine,
			TaskCompletionSource<bool> tcs,
			CancellationTokenRegistration registration)
		{
			// 等待原始业务逻辑执行完毕 (全权交给 Unity 引擎)
			yield return targetRoutine;

			// === 只有当上面这一行跑完，才会执行下面 ===

			// 清理取消注册 (既然跑完了，就不需要监听取消了)
			registration.Dispose();

			// 如果 Task 还没结束 (没被取消)，则标记为成功
			if (!tcs.Task.IsCompleted)
			{
				tcs.TrySetResult(true);
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Core.cs -->
<!-- GUID: 87308edfc0be45f2a16e78acb03ebaed -->
<!-- Size: 2490 bytes -->
<!-- Modified: 2025-12-26 21:44:43 -->
```csharp
using Asaki.Core.Coroutines;
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Asaki.Unity.Services.Coroutines
{
	// [修改点 1] 增加 IDisposable 接口，养成良好习惯
	public partial class AsakiCoroutineProvider : IAsakiCoroutineService, IDisposable
	{
		private CancellationTokenSource _serviceCts = new CancellationTokenSource();
		private int _runningTaskCount = 0;

		// [修改点 2] 持有 Runner 的引用
		private AsakiCoroutineRunner _runner;

		// [修改点 3] 构造函数初始化
		public AsakiCoroutineProvider()
		{
			InitializeRunner();
		}

		private void InitializeRunner()
		{
			// 防止重复初始化
			if (_runner != null) return;

			// 必须在主线程执行 (构造函数如果不在主线程会报错，但在 Unity 服务定位器模式中通常是安全的)
			GameObject go = new GameObject("[Asaki.Routine.Kernel]");
			Object.DontDestroyOnLoad(go);

			// 挂载驱动器
			_runner = go.AddComponent<AsakiCoroutineRunner>();
		}

		public int RunningTaskCount => _runningTaskCount;

		public void CancelAllTasks()
		{
			if (_serviceCts != null)
			{
				_serviceCts.Cancel();
				_serviceCts.Dispose();
			}
			_serviceCts = new CancellationTokenSource();
		}

		public CancellationToken CreateLinkedToken(CancellationToken externalToken = default(CancellationToken))
		{
			if (_serviceCts.IsCancellationRequested) return CancellationToken.None;
			if (externalToken == CancellationToken.None) return _serviceCts.Token;
			return CancellationTokenSource.CreateLinkedTokenSource(_serviceCts.Token, externalToken).Token;
		}

		private async Task Track(Func<Task> taskFunc)
		{
			Interlocked.Increment(ref _runningTaskCount);
			try
			{
				await taskFunc();
			}
			catch (OperationCanceledException)
			{
				// 任务被取消是正常操作
			}
			catch (Exception e)
			{
				Debug.LogException(e);
				throw;
			}
			finally
			{
				Interlocked.Decrement(ref _runningTaskCount);
			}
		}

		// [修改点 4] 销毁逻辑
		public void Dispose()
		{
			CancelAllTasks();

			// 销毁宿主 GameObject
			if (_runner != null)
			{
				// 区分运行时和编辑器模式的销毁
				if (Application.isPlaying)
					Object.Destroy(_runner.gameObject);
				else
					Object.DestroyImmediate(_runner.gameObject);

				_runner = null;
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Tasks.cs -->
<!-- GUID: 8ec10dc87628413194c72042d2e30eb2 -->
<!-- Size: 7586 bytes -->
<!-- Modified: 2025-12-26 21:44:43 -->
```csharp
using Asaki.Core.Coroutines;
using Cysharp.Threading.Tasks;
using System;
using System.Collections; // 引入 IEnumerator
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Asaki.Unity.Services.Coroutines
{
	/// <summary>
	/// [异步服务实现] Part 3: Tasks & Orchestration (Native Refactored)
	/// </summary>
	public partial class AsakiCoroutineProvider
	{
		// =========================================================
		// 1. 任务执行包装
		// =========================================================

		public Task RunTask(Func<Task> taskFunc, CancellationToken token = default(CancellationToken))
		{
			// Track 负责了计数和异常时的计数恢复，直接复用
			return Track(taskFunc);
		}

		public async Task<T> RunTask<T>(Func<Task<T>> taskFunc, CancellationToken token = default(CancellationToken))
		{
			// 链接 Token (虽然 taskFunc 内部可能不使用，但作为 API 契约建议处理)
			// 注意：这里我们无法强行取消 taskFunc 内部的逻辑，除非 taskFunc 接收 token
			// 所以这里的 token 主要是为了 Check
			if (token.IsCancellationRequested) throw new OperationCanceledException(token);

			Interlocked.Increment(ref _runningTaskCount);
			try
			{
				return await taskFunc();
			}
			finally
			{
				Interlocked.Decrement(ref _runningTaskCount);
			}
		}

		// =========================================================
		// 2. 快捷调用 (自动享受 Native 优化)
		// =========================================================

		public async Task DelayedCall(float delaySeconds, Action action, CancellationToken token = default(CancellationToken), bool unscaled = false)
		{
			// 使用 Track 确保计入 RunningTaskCount
			await Track(async () =>
			{
				CancellationToken linkedToken = CreateLinkedToken(token);

				// 这里调用的是 Part 2 中已经优化的 Native 方法
				if (unscaled) await WaitSecondsUnscaled(delaySeconds, linkedToken);
				else await WaitSeconds(delaySeconds, linkedToken);

				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		public async Task NextFrameCall(Action action, CancellationToken token = default(CancellationToken))
		{
			await Track(async () =>
			{
				CancellationToken linkedToken = CreateLinkedToken(token);
				await WaitFrame(linkedToken);
				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		public async Task When(Func<bool> condition, Action action, CancellationToken token = default(CancellationToken))
		{
			await Track(async () =>
			{
				CancellationToken linkedToken = CreateLinkedToken(token);
				await WaitUntil(condition, linkedToken);
				if (!linkedToken.IsCancellationRequested) action?.Invoke();
			});
		}

		// =========================================================
		// 3. 批量与流程控制
		// =========================================================

		public Task WaitAll(params Task[] tasks)
		{
			return Task.WhenAll(tasks);
		}

		public Task WaitAny(params Task[] tasks)
		{
			return Task.WhenAny(tasks);
		}

		public async Task Sequence(params Func<Task>[] actions)
		{
			await Track(async () =>
			{
				foreach (var action in actions)
				{
					// 依次执行，只要子任务是 Native 的，这里就是高效的
					await action();
				}
			});
		}

		public async Task Parallel(params Func<Task>[] actions)
		{
			await Track(async () =>
			{
				var tasks = new Task[actions.Length];
				for (int i = 0; i < actions.Length; i++)
				{
					tasks[i] = actions[i]();
				}
				await Task.WhenAll(tasks);
			});
		}

		public async Task Retry(Func<Task> action, int maxRetries = 3, float retryDelay = 1f, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			await Track(async () =>
			{
				for (int i = 0; i < maxRetries; i++)
				{
					try
					{
						await action();
						return; // 成功
					}
					catch (Exception)
					{
						if (i == maxRetries - 1) throw; // 最后一次失败
						if (linkedToken.IsCancellationRequested) return;

						// 失败等待 (Native 优化)
						await WaitSeconds(retryDelay, linkedToken);
					}
				}
			});
		}

		// =========================================================
		// 4. [重构重点] 自定义等待源 (Native Optimized)
		// =========================================================

		public Task WaitCustom(IAsakiWaitSource waitSource, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			// UniTask 路径：使用 ToUniTask 或手动轮询
			// 为了保持一致性，且 IAsakiWaitSource 是 C# 接口，我们依然需要轮询
			// 但 UniTask 的轮询开销极低
			return WaitCustomUniTask(waitSource, linkedToken).AsTask();
			#else
            // Native 路径：使用 RunRoutine 下沉到协程
            return RunRoutine(WaitCustomRoutine(waitSource), linkedToken);
			#endif
		}

		#if ASAKI_USE_UNITASK
		private async UniTask WaitCustomUniTask(IAsakiWaitSource source, CancellationToken token)
		{
			while (!source.IsCompleted)
			{
				source.Update();
				await UniTask.Yield(PlayerLoopTiming.Update, token);
			}
		}
		#endif

		/// <summary>
		/// [内部协程] 将 Update 循环下沉到 Unity 引擎层
		/// </summary>
		private IEnumerator WaitCustomRoutine(IAsakiWaitSource source)
		{
			while (!source.IsCompleted)
			{
				// 执行用户的自定义 Update 逻辑
				source.Update();

				// 等待一帧 (0 GC)
				yield return null;
			}
		}

		// =========================================================
		// 5. Builder 实现 (无需修改，逻辑正确)
		// =========================================================

		public IWaitBuilder CreateWaitBuilder()
		{
			return new AsakiWaitBuilder(this);
		}

		private class AsakiWaitBuilder : IWaitBuilder
		{
			private readonly IAsakiCoroutineService _service;
			private readonly List<Func<CancellationToken, Task>> _steps = new List<Func<CancellationToken, Task>>();

			public AsakiWaitBuilder(IAsakiCoroutineService service)
			{
				_service = service;
			}

			public IWaitBuilder Seconds(float seconds, bool unscaled = false)
			{
				_steps.Add(ct => unscaled
					? _service.WaitSecondsUnscaled(seconds, ct)
					: _service.WaitSeconds(seconds, ct));
				return this;
			}

			public IWaitBuilder Frames(int count)
			{
				_steps.Add(ct => _service.WaitFrames(count, ct));
				return this;
			}

			public IWaitBuilder FixedFrames(int count)
			{
				_steps.Add(ct => _service.WaitFixedFrames(count, ct));
				return this;
			}

			public IWaitBuilder Until(Func<bool> condition)
			{
				_steps.Add(ct => _service.WaitUntil(condition, ct));
				return this;
			}

			public IWaitBuilder While(Func<bool> condition)
			{
				_steps.Add(ct => _service.WaitWhile(condition, ct));
				return this;
			}

			public async Task Build(CancellationToken token = default(CancellationToken))
			{
				// 这里再次 Link 是为了安全，确保 Builder 执行过程中的取消能被响应
				CancellationToken linkedToken = _service.CreateLinkedToken(token);

				foreach (var step in _steps)
				{
					if (linkedToken.IsCancellationRequested) break;
					await step(linkedToken);
				}
			}
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiRoutineProvider.Time.cs -->
<!-- GUID: 57e39c58841244bb82d1220bc3df61e1 -->
<!-- Size: 8280 bytes -->
<!-- Modified: 2025-12-26 21:44:44 -->
```csharp
using Cysharp.Threading.Tasks; // 如果没有定义宏，这行会被忽略或报错，但在 Asaki 中通常通过 ASMDEF 隔离
using System;
using System.Collections; // 必须引用
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace Asaki.Unity.Services.Coroutines
{
	/// <summary>
	/// [异步服务实现] Part 2: Time & Wait (Native Refactored)
	/// <para>V5.0 重构版：抛弃 Task.Yield 轮询，全面拥抱 Unity 原生 Coroutine。</para>
	/// </summary>
	public partial class AsakiCoroutineProvider
	{
		// =========================================================
		// 1. 辅助协程实现 (Impls)
		// 这里的很多指令是 YieldInstruction，需要包裹在 IEnumerator 中
		// =========================================================

		private IEnumerator WaitForSecondsImpl(float seconds)
		{
			yield return new WaitForSeconds(seconds);
		}

		private IEnumerator WaitForSecondsRealtimeImpl(float seconds)
		{
			yield return new WaitForSecondsRealtime(seconds);
		}

		private IEnumerator WaitFramesImpl(int count)
		{
			for (int i = 0; i < count; i++) yield return null;
		}

		private IEnumerator WaitFixedFramesImpl(int count)
		{
			WaitForFixedUpdate wait = new WaitForFixedUpdate();
			for (int i = 0; i < count; i++) yield return wait;
		}

		private IEnumerator WaitUntilImpl(Func<bool> predicate)
		{
			yield return new WaitUntil(predicate);
		}

		private IEnumerator WaitWhileImpl(Func<bool> predicate)
		{
			yield return new WaitWhile(predicate);
		}

		// =========================================================
		// 2. 时间等待 (Time)
		// =========================================================

		public Task WaitSeconds(float seconds, CancellationToken token = default(CancellationToken))
		{
			// 1. 链接 Token
			CancellationToken linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			return UniTask.Delay(TimeSpan.FromSeconds(seconds), DelayType.DeltaTime, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			// 2. 快速路径：时间为0或已取消
			if (seconds <= 0) return Task.CompletedTask;
			
			// 3. 桥接到原生协程
			return RunRoutine(WaitForSecondsImpl(seconds), linkedToken);
			#endif
		}

		public Task WaitSecondsUnscaled(float seconds, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			return UniTask.Delay(TimeSpan.FromSeconds(seconds), DelayType.UnscaledDeltaTime, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			if (seconds <= 0) return Task.CompletedTask;
			return RunRoutine(WaitForSecondsRealtimeImpl(seconds), linkedToken);
			#endif
		}

		// =========================================================
		// 3. 帧等待 (Frames)
		// =========================================================

		public Task WaitFrame(CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.Yield(PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			// 这里的 1 代表等待 1 帧 (yield return null)
			return RunRoutine(WaitFramesImpl(1), linkedToken);
			#endif
		}

		public Task WaitFrames(int count, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.DelayFrame(count, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			if (count <= 0) return Task.CompletedTask;
			return RunRoutine(WaitFramesImpl(count), linkedToken);
			#endif
		}

		public Task WaitFixedFrame(CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.Yield(PlayerLoopTiming.FixedUpdate, linkedToken).AsTask();
			#else
			return RunRoutine(WaitFixedFramesImpl(1), linkedToken);
			#endif
		}

		public Task WaitFixedFrames(int count, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.DelayFrame(count, PlayerLoopTiming.FixedUpdate, linkedToken).AsTask();
			#else
			if (count <= 0) return Task.CompletedTask;
			return RunRoutine(WaitFixedFramesImpl(count), linkedToken);
			#endif
		}

		// =========================================================
		// 4. 条件等待 (Conditions)
		// =========================================================

		public Task WaitUntil(Func<bool> predicate, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.WaitUntil(predicate, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			return RunRoutine(WaitUntilImpl(predicate), linkedToken);
			#endif
		}

		public Task WaitWhile(Func<bool> predicate, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);
			#if ASAKI_USE_UNITASK
			return UniTask.WaitWhile(predicate, PlayerLoopTiming.Update, linkedToken).AsTask();
			#else
			return RunRoutine(WaitWhileImpl(predicate), linkedToken);
			#endif
		}

		// =========================================================
		// 5. 复杂逻辑：带超时的等待 (Complex Logic)
		// =========================================================

		public async Task<bool> WaitUntil(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken))
		{
			CancellationToken linkedToken = CreateLinkedToken(token);

			#if ASAKI_USE_UNITASK
			try
			{
				await UniTask.WaitUntil(predicate, PlayerLoopTiming.Update, linkedToken)
				             .Timeout(TimeSpan.FromSeconds(timeoutSeconds));
				return true;
			}
			catch (TimeoutException) { return false; }
			catch (OperationCanceledException) { return false; } // 根据需求，取消也可以视为"未成功"
			#else
			// === Native Implementation ===
			// 这是一个手动构建的"有返回值"的桥接器

			// 1. 快速检查
			if (linkedToken.IsCancellationRequested) return false;
			if (_runner == null) return false;

			// 2. 创建 TCS (返回 bool)
			var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);

			// 3. 启动协程引用
			Coroutine activeCoroutine = null;

			// 4. 注册取消回调
			using (linkedToken.Register(() => 
			{
				if (activeCoroutine != null && _runner != null) _runner.StopCoroutine(activeCoroutine);
				tcs.TrySetCanceled(linkedToken);
			}))
			{
				// 5. 启动自定义的超时协程
				activeCoroutine = _runner.StartCoroutine(WaitUntilTimeoutRoutine(predicate, timeoutSeconds, tcs));

				try 
				{
					return await tcs.Task;
				}
				catch (OperationCanceledException)
				{
					return false;
				}
			}
			#endif
		}

		/// <summary>
		/// [内部协程] 执行带超时的条件等待
		/// </summary>
		private IEnumerator WaitUntilTimeoutRoutine(Func<bool> predicate, float timeout, TaskCompletionSource<bool> tcs)
		{
			float timer = 0f;

			// 核心循环：完全在 Unity 协程调度器中运行
			// 相比 C# 的 Task.Yield 循环，这里避免了大量的 Task 状态机上下文切换
			while (timer < timeout)
			{
				// 检查条件
				if (predicate())
				{
					tcs.TrySetResult(true); // 成功
					yield break;
				}

				// 如果外部 Task 已经被取消 (通过 Register 回调)，则退出协程
				if (tcs.Task.IsCanceled) yield break;

				// 等待下一帧 (原生 Unity 等待)
				yield return null;

				// 累加时间
				timer += Time.deltaTime;
			}

			// 循环结束仍未满足 -> 超时
			tcs.TrySetResult(false);
		}

		public async Task<bool> WaitWhile(Func<bool> predicate, float timeoutSeconds, CancellationToken token = default(CancellationToken))
		{
			// 复用 WaitUntil 的逻辑，只是条件取反
			return await WaitUntil(() => !predicate(), timeoutSeconds, token);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Coroutines/AsakiTaskVoid.cs -->
<!-- GUID: 3cf83cadeb054bcaa74e4e1179ec69bb -->
<!-- Size: 2932 bytes -->
<!-- Modified: 2025-12-26 21:44:42 -->
```csharp
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Asaki.Core.Tasks
{
	/// <summary>
	/// [Asaki Native] 轻量级异步 void 替代方案。
	/// <para>用于 "Fire-and-Forget" 场景。</para>
	/// <para>相比 async void，它能捕获并记录未处理的异常，防止程序崩溃或异常静默丢失。</para>
	/// </summary>
	[AsyncMethodBuilder(typeof(AsakiTaskVoidMethodBuilder))]
	public readonly struct AsakiTaskVoid
	{
		/// <summary>
		/// 显式调用此方法以消除 "调用未等待" 的编译器警告。
		/// </summary>
		public void Forget()
		{
			// 纯语义方法，运行时无操作
		}
	}

	/// <summary>
	/// [Internal] 负责构建 AsakiTaskVoid 状态机的构建器。
	/// 核心逻辑在于 SetException 时将异常输出到 Unity 控制台。
	/// </summary>
	public struct AsakiTaskVoidMethodBuilder
	{
		// 1. 创建构建器实例 (编译器调用)
		public static AsakiTaskVoidMethodBuilder Create()
		{
			return default(AsakiTaskVoidMethodBuilder);
		}

		// 2. 返回给调用者的对象 (编译器调用)
		public AsakiTaskVoid Task => default(AsakiTaskVoid);

		// 3. 状态机启动 (编译器调用)
		[DebuggerHidden]
		public void Start<TStateMachine>(ref TStateMachine stateMachine)
			where TStateMachine : IAsyncStateMachine
		{
			stateMachine.MoveNext();
		}

		// 4. 关联状态机 (编译器调用 - 仅在类模式下使用，Struct模式下通常为空)
		public void SetStateMachine(IAsyncStateMachine stateMachine) { }

		// 5. 任务成功完成时调用
		public void SetResult()
		{
			// Do nothing - void 任务不需要结果
		}

		// 6. [核心] 任务抛出未处理异常时调用
		public void SetException(Exception exception)
		{
			// 在这里拦截了原本会导致 async void 崩溃或静默失败的异常
			// 强制输出到 Unity 控制台
			AsakiTaskExceptionLogger.Log(exception);
		}

		// 7. 处理 await (常规)
		public void AwaitOnCompleted<TAwaiter, TStateMachine>(
			ref TAwaiter awaiter, ref TStateMachine stateMachine)
			where TAwaiter : INotifyCompletion
			where TStateMachine : IAsyncStateMachine
		{
			awaiter.OnCompleted(stateMachine.MoveNext);
		}

		// 8. 处理 await (不安全/高性能)
		public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(
			ref TAwaiter awaiter, ref TStateMachine stateMachine)
			where TAwaiter : ICriticalNotifyCompletion
			where TStateMachine : IAsyncStateMachine
		{
			awaiter.UnsafeOnCompleted(stateMachine.MoveNext);
		}
	}

	/// <summary>
	/// [Internal] 简单的异常日志记录器
	/// </summary>
	internal static class AsakiTaskExceptionLogger
	{
		public static void Log(Exception ex)
		{
			// 你可以在这里扩展，比如上报到服务器或弹出错误窗口
			UnityEngine.Debug.LogException(ex);
		}
	}
}
```

<!-- File: Asaki/Unity/Services/Network/AsakiWebService.cs -->
<!-- GUID: 328fe65ba5de4854bf434418ffe8adc7 -->
<!-- Size: 4775 bytes -->
<!-- Modified: 2025-12-26 21:45:06 -->
```csharp
using Asaki.Core.Network;
using Asaki.Core.Serialization;
using Asaki.Unity.Extensions;
using Asaki.Unity.Services.Network.Interceptors;
using Asaki.Unity.Services.Serialization;
using Asaki.Unity.Utils;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace Asaki.Unity.Services.Network
{
	public class AsakiWebService : IAsakiWebService
	{
		private string _baseUrl = "";
		private int _timeout = 10;
		private readonly List<IAsakiWebInterceptor> _interceptors = new List<IAsakiWebInterceptor>();
		public void OnInit()
		{
			AddInterceptor(new AsakiLogInterceptor());
		}

		public Task OnInitAsync()
		{
			return Task.CompletedTask;
		}
		public void OnDispose()
		{
			_interceptors.Clear();
		}

		public void SetBaseUrl(string url)
		{
			_baseUrl = url.TrimEnd('/');
		}
		public void SetTimeout(int seconds)
		{
			_timeout = seconds;
		}
		public void AddInterceptor(IAsakiWebInterceptor interceptor)
		{
			if (!_interceptors.Contains(interceptor)) _interceptors.Add(interceptor);
		}
		public void RemoveInterceptor(IAsakiWebInterceptor interceptor)
		{
			_interceptors.Remove(interceptor);
		}

		public async Task<TResponse> GetAsync<TResponse>(string apiPath)
			where TResponse : IAsakiSavable, new()
		{
			string url = BuildUrl(apiPath);
			using (UnityWebRequest uwr = UnityWebRequest.Get(url))
			{
				ConfigureRequest(uwr);
				foreach (IAsakiWebInterceptor i in _interceptors) i.OnRequest(uwr);

				// 使用扩展方法桥接 UnityWebRequest 到 Task
				await uwr.SendWebRequestAsTask();

				return ProcessResponse<TResponse>(uwr);
			}
		}

		public async Task<TResponse> PostAsync<TRequest, TResponse>(string apiPath, TRequest body) where TRequest : IAsakiSavable where TResponse : IAsakiSavable, new()
		{
			string url = BuildUrl(apiPath);
			string jsonBody = SerializeRequest(body);
			byte[] bodyRaw = Encoding.UTF8.GetBytes(jsonBody);

			using (UnityWebRequest uwr = new UnityWebRequest(url, "POST"))
			{
				uwr.uploadHandler = new UploadHandlerRaw(bodyRaw);
				uwr.downloadHandler = new DownloadHandlerBuffer();
				uwr.SetRequestHeader("Content-Type", "application/json");

				ConfigureRequest(uwr);
				foreach (IAsakiWebInterceptor i in _interceptors) i.OnRequest(uwr);

				await uwr.SendWebRequestAsTask();

				return ProcessResponse<TResponse>(uwr);
			}
		}

		public async Task<TResponse> PostFormAsync<TResponse>(string apiPath, WWWForm form) where TResponse : IAsakiSavable, new()
		{
			string url = BuildUrl(apiPath);
			using (UnityWebRequest uwr = UnityWebRequest.Post(url, form))
			{
				ConfigureRequest(uwr);
				foreach (IAsakiWebInterceptor i in _interceptors) i.OnRequest(uwr);

				await uwr.SendWebRequestAsTask();

				return ProcessResponse<TResponse>(uwr);
			}
		}

		// =========================================================
		// 内部逻辑
		// =========================================================

		private string BuildUrl(string apiPath)
		{
			if (apiPath.StartsWith("http") || string.IsNullOrEmpty(_baseUrl)) return apiPath;
			return $"{_baseUrl}/{apiPath.TrimStart('/')}";
		}

		private void ConfigureRequest(UnityWebRequest uwr)
		{
			uwr.timeout = _timeout;
		}

		private string SerializeRequest<T>(T body) where T : IAsakiSavable
		{
			StringBuilder sb = AsakiStringBuilderPool.Rent();
			try
			{
				AsakiJsonWriter writer = new AsakiJsonWriter(sb);
				body.Serialize(writer);
				return writer.GetResult();
			}
			finally { AsakiStringBuilderPool.Return(sb); }
		}

		private T ProcessResponse<T>(UnityWebRequest uwr) where T : IAsakiSavable, new()
		{
			// 错误检查
			if (uwr.result == UnityWebRequest.Result.ConnectionError ||
			    uwr.result == UnityWebRequest.Result.ProtocolError)
			{
				AsakiWebException ex = new AsakiWebException(uwr.error, uwr.responseCode, uwr.url);
				foreach (IAsakiWebInterceptor i in _interceptors) i.OnError(uwr, ex);
				throw ex;
			}

			// 业务拦截
			foreach (IAsakiWebInterceptor i in _interceptors)
			{
				if (!i.OnResponse(uwr))
					throw new AsakiWebException("Intercepted", uwr.responseCode, uwr.url);
			}

			// 反序列化
			string json = uwr.downloadHandler.text;
			if (string.IsNullOrEmpty(json)) return default(T);

			try
			{
				AsakiJsonReader reader = AsakiJsonReader.FromJson(json);
				T response = new T();
				response.Deserialize(reader);
				return response;
			}
			catch (Exception ex)
			{
				Debug.LogError($"[AsakiWeb] Parse Error: {ex.Message}\n{json}"); // TODO: [Asaki] -> Asaki.ALog.Error
				throw;
			}
		}
	}
}
```

<!-- File: Game/Examples/AsakiWebTest.cs -->
<!-- GUID: ed48897f36514de7942ac499b8e48e7d -->
<!-- Size: 3936 bytes -->
<!-- Modified: 2025-12-26 23:14:12 -->
```csharp
using Asaki.Core.Context;
using Asaki.Core.Network;
using Asaki.Core.Serialization;
using System;
using UnityEngine;

namespace Game.Examples
{
	// =========================================================
	// 1. 定义 DTO (模拟 Roslyn 生成的代码)
	// =========================================================

	// 模拟登录请求
	public class MockLoginReq : IAsakiSavable
	{
		public string Username;
		public string Password;
		public int ClientVersion;

		public void Serialize(IAsakiWriter writer)
		{
			writer.BeginObject("MockLoginReq");
			writer.WriteString("Username", Username);
			writer.WriteString("Password", Password);
			writer.WriteInt("ClientVersion", ClientVersion);
			writer.EndObject();
		}

		public void Deserialize(IAsakiReader reader)
		{
			Username = reader.ReadString("Username");
			Password = reader.ReadString("Password");
			ClientVersion = reader.ReadInt("ClientVersion");
		}
	}

	// 模拟 HttpBin 的响应结构
	// HttpBin 会把我们发的 json 放在 "json" 字段里返回
	public class HttpBinResponse : IAsakiSavable
	{
		public string origin; // 请求IP
		public string url;
		public MockLoginReq json; // 嵌套对象测试

		public void Serialize(IAsakiWriter writer)
		{ /* 只读，不需要写 */
		}

		public void Deserialize(IAsakiReader reader)
		{
			origin = reader.ReadString("origin");
			url = reader.ReadString("url");
			// 测试嵌套反序列化
			json = reader.ReadObject<MockLoginReq>("json");
		}
	}

	// =========================================================
	// 2. 测试逻辑
	// =========================================================

	public class AsakiWebTest : MonoBehaviour
	{
		private IAsakiWebService _webService;

		private void Start()
		{
			_webService = AsakiContext.Get<IAsakiWebService>();
		}


		[ContextMenu("Run Web Test")]
		public async void RunTest()
		{
			Debug.Log("<color=yellow>[AsakiWebTest] === Start Integration Test ===</color>");

			try
			{
				// --- Step 1: 测试 POST JSON ---
				Debug.Log("[Test 1] Testing POST JSON...");

				var req = new MockLoginReq
				{
					Username = "AsakiUser",
					Password = "SuperSecretPassword",
					ClientVersion = 500
				};

				// 发送请求
				var res = await _webService.PostAsync<MockLoginReq, HttpBinResponse>("post", req);

				// 验证结果
				if (res.json != null && res.json.Username == "AsakiUser")
				{
					Debug.Log($"<color=green>[Success] POST Response Validated!</color>\nEcho IP: {res.origin}");
				}
				else
				{
					Debug.LogError("[Fail] POST Response Data Mismatch!");
				}

				// --- Step 2: 测试 GET (模拟) ---
				Debug.Log("[Test 2] Testing GET...");
				// httpbin/get 返回结构类似，我们复用 HttpBinResponse 里的 url 字段验证
				var getRes = await _webService.GetAsync<HttpBinResponse>("get?foo=bar");

				if (getRes.url.Contains("foo=bar"))
				{
					Debug.Log($"<color=green>[Success] GET Response Validated!</color>\nURL: {getRes.url}");
				}
				else
				{
					Debug.LogError("[Fail] GET Response URL Mismatch");
				}

				// --- Step 3: 测试异常捕获 (404) ---
				Debug.Log("[Test 3] Testing Error Handling (404)...");
				try
				{
					await _webService.GetAsync<HttpBinResponse>("status/404");
					Debug.LogError("[Fail] Should verify 404 but got success!");
				}
				catch (AsakiWebException ex)
				{
					if (ex.ResponseCode == 404)
					{
						Debug.Log($"<color=green>[Success] Caught expected 404 error: {ex.Message}</color>");
					}
					else
					{
						Debug.LogError($"[Fail] Caught wrong error code: {ex.ResponseCode}");
					}
				}

			}
			catch (Exception e)
			{
				Debug.LogError($"[Critical Fail] Unexpected Exception: {e}");
			}

			Debug.Log("<color=yellow>[AsakiWebTest] === Test Finished ===</color>");
		}
	}
}
```

```
