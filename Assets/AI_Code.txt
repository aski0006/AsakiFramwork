namespace Asaki.Core.Logging
{
	/// <summary>
	/// 日志最小原子单元。
	/// 设计为 Struct 以减少堆内存分配，在并发队列中传递值的副本。
	/// </summary>
	public struct AsakiLogEntry
	{
		/// <summary>
		/// UTC 时间戳 (Ticks)
		/// </summary>
		public long Timestamp;

		/// <summary>
		/// 线程 ID
		/// </summary>
		public int ThreadId;

		/// <summary>
		/// 日志级别
		/// </summary>
		public AsakiLogLevel Level;

		/// <summary>
		/// 日志内容
		/// </summary>
		public string Message;
        
		/// <summary>
		/// 结构化数据载荷 (可选)
		/// </summary>
		public string PayloadJson;

		// --- 零反射调用点信息 ---

		/// <summary>
		/// 调用方文件绝对路径 (Compiler Generated)
		/// </summary>
		public string CallerPath;

		/// <summary>
		/// 调用方行号 (Compiler Generated)
		/// </summary>
		public int CallerLine;

		/// <summary>
		/// 调用方成员/方法名 (Compiler Generated)
		/// </summary>
		public string CallerMember;

		// [新增] 完整堆栈信息 (用于 Unity 拦截日志 或 ALog.Error)
		public string StackTrace;
	}
}

namespace Asaki.Core.Logging
{
	/// <summary>
	/// 日志级别定义 (Asaki Native)
	/// </summary>
	public enum AsakiLogLevel
	{
		Verbose = 0,
		Debug = 1,
		Info = 2,
		Warning = 3,
		Error = 4,
		Fatal = 5,
        
		/// <summary>
		/// 关闭所有日志
		/// </summary>
		None = 99
	}
}

using System;
using Asaki.Core.Context; // 引用您现有的 Context 命名空间

namespace Asaki.Core.Logging
{
	/// <summary>
	/// 日志服务后端接口。
	/// 负责实际的队列管理、IO 写入和生命周期维护。
	/// </summary>
	public interface IAsakiLoggingService : IAsakiService, IDisposable
	{
		/// <summary>
		/// 设置当前的日志过滤级别
		/// </summary>
		void SetLevel(AsakiLogLevel level);

		/// <summary>
		/// 将日志推入处理队列 (非阻塞)
		/// </summary>
		/// <param name="level">级别</param>
		/// <param name="message">消息内容</param>
		/// <param name="callerPath">文件路径 (自动注入)</param>
		/// <param name="callerLine">行号 (自动注入)</param>
		/// <param name="callerMember">方法名 (自动注入)</param>
		/// <param name="payload">结构化数据</param>
		/// <param name="stackTrace">堆栈信息 (自动注入)</param>
		void Enqueue(AsakiLogLevel level, string message, string callerPath, int callerLine, string callerMember, object payload = null, string stackTrace = null);

		/// <summary>
		/// 紧急同步写入。
		/// 通常在崩溃或应用退出时调用，阻塞线程直到缓冲区清空。
		/// </summary>
		void FlushSync();
	}
}

using Asaki.Core.Logging;
using System.Runtime.CompilerServices;

// 放在根命名空间或 Asaki 命名空间下，方便调用
namespace Asaki.Unity.Services.Logging
{
    /// <summary>
    /// Asaki Logging System 静态门面。
    /// <para>生命周期严格受控：仅在 IAsakiLoggingService 实例存活期间有效。</para>
    /// </summary>
    public static class ALog
    {
        private static IAsakiLoggingService _backend;

        /// <summary>
        /// [Internal] 注册后端实例。通常由 AsakiLoggingService.OnInitialize 调用。
        /// </summary>
        internal static void RegisterBackend(IAsakiLoggingService backend)
        {
            _backend = backend;
        }

        /// <summary>
        /// [Internal] 重置后端。通常由 AsakiLoggingService.OnDestroy/Dispose 调用。
        /// 防止静态引用导致的内存泄漏或野指针访问。
        /// </summary>
        internal static void Reset()
        {
            _backend = null;
        }

        #region Public API

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Debug(string message, object payload = null,
            [CallerFilePath] string file = "",
            [CallerLineNumber] int line = 0,
            [CallerMemberName] string member = "")
        {
            if (_backend == null) return;
            _backend.Enqueue(AsakiLogLevel.Debug, message, file, line, member, payload);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Info(string message, object payload = null,
            [CallerFilePath] string file = "",
            [CallerLineNumber] int line = 0,
            [CallerMemberName] string member = "")
        {
            if (_backend == null) return;
            _backend.Enqueue(AsakiLogLevel.Info, message, file, line, member, payload);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Warn(string message, object payload = null,
            [CallerFilePath] string file = "",
            [CallerLineNumber] int line = 0,
            [CallerMemberName] string member = "")
        {
            if (_backend == null) return;
            _backend.Enqueue(AsakiLogLevel.Warning, message, file, line, member, payload);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Error(string message, object payload = null,
            [CallerFilePath] string file = "",
            [CallerLineNumber] int line = 0,
            [CallerMemberName] string member = "")
        {
            if (_backend == null) return;
            _backend.Enqueue(AsakiLogLevel.Error, message, file, line, member, payload);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Fatal(string message, object payload = null,
            [CallerFilePath] string file = "",
            [CallerLineNumber] int line = 0,
            [CallerMemberName] string member = "")
        {
            if (_backend == null) return;
            _backend.Enqueue(AsakiLogLevel.Fatal, message, file, line, member, payload);
        }

        #endregion
    }
}

using Asaki.Core.Logging;
using System;

namespace Asaki.Unity.Services.Logging
{
	public partial class AsakiLoggingService
	{
		#if UNITY_EDITOR
		public static event Action<AsakiLogEntry> OnLogBroadcast;
		#endif
	}
}

using Asaki.Core.Logging;
using Asaki.Core.Serialization;
using Asaki.Unity.Services.Serialization;
using Asaki.Unity.Utils;
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using UnityEngine;

namespace Asaki.Unity.Services.Logging
{
	public partial class AsakiLoggingService : IAsakiLoggingService
	{
		// 默认配置
		private const int DEFAULT_MAX_FILE_SIZE = 1 * 1024 * 1024;
		private const int DEFAULT_HISTORY_SESSIONS = 3;
		private const string DEFAULT_DATE_FORMAT = "yyyyMMdd_HHmmss";

		// 运行时配置
		private readonly int _maxFileSize;
		private readonly int _maxHistorySessions;
		private readonly string _sessionDateFormat;

		private AsakiLogLevel _currentLevel = AsakiLogLevel.Debug;
		private readonly ConcurrentQueue<AsakiLogEntry> _queue = new ConcurrentQueue<AsakiLogEntry>();
		private readonly AutoResetEvent _signal = new AutoResetEvent(false);

		// [优化] 线程静态缓存 Writer，彻底消除每次 Log 的 GC 分配
		// 每个调用 SerializePayload 的线程都会维护自己的 Writer 实例
		[ThreadStatic]
		private static AsakiJsonWriter _cachedWriter;

		private Thread _writerThread;
		private volatile bool _isRunning = false;

		private string _sessionDir;
		private string _currentLogPath;
		private int _fileIndex = 0;

		// 构造函数：支持动态配置注入
		public AsakiLoggingService(int maxFileSize = DEFAULT_MAX_FILE_SIZE,
		                           int maxHistorySessions = DEFAULT_HISTORY_SESSIONS,
		                           string sessionDateFormat = DEFAULT_DATE_FORMAT)
		{
			_maxFileSize = maxFileSize;
			_maxHistorySessions = maxHistorySessions;
			_sessionDateFormat = sessionDateFormat;
		}

		public void OnInitialize()
		{
			SetupSessionDirectory();
			ALog.RegisterBackend(this);

			_isRunning = true;
			_writerThread = new Thread(WriteLoop)
			{
				IsBackground = true,
				Name = "AsakiLogWriter",
				Priority = System.Threading.ThreadPriority.BelowNormal
			};
			_writerThread.Start();

			RegisterCrashHooks();

			ALog.Info($"Asaki Log Service Initialized. Root: {_sessionDir}");
		}

		public void SetLevel(AsakiLogLevel level) => _currentLevel = level;

		public void Enqueue(AsakiLogLevel level, string message, string callerPath, int callerLine, string callerMember, object payload = null, string stackTrace = null)
		{
			if (level < _currentLevel) return;

			string payloadJson = SerializePayload(payload);

			var entry = new AsakiLogEntry
			{
				Timestamp = DateTime.UtcNow.Ticks,
				ThreadId = Thread.CurrentThread.ManagedThreadId,
				Level = level,
				Message = message,
				CallerPath = callerPath,
				CallerLine = callerLine,
				CallerMember = callerMember,
				PayloadJson = payloadJson,
				StackTrace = stackTrace // [新增] 填充堆栈
			};

			_queue.Enqueue(entry);
			_signal.Set();

			// Editor 广播
			#if UNITY_EDITOR
			OnLogBroadcast?.Invoke(entry);
			#endif
		}

		public void FlushSync()
		{
			try { ProcessQueueToFile(forceFlush: true); }
			catch
			{ /* Crash safety first */
			}
		}

		public void Dispose()
		{
			if (!_isRunning) return;

			Application.logMessageReceivedThreaded -= OnUnityLogMessage;
			AppDomain.CurrentDomain.UnhandledException -= OnUncaughtException;
			ALog.Reset();

			_isRunning = false;
			_signal.Set();
			_writerThread?.Join(500);
			_signal.Dispose();
		}

		// =========================================================
		// 私有逻辑
		// =========================================================

		private void WriteLoop()
		{
			CreateNewLogFile();
			while (_isRunning)
			{
				_signal.WaitOne();
				if (!_isRunning && _queue.IsEmpty) break;
				ProcessQueueToFile(forceFlush: false);
			}
			ProcessQueueToFile(forceFlush: true);
		}

		private void ProcessQueueToFile(bool forceFlush)
		{
			if (string.IsNullOrEmpty(_currentLogPath)) return;

			var sb = AsakiStringBuilderPool.Rent();
			try
			{
				// FileShare.ReadWrite 允许外部工具（如 Notepad++ / Tail）实时查看日志
				using (var fs = new FileStream(_currentLogPath, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
				using (var sw = new StreamWriter(fs, Encoding.UTF8))
				{
					while (_queue.TryDequeue(out var entry))
					{
						sb.Clear();
						FormatLogEntry(sb, entry);
						sw.Write(sb.ToString());
						CheckFileRoll();
					}
				}
			}
			finally
			{
				AsakiStringBuilderPool.Return(sb);
			}
		}

		private void FormatLogEntry(StringBuilder sb, AsakiLogEntry entry)
		{
			var time = new DateTime(entry.Timestamp, DateTimeKind.Utc).ToLocalTime();

			sb.Append('[').Append(time.ToString("HH:mm:ss.fff")).Append(']');
			sb.Append('[').Append(entry.ThreadId).Append(']');
			sb.Append('[').Append(entry.Level.ToString()[0]).Append(']');
			sb.Append(' ').Append(entry.Message);

			if (entry.Level >= AsakiLogLevel.Warning && !string.IsNullOrEmpty(entry.CallerPath))
			{
				sb.Append(" @ ").Append(Path.GetFileName(entry.CallerPath)).Append(':').Append(entry.CallerLine);
			}

			// [修复] 这里的 entry.PayloadJson 是 string，不再报错
			if (!string.IsNullOrEmpty(entry.PayloadJson))
			{
				sb.AppendLine();
				sb.Append("\t=> ").Append(entry.PayloadJson);
			}

			sb.AppendLine();
		}

		// =========================================================
		// 文件与目录管理 (实现配置逻辑)
		// =========================================================

		private void SetupSessionDirectory()
		{
			string root = Path.Combine(Application.persistentDataPath, "Logs");
			if (!Directory.Exists(root)) Directory.CreateDirectory(root);

			// [新增] 清理历史 Session
			CleanupOldSessions(root);

			_sessionDir = Path.Combine(root, $"Session_{DateTime.Now.ToString(_sessionDateFormat)}");
			Directory.CreateDirectory(_sessionDir);
		}

		private void CleanupOldSessions(string rootPath)
		{
			try
			{
				var dirs = new DirectoryInfo(rootPath).GetDirectories("Session_*")
				                                      .OrderByDescending(d => d.CreationTime) // 按时间倒序，最新的在前
				                                      .ToList();

				// 如果超过最大数量，删除旧的
				if (dirs.Count >= _maxHistorySessions)
				{
					// 保留前 (Max - 1) 个，以便为当前新 Session 腾出位置
					// 比如 Max=3，这里保留最新的2个，加上当前创建的1个，总共3个
					for (int i = _maxHistorySessions - 1; i < dirs.Count; i++)
					{
						dirs[i].Delete(true);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogWarning($"[AsakiLog] Failed to cleanup old sessions: {ex.Message}");
			}
		}

		private void CreateNewLogFile()
		{
			_fileIndex++;
			_currentLogPath = Path.Combine(_sessionDir, $"Log_{_fileIndex:00}.log");
		}

		private void CheckFileRoll()
		{
			try
			{
				var info = new FileInfo(_currentLogPath);
				// [修复] 使用配置的 _maxFileSize
				if (info.Exists && info.Length > _maxFileSize) CreateNewLogFile();
			}
			catch { }
		}

		// =========================================================
		// 序列化与 Crash Hook
		// =========================================================

		/// <summary>
		/// 零 GC 序列化 Payload
		/// </summary>
		private string SerializePayload(object payload)
		{
			if (payload == null) return null;

			if (payload is IAsakiSavable savable)
			{
				var sb = AsakiStringBuilderPool.Rent();
				try
				{
					// [优化] 获取当前线程缓存的 Writer，如果没有则创建
					if (_cachedWriter == null)
					{
						// 第一次创建时传入 sb，但后续 Reset 会覆盖它
						_cachedWriter = new AsakiJsonWriter(sb);
					}
					else
					{
						// [核心] 复用 Writer，重置状态并指向新的 StringBuilder
						_cachedWriter.Reset(sb);
					}

					_cachedWriter.WriteObject(null, savable);
					return _cachedWriter.GetResult();
				}
				catch (Exception ex)
				{
					return $"[Serialization Error: {ex.Message}]";
				}
				finally
				{
					AsakiStringBuilderPool.Return(sb);
				}
			}

			return payload.ToString();
		}

		private void RegisterCrashHooks()
		{
			Application.logMessageReceivedThreaded += OnUnityLogMessage;
			AppDomain.CurrentDomain.UnhandledException += OnUncaughtException;
		}

		private void OnUnityLogMessage(string condition, string stack, LogType type)
		{
			if (type == LogType.Log || type == LogType.Warning) return;

			AsakiLogLevel level = type == LogType.Exception ? AsakiLogLevel.Fatal : AsakiLogLevel.Error;
			
			Enqueue(level, condition, null, 0, "UnityNative", null, stack);

			if (level == AsakiLogLevel.Fatal) FlushSync();
		}

		private void OnUncaughtException(object sender, UnhandledExceptionEventArgs e)
		{
			var ex = e.ExceptionObject as Exception;
			string msg = $"[UNCAUGHT] {ex?.Message}\nStack: {ex?.StackTrace}";
			Enqueue(AsakiLogLevel.Fatal, msg, "System", 0, "AppDomain", null);
			FlushSync();
		}
	}
}

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;
using Asaki.Core.Logging;
using Asaki.Editor.Utilities.Extensions;
using Asaki.Unity.Services.Logging;

namespace Asaki.Editor.Debugging
{
    public class AsakiLogDashboard : EditorWindow
    {
        // =========================================================
        // 1. 数据层
        // =========================================================
        [NonSerialized] private ConcurrentQueue<AsakiLogEntry> _incomingQueue;
        [NonSerialized] private List<AsakiLogEntry> _allLogs;
        [NonSerialized] private List<AsakiLogEntry> _filteredLogs;
        
        // 当前选中的日志（用于复制功能）
        [NonSerialized] private AsakiLogEntry? _selectedEntry;

        [SerializeField] private bool _isPaused;
        [SerializeField] private string _searchText = "";
        [SerializeField] private bool _showInfo = true;
        [SerializeField] private bool _showWarn = true;
        [SerializeField] private bool _showErr = true;
        [SerializeField] private bool _autoScroll = true;

        private ListView _listView;
        private ScrollView _stackTraceView;
        private Label _payloadLabel;

        // 正则：匹配 Unity 堆栈格式 (Namespace.Class:Method (Args) (at Path:Line))
        private static readonly Regex _unityStackRegex = new Regex(@"(.*)\s+\(.*\)\s+\(at\s+(.+):(\d+)\)", RegexOptions.Compiled);

        [MenuItem("Asaki/Debugger/Log Dashboard (V5)", false, 0)] 
        public static void ShowWindow()
        {
            var zombies = Resources.FindObjectsOfTypeAll<AsakiLogDashboard>();
            foreach (var zombie in zombies) { try { zombie.Close(); DestroyImmediate(zombie); } catch {} }

            var wnd = CreateInstance<AsakiLogDashboard>();
            wnd.titleContent = new GUIContent("Asaki Dashboard");
            wnd.minSize = new Vector2(900, 600);
            wnd.Show();
            wnd.Focus();
        }

        private void OnEnable()
        {
            InitDataContainers();
            AsakiLoggingService.OnLogBroadcast -= OnLogReceived;
            AsakiLoggingService.OnLogBroadcast += OnLogReceived;
            EditorApplication.update -= OnEditorUpdate;
            EditorApplication.update += OnEditorUpdate;
        }

        private void OnDisable()
        {
            AsakiLoggingService.OnLogBroadcast -= OnLogReceived;
            EditorApplication.update -= OnEditorUpdate;
        }

        private void InitDataContainers()
        {
            if (_incomingQueue == null) _incomingQueue = new ConcurrentQueue<AsakiLogEntry>();
            if (_allLogs == null) _allLogs = new List<AsakiLogEntry>(5000);
            if (_filteredLogs == null) _filteredLogs = new List<AsakiLogEntry>(5000);
        }

        private void OnLogReceived(AsakiLogEntry entry)
        {
            if (_incomingQueue == null) _incomingQueue = new ConcurrentQueue<AsakiLogEntry>();
            _incomingQueue.Enqueue(entry);
        }

        private void OnEditorUpdate()
        {
            if (_incomingQueue == null || _incomingQueue.IsEmpty) return;
            bool needsRefresh = false;
            if (_allLogs == null || _filteredLogs == null) InitDataContainers();

            while (_incomingQueue.TryDequeue(out var entry))
            {
                if (_isPaused) continue;
                _allLogs.Add(entry);
                if (IsMatch(entry))
                {
                    _filteredLogs.Add(entry);
                    needsRefresh = true;
                }
            }

            if (needsRefresh && _listView != null)
            {
                _listView.RefreshItems();
                if (_autoScroll && _listView.itemsSource.Count > 0)
                    _listView.ScrollToItem(_listView.itemsSource.Count - 1);
            }
        }

        // =========================================================
        // 2. UI 构建
        // =========================================================
        public void CreateGUI()
        {
            InitDataContainers();
            var root = rootVisualElement;
            root.style.backgroundColor = new Color(0.18f, 0.18f, 0.18f);

            // --- Toolbar ---
            var toolbar = new VisualElement();
            toolbar.style.flexDirection = FlexDirection.Row;
            toolbar.style.height = 32;
            toolbar.style.borderBottomWidth = 1;
            toolbar.style.borderBottomColor = new Color(0.1f, 0.1f, 0.1f);
            toolbar.style.alignItems = Align.Center;
            toolbar.style.paddingLeft = 8;
            toolbar.style.backgroundColor = new Color(0.25f, 0.25f, 0.25f);

            // 功能区
            toolbar.Add(CreateBtn("Clean", () => { _allLogs.Clear(); _filteredLogs.Clear(); _listView?.RefreshItems(); ClearDetail(); }, 50));
            toolbar.Add(new Label("|") { style = { color = Color.gray, marginLeft = 5, marginRight = 5 } });
            
            // [新增 1] 打开日志目录
            toolbar.Add(CreateBtn("Open Logs", () => {
                string path = System.IO.Path.Combine(Application.persistentDataPath, "Logs");
                EditorUtility.RevealInFinder(path);
            }, 80));
            
            // [新增 2] 复制当前日志
            toolbar.Add(CreateBtn("Copy Select", CopySelectedToClipboard, 80));

            toolbar.Add(new Label("|") { style = { color = Color.gray, marginLeft = 5, marginRight = 5 } });
            
            // 筛选区
            var scrollTog = new UnityEngine.UIElements.Toggle("Auto") { value = _autoScroll };
            scrollTog.RegisterValueChangedCallback(e => _autoScroll = e.newValue);
            toolbar.Add(scrollTog);

            var searchField = new TextField { value = _searchText, style = { width = 150, marginLeft = 10 } };
            searchField.RegisterValueChangedCallback(e => { _searchText = e.newValue.ToLower(); RebuildFilter(); });
            toolbar.Add(searchField);

            toolbar.Add(CreateToggle("I", _showInfo, v => { _showInfo = v; RebuildFilter(); }, new Color(0.4f, 0.7f, 1f)));
            toolbar.Add(CreateToggle("W", _showWarn, v => { _showWarn = v; RebuildFilter(); }, new Color(1f, 0.8f, 0.2f)));
            toolbar.Add(CreateToggle("E", _showErr, v => { _showErr = v; RebuildFilter(); }, new Color(1f, 0.4f, 0.4f)));

            root.Add(toolbar);

            // --- Split View ---
            var split = new TwoPaneSplitView(0, 350, TwoPaneSplitViewOrientation.Vertical);
            root.Add(split);

            // Log List
            _listView = new ListView();
            _listView.style.flexGrow = 1;
            _listView.fixedItemHeight = 26;
            _listView.makeItem = MakeLogItem;
            _listView.bindItem = BindLogItem;
            _listView.itemsSource = _filteredLogs;
            _listView.selectionType = SelectionType.Single;
            _listView.selectionChanged += OnLogSelected;
            split.Add(_listView);

            // Bottom Panel
            var bottomPanel = new VisualElement();
            bottomPanel.style.flexDirection = FlexDirection.Row;
            
            // [新增 3] Stack Trace (Gantt Style)
            var stackContainer = new VisualElement() { style = { flexGrow = 3, borderRightWidth = 1, borderRightColor = Color.black } };
            stackContainer.Add(new Label("Call Graph (Waterfall View)") { style = { unityFontStyleAndWeight = FontStyle.Bold, paddingLeft = 5, paddingTop = 2, color = new Color(0.7f, 0.7f, 0.7f) } });
            _stackTraceView = new ScrollView();
            stackContainer.Add(_stackTraceView);
            
            // Payload
            var payloadContainer = new VisualElement() { style = { flexGrow = 1, minWidth = 250 } };
            payloadContainer.Add(new Label("Data Payload") { style = { unityFontStyleAndWeight = FontStyle.Bold, paddingLeft = 5, paddingTop = 2, color = new Color(0.7f, 0.7f, 0.7f) } });
            var payloadScroll = new ScrollView();
            _payloadLabel = new Label() { style = { whiteSpace = WhiteSpace.Normal, fontSize = 12, color = new Color(0.7f, 0.9f, 0.7f) } };
            _payloadLabel.RegisterCallback<MouseDownEvent>(e => {
                if (e.clickCount == 2) { EditorGUIUtility.systemCopyBuffer = _payloadLabel.text; ALog.Info("Payload Copied"); }
            });
            payloadScroll.Add(_payloadLabel);
            payloadContainer.Add(payloadScroll);

            bottomPanel.Add(stackContainer);
            bottomPanel.Add(payloadContainer);
            split.Add(bottomPanel);
        }

        // =========================================================
        // 3. 逻辑处理 (筛选 & 复制)
        // =========================================================

        private void RebuildFilter()
        {
            if (_filteredLogs == null) _filteredLogs = new List<AsakiLogEntry>();
            if (_allLogs == null) _allLogs = new List<AsakiLogEntry>();

            _filteredLogs.Clear();
            foreach (var log in _allLogs) { if (IsMatch(log)) _filteredLogs.Add(log); }
            _listView?.RefreshItems();
        }

        private bool IsMatch(AsakiLogEntry entry)
        {
            if (entry.Level == AsakiLogLevel.Info && !_showInfo) return false;
            if (entry.Level == AsakiLogLevel.Warning && !_showWarn) return false;
            if ((entry.Level == AsakiLogLevel.Error || entry.Level == AsakiLogLevel.Fatal) && !_showErr) return false;
            if (!string.IsNullOrEmpty(_searchText))
            {
                bool msgMatch = entry.Message != null && entry.Message.ToLower().Contains(_searchText);
                bool pathMatch = entry.CallerPath != null && entry.CallerPath.ToLower().Contains(_searchText);
                if (!msgMatch && !pathMatch) return false;
            }
            return true;
        }

        private void CopySelectedToClipboard()
        {
            if (_selectedEntry == null) return;
            var e = _selectedEntry.Value;
            
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"[{e.Level}] {new DateTime(e.Timestamp).ToLocalTime()}");
            sb.AppendLine($"Message: {e.Message}");
            if (!string.IsNullOrEmpty(e.CallerPath)) sb.AppendLine($"Location: {e.CallerPath}:{e.CallerLine}");
            if (!string.IsNullOrEmpty(e.PayloadJson)) sb.AppendLine($"Payload: {e.PayloadJson}");
            if (!string.IsNullOrEmpty(e.StackTrace)) sb.AppendLine("Stack Trace:\n" + e.StackTrace);
            
            EditorGUIUtility.systemCopyBuffer = sb.ToString();
            ALog.Info("Log Entry copied to clipboard.");
        }

        // =========================================================
        // 4. Gantt/Waterfall 堆栈可视化 (核心升级)
        // =========================================================

        private void OnLogSelected(IEnumerable<object> selection)
        {
            var item = selection?.FirstOrDefault();
            if (item == null) { _selectedEntry = null; return; }
            
            var entry = (AsakiLogEntry)item;
            _selectedEntry = entry;

            // Payload
            _payloadLabel.text = !string.IsNullOrEmpty(entry.PayloadJson) ? PrettifyJson(entry.PayloadJson) : "";

            // Stack Visualization
            BuildWaterfallStack(entry);
        }

        private struct StackFrameInfo
        {
            public string Method;
            public string Path;
            public int Line;
            public bool IsUserCode;
            public bool IsAsaki;
            public string RawLine;
        }

        private void BuildWaterfallStack(AsakiLogEntry entry)
        {
            _stackTraceView.Clear();
            var frames = new List<StackFrameInfo>();

            // 1. 解析堆栈
            if (!string.IsNullOrEmpty(entry.StackTrace))
            {
                var lines = entry.StackTrace.Split('\n');
                foreach (var line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    var match = _unityStackRegex.Match(line);
                    if (match.Success)
                    {
                        string path = match.Groups[2].Value.Trim();
                        frames.Add(new StackFrameInfo {
                            Method = match.Groups[1].Value.Trim(),
                            Path = path,
                            Line = int.Parse(match.Groups[3].Value),
                            IsUserCode = path.Contains("Assets/"),
                            IsAsaki = match.Groups[1].Value.Contains("Asaki"),
                            RawLine = line
                        });
                    }
                    else
                    {
                        // 无法解析的行 (DLL调用) 也作为一个Frame，但不具备跳转能力
                        frames.Add(new StackFrameInfo { RawLine = line, Method = line.Trim() });
                    }
                }
            }
            else if (!string.IsNullOrEmpty(entry.CallerPath))
            {
                // 如果没有 StackTrace (如 Info)，使用 Caller 伪造一个单帧
                frames.Add(new StackFrameInfo {
                    Method = entry.CallerMember ?? "Log Call",
                    Path = entry.CallerPath,
                    Line = entry.CallerLine,
                    IsUserCode = true,
                    IsAsaki = false,
                    RawLine = "Manual Call"
                });
            }

            // 2. 倒序排列 (Root -> Leaf) 形成瀑布流
            // 注意：Unity 堆栈默认是 Top -> Bottom，我们反转它以显示从启动到报错的流程
            frames.Reverse();

            // 3. 绘制
            for (int i = 0; i < frames.Count; i++)
            {
                var frame = frames[i];
                AddGanttFrameUI(frame, i);
            }
        }

        private void AddGanttFrameUI(StackFrameInfo frame, int depth)
        {
            // 容器：行
            var row = new VisualElement();
            row.style.flexDirection = FlexDirection.Row;
            row.style.marginBottom = 1;
            row.style.alignItems = Align.Center;

            // 1. 缩进 (Waterfall Indentation)
            // 限制最大缩进防止溢出
            float indentSize = Mathf.Min(depth * 15, 200); 
            
            // 绘制连接线 (L型)
            var connector = new VisualElement();
            connector.style.width = indentSize;
            connector.style.height = 1; // 横线
            connector.style.backgroundColor = new Color(0.4f, 0.4f, 0.4f, 0.3f);
            connector.style.marginRight = 0;
            row.Add(connector);

            // 2. 交互块 (Bar)
            Button btn;
            if (!string.IsNullOrEmpty(frame.Path))
            {
                // 可跳转的代码帧
                btn = new Button(() => UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(frame.Path, frame.Line));
                btn.tooltip = $"{frame.Path}:{frame.Line}";
            }
            else
            {
                // 不可跳转的系统帧
                btn = new Button();
                btn.SetEnabled(false); // 禁用点击
            }

            // 样式设置
            btn.style.flexDirection = FlexDirection.Row;
            btn.style.height = 22;
            btn.style.SetBorderWidth(0);
            btn.style.borderTopLeftRadius = 0;
            btn.style.borderBottomLeftRadius = 0;
            btn.style.borderTopRightRadius = 4;
            btn.style.borderBottomRightRadius = 4;
            btn.style.alignItems = Align.Center;
            btn.style.paddingLeft = 6;
            btn.style.paddingRight = 10;
            btn.style.flexGrow = 0; // 不自动填充，保持甘特条形状

            // 颜色策略
            Color barColor;
            if (frame.IsAsaki) barColor = new Color(0.8f, 0.5f, 0.2f); // 橙色: 框架
            else if (frame.IsUserCode) barColor = new Color(0.2f, 0.5f, 0.7f); // 蓝色: 业务
            else barColor = new Color(0.25f, 0.25f, 0.25f); // 灰色: 引擎

            btn.style.backgroundColor = barColor;

            // 方法名
            var lbl = new Label(frame.Method);
            lbl.style.color = Color.white;
            lbl.style.fontSize = 11;
            btn.Add(lbl);

            // 行号 (右侧弱化显示)
            if (frame.Line > 0)
            {
                var lineLbl = new Label($":{frame.Line}");
                lineLbl.style.color = new Color(1,1,1,0.5f);
                lineLbl.style.fontSize = 10;
                lineLbl.style.marginLeft = 5;
                btn.Add(lineLbl);
            }

            row.Add(btn);
            _stackTraceView.Add(row);
        }

        // =========================================================
        // 5. 辅助方法
        // =========================================================

        private VisualElement MakeLogItem()
        {
            var row = new VisualElement();
            row.style.flexDirection = FlexDirection.Row;
            row.style.alignItems = Align.Center;
            row.style.paddingLeft = 6;
            row.style.borderBottomWidth = 1;
            row.style.borderBottomColor = new Color(0,0,0, 0.3f);

            var lvl = new VisualElement() { name = "icon", style = { width = 4, height = 18, marginRight = 6 } };
            var time = new Label() { name = "time", style = { width = 65, fontSize = 11, color = Color.gray } };
            var msg = new Label() { name = "msg", style = { flexGrow = 1, fontSize = 12 } };

            row.Add(lvl);
            row.Add(time);
            row.Add(msg);
            return row;
        }

        private void BindLogItem(VisualElement ele, int index)
        {
            if (_filteredLogs == null || index >= _filteredLogs.Count) return;
            var entry = _filteredLogs[index];

            var icon = ele.Q("icon");
            var msg = ele.Q<Label>("msg");
            var time = ele.Q<Label>("time");

            time.text = new DateTime(entry.Timestamp, DateTimeKind.Utc).ToLocalTime().ToString("HH:mm:ss");
            msg.text = entry.Message;

            Color c = Color.white;
            if (entry.Level == AsakiLogLevel.Info) { c = new Color(0.5f, 0.8f, 1f); }
            else if (entry.Level == AsakiLogLevel.Warning) { c = new Color(1f, 0.8f, 0.2f); }
            else if (entry.Level >= AsakiLogLevel.Error) { c = new Color(1f, 0.4f, 0.4f); }

            icon.style.backgroundColor = c;
            msg.style.color = c;
        }

        private Button CreateBtn(string txt, Action act, float width)
        {
            return new Button(act) { text = txt, style = { height = 20, width = width, backgroundColor = new Color(0.3f,0.3f,0.3f) } };
        }

        private UnityEngine.UIElements.Toggle CreateToggle(string label, bool val, Action<bool> onChange, Color c)
        {
            var t = new UnityEngine.UIElements.Toggle(label) { value = val, style = { marginLeft = 10 } };
            t.RegisterValueChangedCallback(e => onChange(e.newValue));
            t.Q<Label>().style.color = c;
            return t;
        }

        private void ClearDetail()
        {
            _stackTraceView.Clear();
            _payloadLabel.text = "";
            _selectedEntry = null;
        }

        private string PrettifyJson(string json)
        {
            return json.Replace(",", ",\n").Replace("{", "{\n").Replace("}", "\n}");
        }
    }
}